
### Incident disease analyses

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(results = 'asis')
```

## Data prep

```{r packages}
library(survival)
library(Hmisc)
library(pbapply)
library(mice)
library(data.table)
```

```{r path}
path <- "/path/to/file"

# set date for saving
date <- "nov_07_2022"
```

```{r load}
# load analysis datasets
load(paste0(path, "/datasets/ACM_final_analysis_datasets_aug_20_2022_all_data.RData"))

# load NCD data
load("/path/to/file/NCD_all_subsets_aug_04_2022.RData")

# load interview baseline dx data
load("/path/to/file/baseline_dx_data_july_07_2022.RData")

# load variable categories
categories <- read.csv("/path/to/file/Argentieri UKB dataset data dictionary.csv")

# load physical environment PCA results
load(paste0(path, "/results/physical_environment_PCA_nov_07_2022_all_sexes.RData"))

```

```{r survival_vars}

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))

### Create 5-year birth cohorts -------------------------------------------------------------------

# function to calculate birth cohorts
split_birth_year <- function(x){
  x$birth_cohort <- ifelse(
    x$birth_year >= 1935 & x$birth_year < 1940,
    "1935-1940",
    ifelse(
      x$birth_year >= 1940 & x$birth_year < 1945,
      "1940-1945",
      ifelse(
        x$birth_year >= 1945 & x$birth_year < 1950,
        "1945-1950",
        ifelse(
          x$birth_year >= 1950 & x$birth_year < 1955,
          "1950-1955",
          ifelse(
            x$birth_year >= 1955 & x$birth_year < 1960,
            "1955-1960",
            ifelse(
              x$birth_year >= 1960 & x$birth_year < 1965,
              "1960-1965",
              ifelse(
                x$birth_year >= 1965 & x$birth_year <= 1970, 
                "1965-1970", 
                NA
              )
            )
          )
        )
      )
    )
  )
    
    x$birth_cohort <- as.factor(x$birth_cohort)
    return(x)
}

# execute function across imputed datasets to create 5-year age bands
all_data <- lapply(all_data, split_birth_year)


### Scale -------------------------------------------------------------------

# scale function
scale_numeric <- function(x) { 
    # create logical vector of numeric columns
    nums <- sapply(x, is.numeric)
    
    # list of numeric variables to exclude from scaling
    scale_exclude <- c(
        Cs(
            recruitment_age,
            censor_age,
            ACM_event_indicator,
            eid,
            time,
            ACM_survival_time,
            hazard,
            birth_year,
            BMI
        )
    )
    
    # exclude those columns I don't want to scale
    nums[names(nums) %in% scale_exclude] <- FALSE # don't want to scale these
    
    # don't bother scaling other numeric cols not in analysis
    nums[names(nums) %nin% exposures] <- FALSE 
    
    # perform scale
    x[nums] <- scale(x[nums],
                     scale = TRUE)
    
    # return entire dataset
    return(x)
}

# scale desired numeric columns
all_data <- lapply(all_data, scale_numeric)

# set contrasts for regression
set_contrasts <- function(x) {
    
    # find ordered variables
    ord <- sapply(x, is.ordered)
    
    # set contrasts to only linear
    for (k in seq(ncol(x[ord]))) {
        contrasts(x[ord][[k]], how.many = 1) <- contr.poly(nlevels(x[ord][[k]]))
    }
    
    return(x)
    
}

# run in datasets
all_data <- lapply(all_data, set_contrasts)

```

```{r merge_disease_data}

# merge in PCA data
for (k in seq_along(all_data)) {
    all_data[[k]] <- merge(
        all_data[[k]],
        pca_dfs[[k]],
        by = "eid",
        sort = FALSE)
}

# merge ICD-10 data with ACM datasets
all_data_ncd <- lapply(all_data, function(x)
    as.data.frame(
        merge(x, 
              dat_NCD_all,
              by = "eid",
              all = FALSE,
              sort = FALSE)
    )
)

# merge baseline dx data with ACM datasets
all_data_ncd <- lapply(all_data_ncd, function(x)
    as.data.frame(
        merge(x, 
              dat_dx,
              by = "eid",
              all = FALSE,
              sort = FALSE)
    )
)

rm(pca_dfs, dat_dx, dat_NCD_all, all_data)
invisible(gc())
```

```{r}
for (k in seq_along(all_data_ncd)){
    all_data_ncd[[k]]$air_pollution_PC1 <- scale(all_data_ncd[[k]]$air_pollution_PC1, scale = TRUE)
    all_data_ncd[[k]]$greenspace_PC1 <- scale(all_data_ncd[[k]]$greenspace_PC1, scale = TRUE)
}
```

## List of diseases to test

```{r make_lists}

disease_list <- c(
    "Colorectal cancer",
    "Lung cancer",
    "Esophageal cancer",
    "Liver cancer",
    "Pancreatic cancer",
    "Brain cancer",
    "Leukemia",
    "Lymphoma",
    "Breast cancer",
    "Ovarian cancer",
    "Prostate cancer",
    "Type II diabetes",
    "Ischemic heart disease",
    "Cerebrovascular diseases",
    "Emphysema, COPD",
    "Chronic liver diseases",
    "Chronic kidney diseases",
    "All-cause dementia",
    "Vascular dementia",
    "Alzheimer's disease",
    "Parkinson's disease",
    "Rheumatoid arthritis",
    "Macular degeneration",
    "Osteoporosis",
    "Osteoarthritis",
    "Hypertension",
    "Obesity",
    "Dyslipidemia"
)

disease_results <- as.list(seq(1, length(disease_list)))
names(disease_results) <- disease_list

sample_sizes <- as.list(seq(1, length(disease_list)))

## set cores for parallel computation
cores <- 2

```

## Run disease analyses

# Colorectal cancer

```{r colon_cancer_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$colon_cancer_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_colon_cancer <- NA
    x$baseline_colon_cancer[baseline_ncd] <- 1
    x$baseline_colon_cancer[which(x$colon_cancer_baseline_dx == 1)] <- 1
    x$baseline_colon_cancer[which(is.na(x$baseline_colon_cancer))] <- 0
    x$baseline_colon_cancer <- factor(x$baseline_colon_cancer)
    
    return(x)
}

# run function in each dataset
all_data_colon_cancer <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_colon_cancer <- lapply(all_data_colon_cancer, function(x) {
  x <- x[which(x$baseline_colon_cancer == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_colon_cancer[[1]]))
sample_sizes[1] <- nrow(all_data_colon_cancer[[1]])

### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_colon_cancer)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_colon_cancer[[j]]$time <- 
        as.numeric(all_data_colon_cancer[[j]]$colon_cancer_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_colon_cancer[[j]]$censor_age <-
        all_data_colon_cancer[[j]]$recruitment_age + all_data_colon_cancer[[j]]$time 
}

### Setting exposures 

# # load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models 

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
colon_cancer_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_colon_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, colon_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group + ",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_colon_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, colon_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_colon_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, colon_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_colon_cancer, function(y)
            coxph(Surv(recruitment_age, censor_age, colon_cancer_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_colon_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, colon_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_colon_cancer <- as.list(seq(1,length(exposures))) # create list to store model results
pool_colon_cancer <- pblapply(exposures, colon_cancer_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_colon_cancer[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
colon_cancer_rest <- rbindlist(smry)

# rename column for exposure
names(colon_cancer_rest)[names(colon_cancer_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
colon_cancer_rest$"exp(Beta)" <- exp(colon_cancer_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
colon_cancer_rest$"exp(Beta)_2.5%" <- exp(colon_cancer_rest$`2.5 %`)
colon_cancer_rest$"exp(Beta)_97.5%" <- exp(colon_cancer_rest$`97.5 %`)

# rename column for betas
names(colon_cancer_rest)[names(colon_cancer_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(colon_cancer_rest)[names(colon_cancer_rest) == "2.5 %"] <- "Beta_2.5%"
names(colon_cancer_rest)[names(colon_cancer_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_colon_cancer[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_colon_cancer[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_colon_cancer[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_colon_cancer[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_colon_cancer[rest][[j]]$pooled$estimate / sqrt(pool_colon_cancer[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_colon_cancer[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_colon_cancer[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
colon_cancer_rest <- cbind(colon_cancer_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(colon_cancer_rest$Exposure, colon_cancer_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
colon_cancer_rest$p.value <- ifelse(colon_cancer_rest$p.value == 0, 
                            colon_cancer_rest$p.value.full,
                            colon_cancer_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(colon_cancer_rest[which(colon_cancer_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

colon_cancer_rest <- colon_cancer_rest[!grepl("recruitment_centre", colon_cancer_rest$Exposure), ]
colon_cancer_rest <- colon_cancer_rest[!grepl("hshld_income", colon_cancer_rest$Exposure), ]
colon_cancer_rest <- colon_cancer_rest[!grepl("education_years", colon_cancer_rest$Exposure), ]
colon_cancer_rest <- colon_cancer_rest[!grepl("ethnicity", colon_cancer_rest$Exposure), ]
colon_cancer_rest <- colon_cancer_rest[!grepl("smoking_status", colon_cancer_rest$Exposure), ]
colon_cancer_rest <- colon_cancer_rest[!grepl("IPAQ_activity_group", colon_cancer_rest$Exposure), ]
colon_cancer_rest <- colon_cancer_rest[!grepl("overall_health", colon_cancer_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
colon_cancer_rest$Exposure <- gsub(".L", "", colon_cancer_rest$Exposure, fixed = TRUE)

### smoking 

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_colon_cancer[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
colon_cancer_smoke <- rbindlist(smry)

# rename column for exposure
names(colon_cancer_smoke)[names(colon_cancer_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
colon_cancer_smoke$"exp(Beta)" <- exp(colon_cancer_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
colon_cancer_smoke$"exp(Beta)_2.5%" <- exp(colon_cancer_smoke$`2.5 %`)
colon_cancer_smoke$"exp(Beta)_97.5%" <- exp(colon_cancer_smoke$`97.5 %`)

# rename column for betas
names(colon_cancer_smoke)[names(colon_cancer_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(colon_cancer_smoke)[names(colon_cancer_smoke) == "2.5 %"] <- "Beta_2.5%"
names(colon_cancer_smoke)[names(colon_cancer_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_colon_cancer[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_colon_cancer[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_colon_cancer[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_colon_cancer[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_colon_cancer[smoke][[j]]$pooled$estimate / sqrt(pool_colon_cancer[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_colon_cancer[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_colon_cancer[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
colon_cancer_smoke <- cbind(colon_cancer_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(colon_cancer_smoke$Exposure, colon_cancer_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
colon_cancer_smoke$p.value <- ifelse(colon_cancer_smoke$p.value == 0,
                            colon_cancer_smoke$p.value.full,
                            colon_cancer_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(colon_cancer_smoke[which(colon_cancer_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
colon_cancer_smoke <- colon_cancer_smoke[!grepl("recruitment_centre", colon_cancer_smoke$Exposure), ]
colon_cancer_smoke <- colon_cancer_smoke[!grepl("hshld_income", colon_cancer_smoke$Exposure), ]
colon_cancer_smoke <- colon_cancer_smoke[!grepl("education_years", colon_cancer_smoke$Exposure), ]
colon_cancer_smoke <- colon_cancer_smoke[!grepl("ethnicity", colon_cancer_smoke$Exposure), ]
colon_cancer_smoke <- colon_cancer_smoke[!grepl("IPAQ_activity_group", colon_cancer_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
colon_cancer_smoke$Exposure <- gsub(".L", "", colon_cancer_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
colon_cancer_pa <- summary(pool_colon_cancer[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(colon_cancer_pa)[names(colon_cancer_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
colon_cancer_pa$"exp(Beta)" <- exp(colon_cancer_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
colon_cancer_pa$"exp(Beta)_2.5%" <- exp(colon_cancer_pa$`2.5 %`)
colon_cancer_pa$"exp(Beta)_97.5%" <- exp(colon_cancer_pa$`97.5 %`)

# rename column for betas
names(colon_cancer_pa)[names(colon_cancer_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(colon_cancer_pa)[names(colon_cancer_pa) == "2.5 %"] <- "Beta_2.5%"
names(colon_cancer_pa)[names(colon_cancer_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_colon_cancer[[ipaq]]$pooled$estimate / sqrt(pool_colon_cancer[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_colon_cancer[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_colon_cancer[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
colon_cancer_pa <- cbind(colon_cancer_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(colon_cancer_pa$Exposure, colon_cancer_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
colon_cancer_pa$p.value <- ifelse(colon_cancer_pa$p.value == 0,
                            colon_cancer_pa$p.value.full,
                            colon_cancer_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(colon_cancer_pa[which(colon_cancer_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
colon_cancer_pa <- colon_cancer_pa[!grepl("recruitment_centre", colon_cancer_pa$Exposure), ]
colon_cancer_pa <- colon_cancer_pa[!grepl("hshld_income", colon_cancer_pa$Exposure), ]
colon_cancer_pa <- colon_cancer_pa[!grepl("education_years", colon_cancer_pa$Exposure), ]
colon_cancer_pa <- colon_cancer_pa[!grepl("ethnicity", colon_cancer_pa$Exposure), ]
colon_cancer_pa <- colon_cancer_pa[!grepl("smoking_status", colon_cancer_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
colon_cancer_pa$Exposure <- gsub(".L", "", colon_cancer_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
colon_cancer_covars <- summary(pool_colon_cancer[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(colon_cancer_covars)[names(colon_cancer_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
colon_cancer_covars$"exp(Beta)" <- exp(colon_cancer_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
colon_cancer_covars$"exp(Beta)_2.5%" <- exp(colon_cancer_covars$`2.5 %`)
colon_cancer_covars$"exp(Beta)_97.5%" <- exp(colon_cancer_covars$`97.5 %`)

# rename column for betas
names(colon_cancer_covars)[names(colon_cancer_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(colon_cancer_covars)[names(colon_cancer_covars) == "2.5 %"] <- "Beta_2.5%"
names(colon_cancer_covars)[names(colon_cancer_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_colon_cancer[covars][[1]]$pooled$estimate / sqrt(pool_colon_cancer[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_colon_cancer[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_colon_cancer[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
colon_cancer_covars <- cbind(colon_cancer_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(colon_cancer_covars$Exposure, colon_cancer_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
colon_cancer_covars$p.value <- ifelse(colon_cancer_covars$p.value == 0,
                            colon_cancer_covars$p.value.full,
                            colon_cancer_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(colon_cancer_covars[which(colon_cancer_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
colon_cancer_covars <- colon_cancer_covars[!grepl("smoking_status", colon_cancer_covars$Exposure), ]
colon_cancer_covars <- colon_cancer_covars[!grepl("IPAQ_activity_group", colon_cancer_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
colon_cancer_covars$Exposure <- gsub(".L", "", colon_cancer_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(colon_cancer_rest, colon_cancer_smoke, colon_cancer_pa, colon_cancer_covars)

# merge with rbind
colon_cancer_total <- as.data.frame(do.call(rbind, dfs))


### Categories 

## map variable names to results
colon_cancer_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  colon_cancer_total$Variable[colon_cancer_total$Exposure %in% colon_cancer_total$Exposure[substring(
    colon_cancer_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
colon_cancer_total <- merge(colon_cancer_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
colon_cancer_total$FDR <- p.adjust(colon_cancer_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
colon_cancer_total <- subset(colon_cancer_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
colon_cancer_table <-
    subset(colon_cancer_total,
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
colon_cancer_table$Significant <-
    ifelse(colon_cancer_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(colon_cancer_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[1]] <- colon_cancer_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_colon_cancer[[1]]))

# remove disease-specific dataset for memory
rm(all_data_colon_cancer)

```

# Lung cancer

```{r lung_cancer_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$lung_cancer_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_lung_cancer <- NA
    x$baseline_lung_cancer[baseline_ncd] <- 1
    x$baseline_lung_cancer[which(x$lung_cancer_baseline_dx == 1)] <- 1
    x$baseline_lung_cancer[which(is.na(x$baseline_lung_cancer))] <- 0
    x$baseline_lung_cancer <- factor(x$baseline_lung_cancer)
    
    return(x)
}

# run function in each dataset
all_data_lung_cancer <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_lung_cancer <- lapply(all_data_lung_cancer, function(x) {
  x <- x[which(x$baseline_lung_cancer == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_lung_cancer[[1]]))
sample_sizes[2] <- nrow(all_data_lung_cancer[[1]])

### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_lung_cancer)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_lung_cancer[[j]]$time <- 
        as.numeric(all_data_lung_cancer[[j]]$lung_cancer_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_lung_cancer[[j]]$censor_age <-
        all_data_lung_cancer[[j]]$recruitment_age + all_data_lung_cancer[[j]]$time 
}

### Setting exposures 

# # load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
lung_cancer_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_lung_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, lung_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_lung_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, lung_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_lung_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, lung_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_lung_cancer, function(y)
            coxph(Surv(recruitment_age, censor_age, lung_cancer_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_lung_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, lung_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_lung_cancer <- as.list(seq(1,length(exposures))) # create list to store model results
pool_lung_cancer <- pblapply(exposures, lung_cancer_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_lung_cancer[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
lung_cancer_rest <- rbindlist(smry)

# rename column for exposure
names(lung_cancer_rest)[names(lung_cancer_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
lung_cancer_rest$"exp(Beta)" <- exp(lung_cancer_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
lung_cancer_rest$"exp(Beta)_2.5%" <- exp(lung_cancer_rest$`2.5 %`)
lung_cancer_rest$"exp(Beta)_97.5%" <- exp(lung_cancer_rest$`97.5 %`)

# rename column for betas
names(lung_cancer_rest)[names(lung_cancer_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(lung_cancer_rest)[names(lung_cancer_rest) == "2.5 %"] <- "Beta_2.5%"
names(lung_cancer_rest)[names(lung_cancer_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_lung_cancer[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_lung_cancer[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_lung_cancer[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_lung_cancer[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_lung_cancer[rest][[j]]$pooled$estimate / sqrt(pool_lung_cancer[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_lung_cancer[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_lung_cancer[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
lung_cancer_rest <- cbind(lung_cancer_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(lung_cancer_rest$Exposure, lung_cancer_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
lung_cancer_rest$p.value <- ifelse(lung_cancer_rest$p.value == 0, 
                            lung_cancer_rest$p.value.full,
                            lung_cancer_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(lung_cancer_rest[which(lung_cancer_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

lung_cancer_rest <- lung_cancer_rest[!grepl("recruitment_centre", lung_cancer_rest$Exposure), ]
lung_cancer_rest <- lung_cancer_rest[!grepl("hshld_income", lung_cancer_rest$Exposure), ]
lung_cancer_rest <- lung_cancer_rest[!grepl("education_years", lung_cancer_rest$Exposure), ]
lung_cancer_rest <- lung_cancer_rest[!grepl("ethnicity", lung_cancer_rest$Exposure), ]
lung_cancer_rest <- lung_cancer_rest[!grepl("smoking_status", lung_cancer_rest$Exposure), ]
lung_cancer_rest <- lung_cancer_rest[!grepl("IPAQ_activity_group", lung_cancer_rest$Exposure), ]
lung_cancer_rest <- lung_cancer_rest[!grepl("overall_health", lung_cancer_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
lung_cancer_rest$Exposure <- gsub(".L", "", lung_cancer_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_lung_cancer[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
lung_cancer_smoke <- rbindlist(smry)

# rename column for exposure
names(lung_cancer_smoke)[names(lung_cancer_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
lung_cancer_smoke$"exp(Beta)" <- exp(lung_cancer_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
lung_cancer_smoke$"exp(Beta)_2.5%" <- exp(lung_cancer_smoke$`2.5 %`)
lung_cancer_smoke$"exp(Beta)_97.5%" <- exp(lung_cancer_smoke$`97.5 %`)

# rename column for betas
names(lung_cancer_smoke)[names(lung_cancer_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(lung_cancer_smoke)[names(lung_cancer_smoke) == "2.5 %"] <- "Beta_2.5%"
names(lung_cancer_smoke)[names(lung_cancer_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_lung_cancer[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_lung_cancer[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_lung_cancer[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_lung_cancer[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_lung_cancer[smoke][[j]]$pooled$estimate / sqrt(pool_lung_cancer[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_lung_cancer[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_lung_cancer[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
lung_cancer_smoke <- cbind(lung_cancer_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(lung_cancer_smoke$Exposure, lung_cancer_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
lung_cancer_smoke$p.value <- ifelse(lung_cancer_smoke$p.value == 0,
                            lung_cancer_smoke$p.value.full,
                            lung_cancer_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(lung_cancer_smoke[which(lung_cancer_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
lung_cancer_smoke <- lung_cancer_smoke[!grepl("recruitment_centre", lung_cancer_smoke$Exposure), ]
lung_cancer_smoke <- lung_cancer_smoke[!grepl("hshld_income", lung_cancer_smoke$Exposure), ]
lung_cancer_smoke <- lung_cancer_smoke[!grepl("education_years", lung_cancer_smoke$Exposure), ]
lung_cancer_smoke <- lung_cancer_smoke[!grepl("ethnicity", lung_cancer_smoke$Exposure), ]
lung_cancer_smoke <- lung_cancer_smoke[!grepl("IPAQ_activity_group", lung_cancer_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
lung_cancer_smoke$Exposure <- gsub(".L", "", lung_cancer_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
lung_cancer_pa <- summary(pool_lung_cancer[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(lung_cancer_pa)[names(lung_cancer_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
lung_cancer_pa$"exp(Beta)" <- exp(lung_cancer_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
lung_cancer_pa$"exp(Beta)_2.5%" <- exp(lung_cancer_pa$`2.5 %`)
lung_cancer_pa$"exp(Beta)_97.5%" <- exp(lung_cancer_pa$`97.5 %`)

# rename column for betas
names(lung_cancer_pa)[names(lung_cancer_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(lung_cancer_pa)[names(lung_cancer_pa) == "2.5 %"] <- "Beta_2.5%"
names(lung_cancer_pa)[names(lung_cancer_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_lung_cancer[[ipaq]]$pooled$estimate / sqrt(pool_lung_cancer[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_lung_cancer[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_lung_cancer[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
lung_cancer_pa <- cbind(lung_cancer_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(lung_cancer_pa$Exposure, lung_cancer_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
lung_cancer_pa$p.value <- ifelse(lung_cancer_pa$p.value == 0,
                            lung_cancer_pa$p.value.full,
                            lung_cancer_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(lung_cancer_pa[which(lung_cancer_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
lung_cancer_pa <- lung_cancer_pa[!grepl("recruitment_centre", lung_cancer_pa$Exposure), ]
lung_cancer_pa <- lung_cancer_pa[!grepl("hshld_income", lung_cancer_pa$Exposure), ]
lung_cancer_pa <- lung_cancer_pa[!grepl("education_years", lung_cancer_pa$Exposure), ]
lung_cancer_pa <- lung_cancer_pa[!grepl("ethnicity", lung_cancer_pa$Exposure), ]
lung_cancer_pa <- lung_cancer_pa[!grepl("smoking_status", lung_cancer_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
lung_cancer_pa$Exposure <- gsub(".L", "", lung_cancer_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
lung_cancer_covars <- summary(pool_lung_cancer[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(lung_cancer_covars)[names(lung_cancer_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
lung_cancer_covars$"exp(Beta)" <- exp(lung_cancer_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
lung_cancer_covars$"exp(Beta)_2.5%" <- exp(lung_cancer_covars$`2.5 %`)
lung_cancer_covars$"exp(Beta)_97.5%" <- exp(lung_cancer_covars$`97.5 %`)

# rename column for betas
names(lung_cancer_covars)[names(lung_cancer_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(lung_cancer_covars)[names(lung_cancer_covars) == "2.5 %"] <- "Beta_2.5%"
names(lung_cancer_covars)[names(lung_cancer_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_lung_cancer[covars][[1]]$pooled$estimate / sqrt(pool_lung_cancer[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_lung_cancer[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_lung_cancer[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
lung_cancer_covars <- cbind(lung_cancer_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(lung_cancer_covars$Exposure, lung_cancer_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
lung_cancer_covars$p.value <- ifelse(lung_cancer_covars$p.value == 0,
                            lung_cancer_covars$p.value.full,
                            lung_cancer_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(lung_cancer_covars[which(lung_cancer_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
lung_cancer_covars <- lung_cancer_covars[!grepl("smoking_status", lung_cancer_covars$Exposure), ]
lung_cancer_covars <- lung_cancer_covars[!grepl("IPAQ_activity_group", lung_cancer_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
lung_cancer_covars$Exposure <- gsub(".L", "", lung_cancer_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(lung_cancer_rest, lung_cancer_smoke, lung_cancer_pa, lung_cancer_covars)

# merge with rbind
lung_cancer_total <- as.data.frame(do.call(rbind, dfs))

### Categories -

## map variable names to results
lung_cancer_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  lung_cancer_total$Variable[lung_cancer_total$Exposure %in% lung_cancer_total$Exposure[substring(
    lung_cancer_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
lung_cancer_total <- merge(lung_cancer_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
lung_cancer_total$FDR <- p.adjust(lung_cancer_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
lung_cancer_total <- subset(lung_cancer_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
lung_cancer_table <- 
    subset(lung_cancer_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
lung_cancer_table$Significant <- 
    ifelse(lung_cancer_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(lung_cancer_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[2]] <- lung_cancer_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_lung_cancer[[1]]))

# remove disease-specific dataset for memory
rm(all_data_lung_cancer)

```

# Esophageal cancer

```{r eso_cancer_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$eso_cancer_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_eso_cancer <- NA
    x$baseline_eso_cancer[baseline_ncd] <- 1
    x$baseline_eso_cancer[which(x$eso_cancer_baseline_dx == 1)] <- 1
    x$baseline_eso_cancer[which(is.na(x$baseline_eso_cancer))] <- 0
    x$baseline_eso_cancer <- factor(x$baseline_eso_cancer)
    
    return(x)
}

# run function in each dataset
all_data_eso_cancer <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_eso_cancer <- lapply(all_data_eso_cancer, function(x) {
  x <- x[which(x$baseline_eso_cancer == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_eso_cancer[[1]]))
sample_sizes[3] <- nrow(all_data_eso_cancer[[1]])

### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_eso_cancer)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_eso_cancer[[j]]$time <- 
        as.numeric(all_data_eso_cancer[[j]]$eso_cancer_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_eso_cancer[[j]]$censor_age <-
        all_data_eso_cancer[[j]]$recruitment_age + all_data_eso_cancer[[j]]$time 
}

### Setting exposures 

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))

# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
eso_cancer_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_eso_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, eso_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_eso_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, eso_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_eso_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, eso_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_eso_cancer, function(y)
            coxph(Surv(recruitment_age, censor_age, eso_cancer_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_eso_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, eso_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_eso_cancer <- as.list(seq(1,length(exposures))) # create list to store model results
pool_eso_cancer <- pblapply(exposures, eso_cancer_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_eso_cancer[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
eso_cancer_rest <- rbindlist(smry)

# rename column for exposure
names(eso_cancer_rest)[names(eso_cancer_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
eso_cancer_rest$"exp(Beta)" <- exp(eso_cancer_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
eso_cancer_rest$"exp(Beta)_2.5%" <- exp(eso_cancer_rest$`2.5 %`)
eso_cancer_rest$"exp(Beta)_97.5%" <- exp(eso_cancer_rest$`97.5 %`)

# rename column for betas
names(eso_cancer_rest)[names(eso_cancer_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(eso_cancer_rest)[names(eso_cancer_rest) == "2.5 %"] <- "Beta_2.5%"
names(eso_cancer_rest)[names(eso_cancer_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_eso_cancer[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_eso_cancer[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_eso_cancer[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_eso_cancer[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_eso_cancer[rest][[j]]$pooled$estimate / sqrt(pool_eso_cancer[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_eso_cancer[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_eso_cancer[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
eso_cancer_rest <- cbind(eso_cancer_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(eso_cancer_rest$Exposure, eso_cancer_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
eso_cancer_rest$p.value <- ifelse(eso_cancer_rest$p.value == 0, 
                            eso_cancer_rest$p.value.full,
                            eso_cancer_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(eso_cancer_rest[which(eso_cancer_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

eso_cancer_rest <- eso_cancer_rest[!grepl("recruitment_centre", eso_cancer_rest$Exposure), ]
eso_cancer_rest <- eso_cancer_rest[!grepl("hshld_income", eso_cancer_rest$Exposure), ]
eso_cancer_rest <- eso_cancer_rest[!grepl("education_years", eso_cancer_rest$Exposure), ]
eso_cancer_rest <- eso_cancer_rest[!grepl("ethnicity", eso_cancer_rest$Exposure), ]
eso_cancer_rest <- eso_cancer_rest[!grepl("smoking_status", eso_cancer_rest$Exposure), ]
eso_cancer_rest <- eso_cancer_rest[!grepl("IPAQ_activity_group", eso_cancer_rest$Exposure), ]
eso_cancer_rest <- eso_cancer_rest[!grepl("overall_health", eso_cancer_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
eso_cancer_rest$Exposure <- gsub(".L", "", eso_cancer_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_eso_cancer[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
eso_cancer_smoke <- rbindlist(smry)

# rename column for exposure
names(eso_cancer_smoke)[names(eso_cancer_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
eso_cancer_smoke$"exp(Beta)" <- exp(eso_cancer_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
eso_cancer_smoke$"exp(Beta)_2.5%" <- exp(eso_cancer_smoke$`2.5 %`)
eso_cancer_smoke$"exp(Beta)_97.5%" <- exp(eso_cancer_smoke$`97.5 %`)

# rename column for betas
names(eso_cancer_smoke)[names(eso_cancer_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(eso_cancer_smoke)[names(eso_cancer_smoke) == "2.5 %"] <- "Beta_2.5%"
names(eso_cancer_smoke)[names(eso_cancer_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_eso_cancer[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_eso_cancer[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_eso_cancer[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_eso_cancer[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_eso_cancer[smoke][[j]]$pooled$estimate / sqrt(pool_eso_cancer[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_eso_cancer[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_eso_cancer[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
eso_cancer_smoke <- cbind(eso_cancer_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(eso_cancer_smoke$Exposure, eso_cancer_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
eso_cancer_smoke$p.value <- ifelse(eso_cancer_smoke$p.value == 0,
                            eso_cancer_smoke$p.value.full,
                            eso_cancer_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(eso_cancer_smoke[which(eso_cancer_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
eso_cancer_smoke <- eso_cancer_smoke[!grepl("recruitment_centre", eso_cancer_smoke$Exposure), ]
eso_cancer_smoke <- eso_cancer_smoke[!grepl("hshld_income", eso_cancer_smoke$Exposure), ]
eso_cancer_smoke <- eso_cancer_smoke[!grepl("education_years", eso_cancer_smoke$Exposure), ]
eso_cancer_smoke <- eso_cancer_smoke[!grepl("ethnicity", eso_cancer_smoke$Exposure), ]
eso_cancer_smoke <- eso_cancer_smoke[!grepl("IPAQ_activity_group", eso_cancer_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
eso_cancer_smoke$Exposure <- gsub(".L", "", eso_cancer_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
eso_cancer_pa <- summary(pool_eso_cancer[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(eso_cancer_pa)[names(eso_cancer_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
eso_cancer_pa$"exp(Beta)" <- exp(eso_cancer_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
eso_cancer_pa$"exp(Beta)_2.5%" <- exp(eso_cancer_pa$`2.5 %`)
eso_cancer_pa$"exp(Beta)_97.5%" <- exp(eso_cancer_pa$`97.5 %`)

# rename column for betas
names(eso_cancer_pa)[names(eso_cancer_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(eso_cancer_pa)[names(eso_cancer_pa) == "2.5 %"] <- "Beta_2.5%"
names(eso_cancer_pa)[names(eso_cancer_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_eso_cancer[[ipaq]]$pooled$estimate / sqrt(pool_eso_cancer[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_eso_cancer[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_eso_cancer[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
eso_cancer_pa <- cbind(eso_cancer_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(eso_cancer_pa$Exposure, eso_cancer_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
eso_cancer_pa$p.value <- ifelse(eso_cancer_pa$p.value == 0,
                            eso_cancer_pa$p.value.full,
                            eso_cancer_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(eso_cancer_pa[which(eso_cancer_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
eso_cancer_pa <- eso_cancer_pa[!grepl("recruitment_centre", eso_cancer_pa$Exposure), ]
eso_cancer_pa <- eso_cancer_pa[!grepl("hshld_income", eso_cancer_pa$Exposure), ]
eso_cancer_pa <- eso_cancer_pa[!grepl("education_years", eso_cancer_pa$Exposure), ]
eso_cancer_pa <- eso_cancer_pa[!grepl("ethnicity", eso_cancer_pa$Exposure), ]
eso_cancer_pa <- eso_cancer_pa[!grepl("smoking_status", eso_cancer_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
eso_cancer_pa$Exposure <- gsub(".L", "", eso_cancer_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
eso_cancer_covars <- summary(pool_eso_cancer[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(eso_cancer_covars)[names(eso_cancer_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
eso_cancer_covars$"exp(Beta)" <- exp(eso_cancer_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
eso_cancer_covars$"exp(Beta)_2.5%" <- exp(eso_cancer_covars$`2.5 %`)
eso_cancer_covars$"exp(Beta)_97.5%" <- exp(eso_cancer_covars$`97.5 %`)

# rename column for betas
names(eso_cancer_covars)[names(eso_cancer_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(eso_cancer_covars)[names(eso_cancer_covars) == "2.5 %"] <- "Beta_2.5%"
names(eso_cancer_covars)[names(eso_cancer_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_eso_cancer[covars][[1]]$pooled$estimate / sqrt(pool_eso_cancer[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_eso_cancer[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_eso_cancer[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
eso_cancer_covars <- cbind(eso_cancer_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(eso_cancer_covars$Exposure, eso_cancer_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
eso_cancer_covars$p.value <- ifelse(eso_cancer_covars$p.value == 0,
                            eso_cancer_covars$p.value.full,
                            eso_cancer_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(eso_cancer_covars[which(eso_cancer_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
eso_cancer_covars <- eso_cancer_covars[!grepl("smoking_status", eso_cancer_covars$Exposure), ]
eso_cancer_covars <- eso_cancer_covars[!grepl("IPAQ_activity_group", eso_cancer_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
eso_cancer_covars$Exposure <- gsub(".L", "", eso_cancer_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(eso_cancer_rest, eso_cancer_smoke, eso_cancer_pa, eso_cancer_covars)

# merge with rbind
eso_cancer_total <- as.data.frame(do.call(rbind, dfs))

### Categories -

## map variable names to results
eso_cancer_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  eso_cancer_total$Variable[eso_cancer_total$Exposure %in% eso_cancer_total$Exposure[substring(
    eso_cancer_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
eso_cancer_total <- merge(eso_cancer_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
eso_cancer_total$FDR <- p.adjust(eso_cancer_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
eso_cancer_total <- subset(eso_cancer_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
eso_cancer_table <- 
    subset(eso_cancer_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
eso_cancer_table$Significant <- 
    ifelse(eso_cancer_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(eso_cancer_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[3]] <- eso_cancer_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_eso_cancer[[1]]))

# remove disease-specific dataset for memory
rm(all_data_eso_cancer)

```

# Liver cancer

```{r liver_cancer_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$liver_cancer_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_liver_cancer <- NA
    x$baseline_liver_cancer[baseline_ncd] <- 1
    x$baseline_liver_cancer[which(x$liver_cancer_baseline_dx == 1)] <- 1
    x$baseline_liver_cancer[which(is.na(x$baseline_liver_cancer))] <- 0
    x$baseline_liver_cancer <- factor(x$baseline_liver_cancer)
    
    return(x)
}

# run function in each dataset
all_data_liver_cancer <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_liver_cancer <- lapply(all_data_liver_cancer, function(x) {
  x <- x[which(x$baseline_liver_cancer == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_liver_cancer[[1]]))
sample_sizes[4] <- nrow(all_data_liver_cancer[[1]])

### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_liver_cancer)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_liver_cancer[[j]]$time <- 
        as.numeric(all_data_liver_cancer[[j]]$liver_cancer_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_liver_cancer[[j]]$censor_age <-
        all_data_liver_cancer[[j]]$recruitment_age + all_data_liver_cancer[[j]]$time 
}

### Setting exposures 

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
liver_cancer_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_liver_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, liver_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_liver_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, liver_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_liver_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, liver_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_liver_cancer, function(y)
            coxph(Surv(recruitment_age, censor_age, liver_cancer_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_liver_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, liver_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_liver_cancer <- as.list(seq(1,length(exposures))) # create list to store model results
pool_liver_cancer <- pblapply(exposures, liver_cancer_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_liver_cancer[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
liver_cancer_rest <- rbindlist(smry)

# rename column for exposure
names(liver_cancer_rest)[names(liver_cancer_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
liver_cancer_rest$"exp(Beta)" <- exp(liver_cancer_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
liver_cancer_rest$"exp(Beta)_2.5%" <- exp(liver_cancer_rest$`2.5 %`)
liver_cancer_rest$"exp(Beta)_97.5%" <- exp(liver_cancer_rest$`97.5 %`)

# rename column for betas
names(liver_cancer_rest)[names(liver_cancer_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(liver_cancer_rest)[names(liver_cancer_rest) == "2.5 %"] <- "Beta_2.5%"
names(liver_cancer_rest)[names(liver_cancer_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_liver_cancer[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_liver_cancer[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_liver_cancer[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_liver_cancer[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_liver_cancer[rest][[j]]$pooled$estimate / sqrt(pool_liver_cancer[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_liver_cancer[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_liver_cancer[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
liver_cancer_rest <- cbind(liver_cancer_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(liver_cancer_rest$Exposure, liver_cancer_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
liver_cancer_rest$p.value <- ifelse(liver_cancer_rest$p.value == 0, 
                            liver_cancer_rest$p.value.full,
                            liver_cancer_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(liver_cancer_rest[which(liver_cancer_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

liver_cancer_rest <- liver_cancer_rest[!grepl("recruitment_centre", liver_cancer_rest$Exposure), ]
liver_cancer_rest <- liver_cancer_rest[!grepl("hshld_income", liver_cancer_rest$Exposure), ]
liver_cancer_rest <- liver_cancer_rest[!grepl("education_years", liver_cancer_rest$Exposure), ]
liver_cancer_rest <- liver_cancer_rest[!grepl("ethnicity", liver_cancer_rest$Exposure), ]
liver_cancer_rest <- liver_cancer_rest[!grepl("smoking_status", liver_cancer_rest$Exposure), ]
liver_cancer_rest <- liver_cancer_rest[!grepl("IPAQ_activity_group", liver_cancer_rest$Exposure), ]
liver_cancer_rest <- liver_cancer_rest[!grepl("overall_health", liver_cancer_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
liver_cancer_rest$Exposure <- gsub(".L", "", liver_cancer_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_liver_cancer[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
liver_cancer_smoke <- rbindlist(smry)

# rename column for exposure
names(liver_cancer_smoke)[names(liver_cancer_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
liver_cancer_smoke$"exp(Beta)" <- exp(liver_cancer_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
liver_cancer_smoke$"exp(Beta)_2.5%" <- exp(liver_cancer_smoke$`2.5 %`)
liver_cancer_smoke$"exp(Beta)_97.5%" <- exp(liver_cancer_smoke$`97.5 %`)

# rename column for betas
names(liver_cancer_smoke)[names(liver_cancer_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(liver_cancer_smoke)[names(liver_cancer_smoke) == "2.5 %"] <- "Beta_2.5%"
names(liver_cancer_smoke)[names(liver_cancer_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_liver_cancer[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_liver_cancer[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_liver_cancer[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_liver_cancer[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_liver_cancer[smoke][[j]]$pooled$estimate / sqrt(pool_liver_cancer[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_liver_cancer[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_liver_cancer[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
liver_cancer_smoke <- cbind(liver_cancer_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(liver_cancer_smoke$Exposure, liver_cancer_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
liver_cancer_smoke$p.value <- ifelse(liver_cancer_smoke$p.value == 0,
                            liver_cancer_smoke$p.value.full,
                            liver_cancer_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(liver_cancer_smoke[which(liver_cancer_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
liver_cancer_smoke <- liver_cancer_smoke[!grepl("recruitment_centre", liver_cancer_smoke$Exposure), ]
liver_cancer_smoke <- liver_cancer_smoke[!grepl("hshld_income", liver_cancer_smoke$Exposure), ]
liver_cancer_smoke <- liver_cancer_smoke[!grepl("education_years", liver_cancer_smoke$Exposure), ]
liver_cancer_smoke <- liver_cancer_smoke[!grepl("ethnicity", liver_cancer_smoke$Exposure), ]
liver_cancer_smoke <- liver_cancer_smoke[!grepl("IPAQ_activity_group", liver_cancer_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
liver_cancer_smoke$Exposure <- gsub(".L", "", liver_cancer_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
liver_cancer_pa <- summary(pool_liver_cancer[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(liver_cancer_pa)[names(liver_cancer_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
liver_cancer_pa$"exp(Beta)" <- exp(liver_cancer_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
liver_cancer_pa$"exp(Beta)_2.5%" <- exp(liver_cancer_pa$`2.5 %`)
liver_cancer_pa$"exp(Beta)_97.5%" <- exp(liver_cancer_pa$`97.5 %`)

# rename column for betas
names(liver_cancer_pa)[names(liver_cancer_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(liver_cancer_pa)[names(liver_cancer_pa) == "2.5 %"] <- "Beta_2.5%"
names(liver_cancer_pa)[names(liver_cancer_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_liver_cancer[[ipaq]]$pooled$estimate / sqrt(pool_liver_cancer[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_liver_cancer[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_liver_cancer[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
liver_cancer_pa <- cbind(liver_cancer_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(liver_cancer_pa$Exposure, liver_cancer_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
liver_cancer_pa$p.value <- ifelse(liver_cancer_pa$p.value == 0,
                            liver_cancer_pa$p.value.full,
                            liver_cancer_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(liver_cancer_pa[which(liver_cancer_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
liver_cancer_pa <- liver_cancer_pa[!grepl("recruitment_centre", liver_cancer_pa$Exposure), ]
liver_cancer_pa <- liver_cancer_pa[!grepl("hshld_income", liver_cancer_pa$Exposure), ]
liver_cancer_pa <- liver_cancer_pa[!grepl("education_years", liver_cancer_pa$Exposure), ]
liver_cancer_pa <- liver_cancer_pa[!grepl("ethnicity", liver_cancer_pa$Exposure), ]
liver_cancer_pa <- liver_cancer_pa[!grepl("smoking_status", liver_cancer_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
liver_cancer_pa$Exposure <- gsub(".L", "", liver_cancer_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
liver_cancer_covars <- summary(pool_liver_cancer[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(liver_cancer_covars)[names(liver_cancer_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
liver_cancer_covars$"exp(Beta)" <- exp(liver_cancer_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
liver_cancer_covars$"exp(Beta)_2.5%" <- exp(liver_cancer_covars$`2.5 %`)
liver_cancer_covars$"exp(Beta)_97.5%" <- exp(liver_cancer_covars$`97.5 %`)

# rename column for betas
names(liver_cancer_covars)[names(liver_cancer_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(liver_cancer_covars)[names(liver_cancer_covars) == "2.5 %"] <- "Beta_2.5%"
names(liver_cancer_covars)[names(liver_cancer_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_liver_cancer[covars][[1]]$pooled$estimate / sqrt(pool_liver_cancer[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_liver_cancer[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_liver_cancer[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
liver_cancer_covars <- cbind(liver_cancer_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(liver_cancer_covars$Exposure, liver_cancer_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
liver_cancer_covars$p.value <- ifelse(liver_cancer_covars$p.value == 0,
                            liver_cancer_covars$p.value.full,
                            liver_cancer_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(liver_cancer_covars[which(liver_cancer_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
liver_cancer_covars <- liver_cancer_covars[!grepl("smoking_status", liver_cancer_covars$Exposure), ]
liver_cancer_covars <- liver_cancer_covars[!grepl("IPAQ_activity_group", liver_cancer_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
liver_cancer_covars$Exposure <- gsub(".L", "", liver_cancer_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(liver_cancer_rest, liver_cancer_smoke, liver_cancer_pa, liver_cancer_covars)

# merge with rbind
liver_cancer_total <- as.data.frame(do.call(rbind, dfs))

### Categories -

## map variable names to results
liver_cancer_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  liver_cancer_total$Variable[liver_cancer_total$Exposure %in% liver_cancer_total$Exposure[substring(
    liver_cancer_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
liver_cancer_total <- merge(liver_cancer_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
liver_cancer_total$FDR <- p.adjust(liver_cancer_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
liver_cancer_total <- subset(liver_cancer_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
liver_cancer_table <- 
    subset(liver_cancer_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
liver_cancer_table$Significant <- 
    ifelse(liver_cancer_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(liver_cancer_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[4]] <- liver_cancer_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_liver_cancer[[1]]))

# remove disease-specific dataset for memory
rm(all_data_liver_cancer)

```

# Pancreatic cancer

```{r pancreatic_cancer_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$pancreatic_cancer_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_pancreatic_cancer <- NA
    x$baseline_pancreatic_cancer[baseline_ncd] <- 1
    x$baseline_pancreatic_cancer[which(x$pancreatic_cancer_baseline_dx == 1)] <- 1
    x$baseline_pancreatic_cancer[which(is.na(x$baseline_pancreatic_cancer))] <- 0
    x$baseline_pancreatic_cancer <- factor(x$baseline_pancreatic_cancer)
    
    return(x)
}

# run function in each dataset
all_data_pancreatic_cancer <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_pancreatic_cancer <- lapply(all_data_pancreatic_cancer, function(x) {
  x <- x[which(x$baseline_pancreatic_cancer == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_pancreatic_cancer[[1]]))
sample_sizes[5] <- nrow(all_data_pancreatic_cancer[[1]])

### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_pancreatic_cancer)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_pancreatic_cancer[[j]]$time <- 
        as.numeric(all_data_pancreatic_cancer[[j]]$pancreatic_cancer_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_pancreatic_cancer[[j]]$censor_age <-
        all_data_pancreatic_cancer[[j]]$recruitment_age + all_data_pancreatic_cancer[[j]]$time 
}

### Setting exposures 

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
pancreatic_cancer_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_pancreatic_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, pancreatic_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_pancreatic_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, pancreatic_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_pancreatic_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, pancreatic_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_pancreatic_cancer, function(y)
            coxph(Surv(recruitment_age, censor_age, pancreatic_cancer_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_pancreatic_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, pancreatic_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_pancreatic_cancer <- as.list(seq(1,length(exposures))) # create list to store model results
pool_pancreatic_cancer <- pblapply(exposures, pancreatic_cancer_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_pancreatic_cancer[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
pancreatic_cancer_rest <- rbindlist(smry)

# rename column for exposure
names(pancreatic_cancer_rest)[names(pancreatic_cancer_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
pancreatic_cancer_rest$"exp(Beta)" <- exp(pancreatic_cancer_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
pancreatic_cancer_rest$"exp(Beta)_2.5%" <- exp(pancreatic_cancer_rest$`2.5 %`)
pancreatic_cancer_rest$"exp(Beta)_97.5%" <- exp(pancreatic_cancer_rest$`97.5 %`)

# rename column for betas
names(pancreatic_cancer_rest)[names(pancreatic_cancer_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(pancreatic_cancer_rest)[names(pancreatic_cancer_rest) == "2.5 %"] <- "Beta_2.5%"
names(pancreatic_cancer_rest)[names(pancreatic_cancer_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_pancreatic_cancer[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_pancreatic_cancer[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_pancreatic_cancer[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_pancreatic_cancer[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_pancreatic_cancer[rest][[j]]$pooled$estimate / sqrt(pool_pancreatic_cancer[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_pancreatic_cancer[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_pancreatic_cancer[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
pancreatic_cancer_rest <- cbind(pancreatic_cancer_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(pancreatic_cancer_rest$Exposure, pancreatic_cancer_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
pancreatic_cancer_rest$p.value <- ifelse(pancreatic_cancer_rest$p.value == 0, 
                            pancreatic_cancer_rest$p.value.full,
                            pancreatic_cancer_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(pancreatic_cancer_rest[which(pancreatic_cancer_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

pancreatic_cancer_rest <- pancreatic_cancer_rest[!grepl("recruitment_centre", pancreatic_cancer_rest$Exposure), ]
pancreatic_cancer_rest <- pancreatic_cancer_rest[!grepl("hshld_income", pancreatic_cancer_rest$Exposure), ]
pancreatic_cancer_rest <- pancreatic_cancer_rest[!grepl("education_years", pancreatic_cancer_rest$Exposure), ]
pancreatic_cancer_rest <- pancreatic_cancer_rest[!grepl("ethnicity", pancreatic_cancer_rest$Exposure), ]
pancreatic_cancer_rest <- pancreatic_cancer_rest[!grepl("smoking_status", pancreatic_cancer_rest$Exposure), ]
pancreatic_cancer_rest <- pancreatic_cancer_rest[!grepl("IPAQ_activity_group", pancreatic_cancer_rest$Exposure), ]
pancreatic_cancer_rest <- pancreatic_cancer_rest[!grepl("overall_health", pancreatic_cancer_rest$Exposure), ]


# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
pancreatic_cancer_rest$Exposure <- gsub(".L", "", pancreatic_cancer_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_pancreatic_cancer[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
pancreatic_cancer_smoke <- rbindlist(smry)

# rename column for exposure
names(pancreatic_cancer_smoke)[names(pancreatic_cancer_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
pancreatic_cancer_smoke$"exp(Beta)" <- exp(pancreatic_cancer_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
pancreatic_cancer_smoke$"exp(Beta)_2.5%" <- exp(pancreatic_cancer_smoke$`2.5 %`)
pancreatic_cancer_smoke$"exp(Beta)_97.5%" <- exp(pancreatic_cancer_smoke$`97.5 %`)

# rename column for betas
names(pancreatic_cancer_smoke)[names(pancreatic_cancer_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(pancreatic_cancer_smoke)[names(pancreatic_cancer_smoke) == "2.5 %"] <- "Beta_2.5%"
names(pancreatic_cancer_smoke)[names(pancreatic_cancer_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_pancreatic_cancer[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_pancreatic_cancer[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_pancreatic_cancer[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_pancreatic_cancer[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_pancreatic_cancer[smoke][[j]]$pooled$estimate / sqrt(pool_pancreatic_cancer[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_pancreatic_cancer[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_pancreatic_cancer[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
pancreatic_cancer_smoke <- cbind(pancreatic_cancer_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(pancreatic_cancer_smoke$Exposure, pancreatic_cancer_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
pancreatic_cancer_smoke$p.value <- ifelse(pancreatic_cancer_smoke$p.value == 0,
                            pancreatic_cancer_smoke$p.value.full,
                            pancreatic_cancer_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(pancreatic_cancer_smoke[which(pancreatic_cancer_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
pancreatic_cancer_smoke <- pancreatic_cancer_smoke[!grepl("recruitment_centre", pancreatic_cancer_smoke$Exposure), ]
pancreatic_cancer_smoke <- pancreatic_cancer_smoke[!grepl("hshld_income", pancreatic_cancer_smoke$Exposure), ]
pancreatic_cancer_smoke <- pancreatic_cancer_smoke[!grepl("education_years", pancreatic_cancer_smoke$Exposure), ]
pancreatic_cancer_smoke <- pancreatic_cancer_smoke[!grepl("ethnicity", pancreatic_cancer_smoke$Exposure), ]
pancreatic_cancer_smoke <- pancreatic_cancer_smoke[!grepl("IPAQ_activity_group", pancreatic_cancer_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
pancreatic_cancer_smoke$Exposure <- gsub(".L", "", pancreatic_cancer_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
pancreatic_cancer_pa <- summary(pool_pancreatic_cancer[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(pancreatic_cancer_pa)[names(pancreatic_cancer_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
pancreatic_cancer_pa$"exp(Beta)" <- exp(pancreatic_cancer_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
pancreatic_cancer_pa$"exp(Beta)_2.5%" <- exp(pancreatic_cancer_pa$`2.5 %`)
pancreatic_cancer_pa$"exp(Beta)_97.5%" <- exp(pancreatic_cancer_pa$`97.5 %`)

# rename column for betas
names(pancreatic_cancer_pa)[names(pancreatic_cancer_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(pancreatic_cancer_pa)[names(pancreatic_cancer_pa) == "2.5 %"] <- "Beta_2.5%"
names(pancreatic_cancer_pa)[names(pancreatic_cancer_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_pancreatic_cancer[[ipaq]]$pooled$estimate / sqrt(pool_pancreatic_cancer[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_pancreatic_cancer[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_pancreatic_cancer[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
pancreatic_cancer_pa <- cbind(pancreatic_cancer_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(pancreatic_cancer_pa$Exposure, pancreatic_cancer_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
pancreatic_cancer_pa$p.value <- ifelse(pancreatic_cancer_pa$p.value == 0,
                            pancreatic_cancer_pa$p.value.full,
                            pancreatic_cancer_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(pancreatic_cancer_pa[which(pancreatic_cancer_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
pancreatic_cancer_pa <- pancreatic_cancer_pa[!grepl("recruitment_centre", pancreatic_cancer_pa$Exposure), ]
pancreatic_cancer_pa <- pancreatic_cancer_pa[!grepl("hshld_income", pancreatic_cancer_pa$Exposure), ]
pancreatic_cancer_pa <- pancreatic_cancer_pa[!grepl("education_years", pancreatic_cancer_pa$Exposure), ]
pancreatic_cancer_pa <- pancreatic_cancer_pa[!grepl("ethnicity", pancreatic_cancer_pa$Exposure), ]
pancreatic_cancer_pa <- pancreatic_cancer_pa[!grepl("smoking_status", pancreatic_cancer_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
pancreatic_cancer_pa$Exposure <- gsub(".L", "", pancreatic_cancer_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
pancreatic_cancer_covars <- summary(pool_pancreatic_cancer[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(pancreatic_cancer_covars)[names(pancreatic_cancer_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
pancreatic_cancer_covars$"exp(Beta)" <- exp(pancreatic_cancer_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
pancreatic_cancer_covars$"exp(Beta)_2.5%" <- exp(pancreatic_cancer_covars$`2.5 %`)
pancreatic_cancer_covars$"exp(Beta)_97.5%" <- exp(pancreatic_cancer_covars$`97.5 %`)

# rename column for betas
names(pancreatic_cancer_covars)[names(pancreatic_cancer_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(pancreatic_cancer_covars)[names(pancreatic_cancer_covars) == "2.5 %"] <- "Beta_2.5%"
names(pancreatic_cancer_covars)[names(pancreatic_cancer_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_pancreatic_cancer[covars][[1]]$pooled$estimate / sqrt(pool_pancreatic_cancer[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_pancreatic_cancer[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_pancreatic_cancer[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
pancreatic_cancer_covars <- cbind(pancreatic_cancer_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(pancreatic_cancer_covars$Exposure, pancreatic_cancer_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
pancreatic_cancer_covars$p.value <- ifelse(pancreatic_cancer_covars$p.value == 0,
                            pancreatic_cancer_covars$p.value.full,
                            pancreatic_cancer_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(pancreatic_cancer_covars[which(pancreatic_cancer_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
pancreatic_cancer_covars <- pancreatic_cancer_covars[!grepl("smoking_status", pancreatic_cancer_covars$Exposure), ]
pancreatic_cancer_covars <- pancreatic_cancer_covars[!grepl("IPAQ_activity_group", pancreatic_cancer_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
pancreatic_cancer_covars$Exposure <- gsub(".L", "", pancreatic_cancer_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(pancreatic_cancer_rest, pancreatic_cancer_smoke, pancreatic_cancer_pa, pancreatic_cancer_covars)

# merge with rbind
pancreatic_cancer_total <- as.data.frame(do.call(rbind, dfs))

### Categories -

## map variable names to results
pancreatic_cancer_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  pancreatic_cancer_total$Variable[pancreatic_cancer_total$Exposure %in% pancreatic_cancer_total$Exposure[substring(
    pancreatic_cancer_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
pancreatic_cancer_total <- merge(pancreatic_cancer_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
pancreatic_cancer_total$FDR <- p.adjust(pancreatic_cancer_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
pancreatic_cancer_total <- subset(pancreatic_cancer_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
pancreatic_cancer_table <- 
    subset(pancreatic_cancer_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
pancreatic_cancer_table$Significant <- 
    ifelse(pancreatic_cancer_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(pancreatic_cancer_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[5]] <- pancreatic_cancer_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_pancreatic_cancer[[1]]))

# remove disease-specific dataset for memory
rm(all_data_pancreatic_cancer)

```

# Brain cancer

```{r brain_cancer_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$brain_cancer_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_brain_cancer <- NA
    x$baseline_brain_cancer[baseline_ncd] <- 1
    x$baseline_brain_cancer[which(x$brain_cancer_baseline_dx == 1)] <- 1
    x$baseline_brain_cancer[which(is.na(x$baseline_brain_cancer))] <- 0
    x$baseline_brain_cancer <- factor(x$baseline_brain_cancer)
    
    return(x)
}

# run function in each dataset
all_data_brain_cancer <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_brain_cancer <- lapply(all_data_brain_cancer, function(x) {
  x <- x[which(x$baseline_brain_cancer == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_brain_cancer[[1]]))
sample_sizes[6] <- nrow(all_data_brain_cancer[[1]])

### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_brain_cancer)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_brain_cancer[[j]]$time <- 
        as.numeric(all_data_brain_cancer[[j]]$brain_cancer_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_brain_cancer[[j]]$censor_age <-
        all_data_brain_cancer[[j]]$recruitment_age + all_data_brain_cancer[[j]]$time 
}

### Setting exposures 

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
brain_cancer_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_brain_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, brain_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_brain_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, brain_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_brain_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, brain_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_brain_cancer, function(y)
            coxph(Surv(recruitment_age, censor_age, brain_cancer_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_brain_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, brain_cancer_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_brain_cancer <- as.list(seq(1,length(exposures))) # create list to store model results
pool_brain_cancer <- pblapply(exposures, brain_cancer_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_brain_cancer[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
brain_cancer_rest <- rbindlist(smry)

# rename column for exposure
names(brain_cancer_rest)[names(brain_cancer_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
brain_cancer_rest$"exp(Beta)" <- exp(brain_cancer_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
brain_cancer_rest$"exp(Beta)_2.5%" <- exp(brain_cancer_rest$`2.5 %`)
brain_cancer_rest$"exp(Beta)_97.5%" <- exp(brain_cancer_rest$`97.5 %`)

# rename column for betas
names(brain_cancer_rest)[names(brain_cancer_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(brain_cancer_rest)[names(brain_cancer_rest) == "2.5 %"] <- "Beta_2.5%"
names(brain_cancer_rest)[names(brain_cancer_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_brain_cancer[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_brain_cancer[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_brain_cancer[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_brain_cancer[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_brain_cancer[rest][[j]]$pooled$estimate / sqrt(pool_brain_cancer[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_brain_cancer[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_brain_cancer[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
brain_cancer_rest <- cbind(brain_cancer_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(brain_cancer_rest$Exposure, brain_cancer_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
brain_cancer_rest$p.value <- ifelse(brain_cancer_rest$p.value == 0, 
                            brain_cancer_rest$p.value.full,
                            brain_cancer_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(brain_cancer_rest[which(brain_cancer_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

brain_cancer_rest <- brain_cancer_rest[!grepl("recruitment_centre", brain_cancer_rest$Exposure), ]
brain_cancer_rest <- brain_cancer_rest[!grepl("hshld_income", brain_cancer_rest$Exposure), ]
brain_cancer_rest <- brain_cancer_rest[!grepl("education_years", brain_cancer_rest$Exposure), ]
brain_cancer_rest <- brain_cancer_rest[!grepl("ethnicity", brain_cancer_rest$Exposure), ]
brain_cancer_rest <- brain_cancer_rest[!grepl("smoking_status", brain_cancer_rest$Exposure), ]
brain_cancer_rest <- brain_cancer_rest[!grepl("IPAQ_activity_group", brain_cancer_rest$Exposure), ]
brain_cancer_rest <- brain_cancer_rest[!grepl("overall_health", brain_cancer_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
brain_cancer_rest$Exposure <- gsub(".L", "", brain_cancer_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_brain_cancer[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
brain_cancer_smoke <- rbindlist(smry)

# rename column for exposure
names(brain_cancer_smoke)[names(brain_cancer_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
brain_cancer_smoke$"exp(Beta)" <- exp(brain_cancer_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
brain_cancer_smoke$"exp(Beta)_2.5%" <- exp(brain_cancer_smoke$`2.5 %`)
brain_cancer_smoke$"exp(Beta)_97.5%" <- exp(brain_cancer_smoke$`97.5 %`)

# rename column for betas
names(brain_cancer_smoke)[names(brain_cancer_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(brain_cancer_smoke)[names(brain_cancer_smoke) == "2.5 %"] <- "Beta_2.5%"
names(brain_cancer_smoke)[names(brain_cancer_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_brain_cancer[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_brain_cancer[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_brain_cancer[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_brain_cancer[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_brain_cancer[smoke][[j]]$pooled$estimate / sqrt(pool_brain_cancer[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_brain_cancer[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_brain_cancer[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
brain_cancer_smoke <- cbind(brain_cancer_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(brain_cancer_smoke$Exposure, brain_cancer_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
brain_cancer_smoke$p.value <- ifelse(brain_cancer_smoke$p.value == 0,
                            brain_cancer_smoke$p.value.full,
                            brain_cancer_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(brain_cancer_smoke[which(brain_cancer_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
brain_cancer_smoke <- brain_cancer_smoke[!grepl("recruitment_centre", brain_cancer_smoke$Exposure), ]
brain_cancer_smoke <- brain_cancer_smoke[!grepl("hshld_income", brain_cancer_smoke$Exposure), ]
brain_cancer_smoke <- brain_cancer_smoke[!grepl("education_years", brain_cancer_smoke$Exposure), ]
brain_cancer_smoke <- brain_cancer_smoke[!grepl("ethnicity", brain_cancer_smoke$Exposure), ]
brain_cancer_smoke <- brain_cancer_smoke[!grepl("IPAQ_activity_group", brain_cancer_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
brain_cancer_smoke$Exposure <- gsub(".L", "", brain_cancer_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
brain_cancer_pa <- summary(pool_brain_cancer[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(brain_cancer_pa)[names(brain_cancer_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
brain_cancer_pa$"exp(Beta)" <- exp(brain_cancer_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
brain_cancer_pa$"exp(Beta)_2.5%" <- exp(brain_cancer_pa$`2.5 %`)
brain_cancer_pa$"exp(Beta)_97.5%" <- exp(brain_cancer_pa$`97.5 %`)

# rename column for betas
names(brain_cancer_pa)[names(brain_cancer_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(brain_cancer_pa)[names(brain_cancer_pa) == "2.5 %"] <- "Beta_2.5%"
names(brain_cancer_pa)[names(brain_cancer_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_brain_cancer[[ipaq]]$pooled$estimate / sqrt(pool_brain_cancer[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_brain_cancer[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_brain_cancer[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
brain_cancer_pa <- cbind(brain_cancer_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(brain_cancer_pa$Exposure, brain_cancer_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
brain_cancer_pa$p.value <- ifelse(brain_cancer_pa$p.value == 0,
                            brain_cancer_pa$p.value.full,
                            brain_cancer_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(brain_cancer_pa[which(brain_cancer_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
brain_cancer_pa <- brain_cancer_pa[!grepl("recruitment_centre", brain_cancer_pa$Exposure), ]
brain_cancer_pa <- brain_cancer_pa[!grepl("hshld_income", brain_cancer_pa$Exposure), ]
brain_cancer_pa <- brain_cancer_pa[!grepl("education_years", brain_cancer_pa$Exposure), ]
brain_cancer_pa <- brain_cancer_pa[!grepl("ethnicity", brain_cancer_pa$Exposure), ]
brain_cancer_pa <- brain_cancer_pa[!grepl("smoking_status", brain_cancer_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
brain_cancer_pa$Exposure <- gsub(".L", "", brain_cancer_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
brain_cancer_covars <- summary(pool_brain_cancer[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(brain_cancer_covars)[names(brain_cancer_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
brain_cancer_covars$"exp(Beta)" <- exp(brain_cancer_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
brain_cancer_covars$"exp(Beta)_2.5%" <- exp(brain_cancer_covars$`2.5 %`)
brain_cancer_covars$"exp(Beta)_97.5%" <- exp(brain_cancer_covars$`97.5 %`)

# rename column for betas
names(brain_cancer_covars)[names(brain_cancer_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(brain_cancer_covars)[names(brain_cancer_covars) == "2.5 %"] <- "Beta_2.5%"
names(brain_cancer_covars)[names(brain_cancer_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_brain_cancer[covars][[1]]$pooled$estimate / sqrt(pool_brain_cancer[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_brain_cancer[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_brain_cancer[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
brain_cancer_covars <- cbind(brain_cancer_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(brain_cancer_covars$Exposure, brain_cancer_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
brain_cancer_covars$p.value <- ifelse(brain_cancer_covars$p.value == 0,
                            brain_cancer_covars$p.value.full,
                            brain_cancer_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(brain_cancer_covars[which(brain_cancer_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
brain_cancer_covars <- brain_cancer_covars[!grepl("smoking_status", brain_cancer_covars$Exposure), ]
brain_cancer_covars <- brain_cancer_covars[!grepl("IPAQ_activity_group", brain_cancer_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
brain_cancer_covars$Exposure <- gsub(".L", "", brain_cancer_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(brain_cancer_rest, brain_cancer_smoke, brain_cancer_pa, brain_cancer_covars)

# merge with rbind
brain_cancer_total <- as.data.frame(do.call(rbind, dfs))

### Categories -

## map variable names to results
brain_cancer_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  brain_cancer_total$Variable[brain_cancer_total$Exposure %in% brain_cancer_total$Exposure[substring(
    brain_cancer_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
brain_cancer_total <- merge(brain_cancer_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
brain_cancer_total$FDR <- p.adjust(brain_cancer_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
brain_cancer_total <- subset(brain_cancer_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
brain_cancer_table <- 
    subset(brain_cancer_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
brain_cancer_table$Significant <- 
    ifelse(brain_cancer_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(brain_cancer_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[6]] <- brain_cancer_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_brain_cancer[[1]]))

# remove disease-specific dataset for memory
rm(all_data_brain_cancer)

```

# Leukemia

```{r leukemia_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$leukemia_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_leukemia <- NA
    x$baseline_leukemia[baseline_ncd] <- 1
    x$baseline_leukemia[which(x$leukemia_baseline_dx == 1)] <- 1
    x$baseline_leukemia[which(is.na(x$baseline_leukemia))] <- 0
    x$baseline_leukemia <- factor(x$baseline_leukemia)
    
    return(x)
}

# run function in each dataset
all_data_leukemia <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_leukemia <- lapply(all_data_leukemia, function(x) {
  x <- x[which(x$baseline_leukemia == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_leukemia[[1]]))
sample_sizes[7] <- nrow(all_data_leukemia[[1]])

### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_leukemia)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_leukemia[[j]]$time <- 
        as.numeric(all_data_leukemia[[j]]$leukemia_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_leukemia[[j]]$censor_age <-
        all_data_leukemia[[j]]$recruitment_age + all_data_leukemia[[j]]$time 
}

### Setting exposures 

# # load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
leukemia_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_leukemia, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, leukemia_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_leukemia, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, leukemia_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_leukemia, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, leukemia_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_leukemia, function(y)
            coxph(Surv(recruitment_age, censor_age, leukemia_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_leukemia, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, leukemia_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_leukemia <- as.list(seq(1,length(exposures))) # create list to store model results
pool_leukemia <- pblapply(exposures, leukemia_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_leukemia[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
leukemia_rest <- rbindlist(smry)

# rename column for exposure
names(leukemia_rest)[names(leukemia_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
leukemia_rest$"exp(Beta)" <- exp(leukemia_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
leukemia_rest$"exp(Beta)_2.5%" <- exp(leukemia_rest$`2.5 %`)
leukemia_rest$"exp(Beta)_97.5%" <- exp(leukemia_rest$`97.5 %`)

# rename column for betas
names(leukemia_rest)[names(leukemia_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(leukemia_rest)[names(leukemia_rest) == "2.5 %"] <- "Beta_2.5%"
names(leukemia_rest)[names(leukemia_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_leukemia[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_leukemia[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_leukemia[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_leukemia[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_leukemia[rest][[j]]$pooled$estimate / sqrt(pool_leukemia[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_leukemia[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_leukemia[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
leukemia_rest <- cbind(leukemia_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(leukemia_rest$Exposure, leukemia_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
leukemia_rest$p.value <- ifelse(leukemia_rest$p.value == 0, 
                            leukemia_rest$p.value.full,
                            leukemia_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(leukemia_rest[which(leukemia_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

leukemia_rest <- leukemia_rest[!grepl("recruitment_centre", leukemia_rest$Exposure), ]
leukemia_rest <- leukemia_rest[!grepl("hshld_income", leukemia_rest$Exposure), ]
leukemia_rest <- leukemia_rest[!grepl("education_years", leukemia_rest$Exposure), ]
leukemia_rest <- leukemia_rest[!grepl("ethnicity", leukemia_rest$Exposure), ]
leukemia_rest <- leukemia_rest[!grepl("smoking_status", leukemia_rest$Exposure), ]
leukemia_rest <- leukemia_rest[!grepl("IPAQ_activity_group", leukemia_rest$Exposure), ]
leukemia_rest <- leukemia_rest[!grepl("overall_health", leukemia_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
leukemia_rest$Exposure <- gsub(".L", "", leukemia_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_leukemia[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
leukemia_smoke <- rbindlist(smry)

# rename column for exposure
names(leukemia_smoke)[names(leukemia_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
leukemia_smoke$"exp(Beta)" <- exp(leukemia_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
leukemia_smoke$"exp(Beta)_2.5%" <- exp(leukemia_smoke$`2.5 %`)
leukemia_smoke$"exp(Beta)_97.5%" <- exp(leukemia_smoke$`97.5 %`)

# rename column for betas
names(leukemia_smoke)[names(leukemia_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(leukemia_smoke)[names(leukemia_smoke) == "2.5 %"] <- "Beta_2.5%"
names(leukemia_smoke)[names(leukemia_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_leukemia[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_leukemia[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_leukemia[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_leukemia[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_leukemia[smoke][[j]]$pooled$estimate / sqrt(pool_leukemia[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_leukemia[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_leukemia[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
leukemia_smoke <- cbind(leukemia_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(leukemia_smoke$Exposure, leukemia_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
leukemia_smoke$p.value <- ifelse(leukemia_smoke$p.value == 0,
                            leukemia_smoke$p.value.full,
                            leukemia_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(leukemia_smoke[which(leukemia_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
leukemia_smoke <- leukemia_smoke[!grepl("recruitment_centre", leukemia_smoke$Exposure), ]
leukemia_smoke <- leukemia_smoke[!grepl("hshld_income", leukemia_smoke$Exposure), ]
leukemia_smoke <- leukemia_smoke[!grepl("education_years", leukemia_smoke$Exposure), ]
leukemia_smoke <- leukemia_smoke[!grepl("ethnicity", leukemia_smoke$Exposure), ]
leukemia_smoke <- leukemia_smoke[!grepl("IPAQ_activity_group", leukemia_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
leukemia_smoke$Exposure <- gsub(".L", "", leukemia_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
leukemia_pa <- summary(pool_leukemia[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(leukemia_pa)[names(leukemia_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
leukemia_pa$"exp(Beta)" <- exp(leukemia_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
leukemia_pa$"exp(Beta)_2.5%" <- exp(leukemia_pa$`2.5 %`)
leukemia_pa$"exp(Beta)_97.5%" <- exp(leukemia_pa$`97.5 %`)

# rename column for betas
names(leukemia_pa)[names(leukemia_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(leukemia_pa)[names(leukemia_pa) == "2.5 %"] <- "Beta_2.5%"
names(leukemia_pa)[names(leukemia_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_leukemia[[ipaq]]$pooled$estimate / sqrt(pool_leukemia[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_leukemia[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_leukemia[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
leukemia_pa <- cbind(leukemia_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(leukemia_pa$Exposure, leukemia_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
leukemia_pa$p.value <- ifelse(leukemia_pa$p.value == 0,
                            leukemia_pa$p.value.full,
                            leukemia_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(leukemia_pa[which(leukemia_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
leukemia_pa <- leukemia_pa[!grepl("recruitment_centre", leukemia_pa$Exposure), ]
leukemia_pa <- leukemia_pa[!grepl("hshld_income", leukemia_pa$Exposure), ]
leukemia_pa <- leukemia_pa[!grepl("education_years", leukemia_pa$Exposure), ]
leukemia_pa <- leukemia_pa[!grepl("ethnicity", leukemia_pa$Exposure), ]
leukemia_pa <- leukemia_pa[!grepl("smoking_status", leukemia_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
leukemia_pa$Exposure <- gsub(".L", "", leukemia_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
leukemia_covars <- summary(pool_leukemia[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(leukemia_covars)[names(leukemia_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
leukemia_covars$"exp(Beta)" <- exp(leukemia_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
leukemia_covars$"exp(Beta)_2.5%" <- exp(leukemia_covars$`2.5 %`)
leukemia_covars$"exp(Beta)_97.5%" <- exp(leukemia_covars$`97.5 %`)

# rename column for betas
names(leukemia_covars)[names(leukemia_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(leukemia_covars)[names(leukemia_covars) == "2.5 %"] <- "Beta_2.5%"
names(leukemia_covars)[names(leukemia_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_leukemia[covars][[1]]$pooled$estimate / sqrt(pool_leukemia[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_leukemia[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_leukemia[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
leukemia_covars <- cbind(leukemia_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(leukemia_covars$Exposure, leukemia_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
leukemia_covars$p.value <- ifelse(leukemia_covars$p.value == 0,
                            leukemia_covars$p.value.full,
                            leukemia_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(leukemia_covars[which(leukemia_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
leukemia_covars <- leukemia_covars[!grepl("smoking_status", leukemia_covars$Exposure), ]
leukemia_covars <- leukemia_covars[!grepl("IPAQ_activity_group", leukemia_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
leukemia_covars$Exposure <- gsub(".L", "", leukemia_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(leukemia_rest, leukemia_smoke, leukemia_pa, leukemia_covars)

# merge with rbind
leukemia_total <- as.data.frame(do.call(rbind, dfs))

### Categories -

## map variable names to results
leukemia_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  leukemia_total$Variable[leukemia_total$Exposure %in% leukemia_total$Exposure[substring(
    leukemia_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
leukemia_total <- merge(leukemia_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
leukemia_total$FDR <- p.adjust(leukemia_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
leukemia_total <- subset(leukemia_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
leukemia_table <- 
    subset(leukemia_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
leukemia_table$Significant <- 
    ifelse(leukemia_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(leukemia_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[7]] <- leukemia_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_leukemia[[1]]))

# remove disease-specific dataset for memory
rm(all_data_leukemia)

```

# Lymphoma

```{r lymphoma_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$lymphoma_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_lymphoma <- NA
    x$baseline_lymphoma[baseline_ncd] <- 1
    x$baseline_lymphoma[which(x$lymphoma_baseline_dx == 1)] <- 1
    x$baseline_lymphoma[which(is.na(x$baseline_lymphoma))] <- 0
    x$baseline_lymphoma <- factor(x$baseline_lymphoma)
    
    return(x)
}

# run function in each dataset
all_data_lymphoma <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_lymphoma <- lapply(all_data_lymphoma, function(x) {
  x <- x[which(x$baseline_lymphoma == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_lymphoma[[1]]))
sample_sizes[8] <- nrow(all_data_lymphoma[[1]])

### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_lymphoma)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_lymphoma[[j]]$time <- 
        as.numeric(all_data_lymphoma[[j]]$lymphoma_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_lymphoma[[j]]$censor_age <-
        all_data_lymphoma[[j]]$recruitment_age + all_data_lymphoma[[j]]$time 
}

### Setting exposures 

# # load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))

# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
lymphoma_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_lymphoma, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, lymphoma_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_lymphoma, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, lymphoma_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_lymphoma, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, lymphoma_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_lymphoma, function(y)
            coxph(Surv(recruitment_age, censor_age, lymphoma_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_lymphoma, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, lymphoma_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_lymphoma <- as.list(seq(1,length(exposures))) # create list to store model results
pool_lymphoma <- pblapply(exposures, lymphoma_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_lymphoma[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
lymphoma_rest <- rbindlist(smry)

# rename column for exposure
names(lymphoma_rest)[names(lymphoma_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
lymphoma_rest$"exp(Beta)" <- exp(lymphoma_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
lymphoma_rest$"exp(Beta)_2.5%" <- exp(lymphoma_rest$`2.5 %`)
lymphoma_rest$"exp(Beta)_97.5%" <- exp(lymphoma_rest$`97.5 %`)

# rename column for betas
names(lymphoma_rest)[names(lymphoma_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(lymphoma_rest)[names(lymphoma_rest) == "2.5 %"] <- "Beta_2.5%"
names(lymphoma_rest)[names(lymphoma_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_lymphoma[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_lymphoma[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_lymphoma[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_lymphoma[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_lymphoma[rest][[j]]$pooled$estimate / sqrt(pool_lymphoma[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_lymphoma[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_lymphoma[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
lymphoma_rest <- cbind(lymphoma_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(lymphoma_rest$Exposure, lymphoma_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
lymphoma_rest$p.value <- ifelse(lymphoma_rest$p.value == 0, 
                            lymphoma_rest$p.value.full,
                            lymphoma_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(lymphoma_rest[which(lymphoma_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

lymphoma_rest <- lymphoma_rest[!grepl("recruitment_centre", lymphoma_rest$Exposure), ]
lymphoma_rest <- lymphoma_rest[!grepl("hshld_income", lymphoma_rest$Exposure), ]
lymphoma_rest <- lymphoma_rest[!grepl("education_years", lymphoma_rest$Exposure), ]
lymphoma_rest <- lymphoma_rest[!grepl("ethnicity", lymphoma_rest$Exposure), ]
lymphoma_rest <- lymphoma_rest[!grepl("smoking_status", lymphoma_rest$Exposure), ]
lymphoma_rest <- lymphoma_rest[!grepl("IPAQ_activity_group", lymphoma_rest$Exposure), ]
lymphoma_rest <- lymphoma_rest[!grepl("overall_health", lymphoma_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
lymphoma_rest$Exposure <- gsub(".L", "", lymphoma_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_lymphoma[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
lymphoma_smoke <- rbindlist(smry)

# rename column for exposure
names(lymphoma_smoke)[names(lymphoma_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
lymphoma_smoke$"exp(Beta)" <- exp(lymphoma_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
lymphoma_smoke$"exp(Beta)_2.5%" <- exp(lymphoma_smoke$`2.5 %`)
lymphoma_smoke$"exp(Beta)_97.5%" <- exp(lymphoma_smoke$`97.5 %`)

# rename column for betas
names(lymphoma_smoke)[names(lymphoma_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(lymphoma_smoke)[names(lymphoma_smoke) == "2.5 %"] <- "Beta_2.5%"
names(lymphoma_smoke)[names(lymphoma_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_lymphoma[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_lymphoma[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_lymphoma[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_lymphoma[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_lymphoma[smoke][[j]]$pooled$estimate / sqrt(pool_lymphoma[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_lymphoma[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_lymphoma[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
lymphoma_smoke <- cbind(lymphoma_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(lymphoma_smoke$Exposure, lymphoma_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
lymphoma_smoke$p.value <- ifelse(lymphoma_smoke$p.value == 0,
                            lymphoma_smoke$p.value.full,
                            lymphoma_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(lymphoma_smoke[which(lymphoma_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
lymphoma_smoke <- lymphoma_smoke[!grepl("recruitment_centre", lymphoma_smoke$Exposure), ]
lymphoma_smoke <- lymphoma_smoke[!grepl("hshld_income", lymphoma_smoke$Exposure), ]
lymphoma_smoke <- lymphoma_smoke[!grepl("education_years", lymphoma_smoke$Exposure), ]
lymphoma_smoke <- lymphoma_smoke[!grepl("ethnicity", lymphoma_smoke$Exposure), ]
lymphoma_smoke <- lymphoma_smoke[!grepl("IPAQ_activity_group", lymphoma_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
lymphoma_smoke$Exposure <- gsub(".L", "", lymphoma_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
lymphoma_pa <- summary(pool_lymphoma[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(lymphoma_pa)[names(lymphoma_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
lymphoma_pa$"exp(Beta)" <- exp(lymphoma_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
lymphoma_pa$"exp(Beta)_2.5%" <- exp(lymphoma_pa$`2.5 %`)
lymphoma_pa$"exp(Beta)_97.5%" <- exp(lymphoma_pa$`97.5 %`)

# rename column for betas
names(lymphoma_pa)[names(lymphoma_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(lymphoma_pa)[names(lymphoma_pa) == "2.5 %"] <- "Beta_2.5%"
names(lymphoma_pa)[names(lymphoma_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_lymphoma[[ipaq]]$pooled$estimate / sqrt(pool_lymphoma[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_lymphoma[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_lymphoma[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
lymphoma_pa <- cbind(lymphoma_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(lymphoma_pa$Exposure, lymphoma_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
lymphoma_pa$p.value <- ifelse(lymphoma_pa$p.value == 0,
                            lymphoma_pa$p.value.full,
                            lymphoma_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(lymphoma_pa[which(lymphoma_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
lymphoma_pa <- lymphoma_pa[!grepl("recruitment_centre", lymphoma_pa$Exposure), ]
lymphoma_pa <- lymphoma_pa[!grepl("hshld_income", lymphoma_pa$Exposure), ]
lymphoma_pa <- lymphoma_pa[!grepl("education_years", lymphoma_pa$Exposure), ]
lymphoma_pa <- lymphoma_pa[!grepl("ethnicity", lymphoma_pa$Exposure), ]
lymphoma_pa <- lymphoma_pa[!grepl("smoking_status", lymphoma_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
lymphoma_pa$Exposure <- gsub(".L", "", lymphoma_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
lymphoma_covars <- summary(pool_lymphoma[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(lymphoma_covars)[names(lymphoma_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
lymphoma_covars$"exp(Beta)" <- exp(lymphoma_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
lymphoma_covars$"exp(Beta)_2.5%" <- exp(lymphoma_covars$`2.5 %`)
lymphoma_covars$"exp(Beta)_97.5%" <- exp(lymphoma_covars$`97.5 %`)

# rename column for betas
names(lymphoma_covars)[names(lymphoma_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(lymphoma_covars)[names(lymphoma_covars) == "2.5 %"] <- "Beta_2.5%"
names(lymphoma_covars)[names(lymphoma_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_lymphoma[covars][[1]]$pooled$estimate / sqrt(pool_lymphoma[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_lymphoma[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_lymphoma[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
lymphoma_covars <- cbind(lymphoma_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(lymphoma_covars$Exposure, lymphoma_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
lymphoma_covars$p.value <- ifelse(lymphoma_covars$p.value == 0,
                            lymphoma_covars$p.value.full,
                            lymphoma_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(lymphoma_covars[which(lymphoma_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
lymphoma_covars <- lymphoma_covars[!grepl("smoking_status", lymphoma_covars$Exposure), ]
lymphoma_covars <- lymphoma_covars[!grepl("IPAQ_activity_group", lymphoma_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
lymphoma_covars$Exposure <- gsub(".L", "", lymphoma_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(lymphoma_rest, lymphoma_smoke, lymphoma_pa, lymphoma_covars)

# merge with rbind
lymphoma_total <- as.data.frame(do.call(rbind, dfs))

### Categories -

## map variable names to results
lymphoma_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  lymphoma_total$Variable[lymphoma_total$Exposure %in% lymphoma_total$Exposure[substring(
    lymphoma_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
lymphoma_total <- merge(lymphoma_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
lymphoma_total$FDR <- p.adjust(lymphoma_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
lymphoma_total <- subset(lymphoma_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
lymphoma_table <- 
    subset(lymphoma_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
lymphoma_table$Significant <- 
    ifelse(lymphoma_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(lymphoma_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[8]] <- lymphoma_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_lymphoma[[1]]))

# remove disease-specific dataset for memory
rm(all_data_lymphoma)

```

# Breast cancer

```{r breast_cancer_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$breast_cancer_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_breast_cancer <- NA
    x$baseline_breast_cancer[baseline_ncd] <- 1
    x$baseline_breast_cancer[which(x$breast_cancer_baseline_dx == 1)] <- 1
    x$baseline_breast_cancer[which(is.na(x$baseline_breast_cancer))] <- 0
    x$baseline_breast_cancer <- factor(x$baseline_breast_cancer)
    
    return(x)
}

# run function in each dataset
all_data_breast_cancer <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline and to just women
all_data_breast_cancer <- lapply(all_data_breast_cancer, function(x) {
  x <- x[which(x$baseline_breast_cancer == 0), ]
  x <- x[which(x$sex == "Female"), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_breast_cancer[[1]]))
sample_sizes[9] <- nrow(all_data_breast_cancer[[1]])

### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_breast_cancer)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_breast_cancer[[j]]$time <- 
        as.numeric(all_data_breast_cancer[[j]]$breast_cancer_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_breast_cancer[[j]]$censor_age <-
        all_data_breast_cancer[[j]]$recruitment_age + all_data_breast_cancer[[j]]$time 
}

### Setting exposures 

# # load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# # load female-specific XWAS results
load(paste0(path, "/results/full cohort/sex-specific results/ACM_XWAS_results_sept_07_2022_women_summary.RData"))
female_vars <- XWAS_total$Variable[which(XWAS_total$Category == "Female reproductive factors" & XWAS_total$FDR.rep < 0.05)]

exposures <- c(exposures, female_vars)

# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
breast_cancer_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_breast_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, breast_cancer_event) ~
                        strata(birth_cohort) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_breast_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, breast_cancer_event) ~
                        strata(birth_cohort) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_breast_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, breast_cancer_event) ~
                        strata(birth_cohort) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_breast_cancer, function(y)
            coxph(Surv(recruitment_age, censor_age, breast_cancer_event) ~
                   strata(birth_cohort) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_breast_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, breast_cancer_event) ~
                        strata(birth_cohort) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_breast_cancer <- as.list(seq(1,length(exposures))) # create list to store model results
pool_breast_cancer <- pblapply(exposures, breast_cancer_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_breast_cancer[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
breast_cancer_rest <- rbindlist(smry)

# rename column for exposure
names(breast_cancer_rest)[names(breast_cancer_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
breast_cancer_rest$"exp(Beta)" <- exp(breast_cancer_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
breast_cancer_rest$"exp(Beta)_2.5%" <- exp(breast_cancer_rest$`2.5 %`)
breast_cancer_rest$"exp(Beta)_97.5%" <- exp(breast_cancer_rest$`97.5 %`)

# rename column for betas
names(breast_cancer_rest)[names(breast_cancer_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(breast_cancer_rest)[names(breast_cancer_rest) == "2.5 %"] <- "Beta_2.5%"
names(breast_cancer_rest)[names(breast_cancer_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_breast_cancer[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_breast_cancer[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_breast_cancer[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_breast_cancer[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_breast_cancer[rest][[j]]$pooled$estimate / sqrt(pool_breast_cancer[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_breast_cancer[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_breast_cancer[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
breast_cancer_rest <- cbind(breast_cancer_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(breast_cancer_rest$Exposure, breast_cancer_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
breast_cancer_rest$p.value <- ifelse(breast_cancer_rest$p.value == 0, 
                            breast_cancer_rest$p.value.full,
                            breast_cancer_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(breast_cancer_rest[which(breast_cancer_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

breast_cancer_rest <- breast_cancer_rest[!grepl("recruitment_centre", breast_cancer_rest$Exposure), ]
breast_cancer_rest <- breast_cancer_rest[!grepl("hshld_income", breast_cancer_rest$Exposure), ]
breast_cancer_rest <- breast_cancer_rest[!grepl("education_years", breast_cancer_rest$Exposure), ]
breast_cancer_rest <- breast_cancer_rest[!grepl("ethnicity", breast_cancer_rest$Exposure), ]
breast_cancer_rest <- breast_cancer_rest[!grepl("smoking_status", breast_cancer_rest$Exposure), ]
breast_cancer_rest <- breast_cancer_rest[!grepl("IPAQ_activity_group", breast_cancer_rest$Exposure), ]
breast_cancer_rest <- breast_cancer_rest[!grepl("overall_health", breast_cancer_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
breast_cancer_rest$Exposure <- gsub(".L", "", breast_cancer_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_breast_cancer[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
breast_cancer_smoke <- rbindlist(smry)

# rename column for exposure
names(breast_cancer_smoke)[names(breast_cancer_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
breast_cancer_smoke$"exp(Beta)" <- exp(breast_cancer_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
breast_cancer_smoke$"exp(Beta)_2.5%" <- exp(breast_cancer_smoke$`2.5 %`)
breast_cancer_smoke$"exp(Beta)_97.5%" <- exp(breast_cancer_smoke$`97.5 %`)

# rename column for betas
names(breast_cancer_smoke)[names(breast_cancer_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(breast_cancer_smoke)[names(breast_cancer_smoke) == "2.5 %"] <- "Beta_2.5%"
names(breast_cancer_smoke)[names(breast_cancer_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_breast_cancer[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_breast_cancer[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_breast_cancer[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_breast_cancer[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_breast_cancer[smoke][[j]]$pooled$estimate / sqrt(pool_breast_cancer[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_breast_cancer[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_breast_cancer[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
breast_cancer_smoke <- cbind(breast_cancer_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(breast_cancer_smoke$Exposure, breast_cancer_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
breast_cancer_smoke$p.value <- ifelse(breast_cancer_smoke$p.value == 0,
                            breast_cancer_smoke$p.value.full,
                            breast_cancer_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(breast_cancer_smoke[which(breast_cancer_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
breast_cancer_smoke <- breast_cancer_smoke[!grepl("recruitment_centre", breast_cancer_smoke$Exposure), ]
breast_cancer_smoke <- breast_cancer_smoke[!grepl("hshld_income", breast_cancer_smoke$Exposure), ]
breast_cancer_smoke <- breast_cancer_smoke[!grepl("education_years", breast_cancer_smoke$Exposure), ]
breast_cancer_smoke <- breast_cancer_smoke[!grepl("ethnicity", breast_cancer_smoke$Exposure), ]
breast_cancer_smoke <- breast_cancer_smoke[!grepl("IPAQ_activity_group", breast_cancer_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
breast_cancer_smoke$Exposure <- gsub(".L", "", breast_cancer_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
breast_cancer_pa <- summary(pool_breast_cancer[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(breast_cancer_pa)[names(breast_cancer_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
breast_cancer_pa$"exp(Beta)" <- exp(breast_cancer_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
breast_cancer_pa$"exp(Beta)_2.5%" <- exp(breast_cancer_pa$`2.5 %`)
breast_cancer_pa$"exp(Beta)_97.5%" <- exp(breast_cancer_pa$`97.5 %`)

# rename column for betas
names(breast_cancer_pa)[names(breast_cancer_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(breast_cancer_pa)[names(breast_cancer_pa) == "2.5 %"] <- "Beta_2.5%"
names(breast_cancer_pa)[names(breast_cancer_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_breast_cancer[[ipaq]]$pooled$estimate / sqrt(pool_breast_cancer[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_breast_cancer[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_breast_cancer[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
breast_cancer_pa <- cbind(breast_cancer_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(breast_cancer_pa$Exposure, breast_cancer_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
breast_cancer_pa$p.value <- ifelse(breast_cancer_pa$p.value == 0,
                            breast_cancer_pa$p.value.full,
                            breast_cancer_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(breast_cancer_pa[which(breast_cancer_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
breast_cancer_pa <- breast_cancer_pa[!grepl("recruitment_centre", breast_cancer_pa$Exposure), ]
breast_cancer_pa <- breast_cancer_pa[!grepl("hshld_income", breast_cancer_pa$Exposure), ]
breast_cancer_pa <- breast_cancer_pa[!grepl("education_years", breast_cancer_pa$Exposure), ]
breast_cancer_pa <- breast_cancer_pa[!grepl("ethnicity", breast_cancer_pa$Exposure), ]
breast_cancer_pa <- breast_cancer_pa[!grepl("smoking_status", breast_cancer_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
breast_cancer_pa$Exposure <- gsub(".L", "", breast_cancer_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
breast_cancer_covars <- summary(pool_breast_cancer[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(breast_cancer_covars)[names(breast_cancer_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
breast_cancer_covars$"exp(Beta)" <- exp(breast_cancer_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
breast_cancer_covars$"exp(Beta)_2.5%" <- exp(breast_cancer_covars$`2.5 %`)
breast_cancer_covars$"exp(Beta)_97.5%" <- exp(breast_cancer_covars$`97.5 %`)

# rename column for betas
names(breast_cancer_covars)[names(breast_cancer_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(breast_cancer_covars)[names(breast_cancer_covars) == "2.5 %"] <- "Beta_2.5%"
names(breast_cancer_covars)[names(breast_cancer_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_breast_cancer[covars][[1]]$pooled$estimate / sqrt(pool_breast_cancer[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_breast_cancer[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_breast_cancer[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
breast_cancer_covars <- cbind(breast_cancer_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(breast_cancer_covars$Exposure, breast_cancer_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
breast_cancer_covars$p.value <- ifelse(breast_cancer_covars$p.value == 0,
                            breast_cancer_covars$p.value.full,
                            breast_cancer_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(breast_cancer_covars[which(breast_cancer_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
breast_cancer_covars <- breast_cancer_covars[!grepl("smoking_status", breast_cancer_covars$Exposure), ]
breast_cancer_covars <- breast_cancer_covars[!grepl("IPAQ_activity_group", breast_cancer_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
breast_cancer_covars$Exposure <- gsub(".L", "", breast_cancer_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(breast_cancer_rest, breast_cancer_smoke, breast_cancer_pa, breast_cancer_covars)

# merge with rbind
breast_cancer_total <- as.data.frame(do.call(rbind, dfs))

### Categories -

## map variable names to results
breast_cancer_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  breast_cancer_total$Variable[breast_cancer_total$Exposure %in% breast_cancer_total$Exposure[substring(
    breast_cancer_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
breast_cancer_total <- merge(breast_cancer_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
breast_cancer_total$FDR <- p.adjust(breast_cancer_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
breast_cancer_total <- subset(breast_cancer_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))


# save
# save(pool_breast_cancer,
#      breast_cancer_total,
#      breast_cancer_model,
#      exposures,
#      file = 
#          paste0(paste0(paste0(path, "/results/incident disease/breast_cancer_analysis_results_"), date), "_all_sexes.RData")
# )

### output results
options(scipen = 999)
# subset results to columns for table
breast_cancer_table <- 
    subset(breast_cancer_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
breast_cancer_table$Significant <- 
    ifelse(breast_cancer_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(breast_cancer_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[9]] <- breast_cancer_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_breast_cancer[[1]]))

# remove disease-specific dataset for memory
rm(all_data_breast_cancer)

```

# Ovarian cancer

```{r ovarian_cancer_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$ovarian_cancer_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_ovarian_cancer <- NA
    x$baseline_ovarian_cancer[baseline_ncd] <- 1
    x$baseline_ovarian_cancer[which(x$ovarian_cancer_baseline_dx == 1)] <- 1
    x$baseline_ovarian_cancer[which(is.na(x$baseline_ovarian_cancer))] <- 0
    x$baseline_ovarian_cancer <- factor(x$baseline_ovarian_cancer)
    
    return(x)
}

# run function in each dataset
all_data_ovarian_cancer <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline and to just women
all_data_ovarian_cancer <- lapply(all_data_ovarian_cancer, function(x) {
  x <- x[which(x$baseline_ovarian_cancer == 0), ]
  x <- x[which(x$sex == "Female"), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_ovarian_cancer[[1]]))
sample_sizes[10] <- nrow(all_data_ovarian_cancer[[1]])

### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_ovarian_cancer)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_ovarian_cancer[[j]]$time <- 
        as.numeric(all_data_ovarian_cancer[[j]]$ovarian_cancer_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_ovarian_cancer[[j]]$censor_age <-
        all_data_ovarian_cancer[[j]]$recruitment_age + all_data_ovarian_cancer[[j]]$time 
}

### Setting exposures 

# # load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# load female-specific XWAS results
load(paste0(path, "/results/full cohort/sex-specific results/ACM_XWAS_results_sept_07_2022_women_summary.RData"))
female_vars <- XWAS_total$Variable[which(XWAS_total$Category == "Female reproductive factors" & XWAS_total$FDR.rep < 0.05)]

exposures <- c(exposures, female_vars)

# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
ovarian_cancer_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_ovarian_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, ovarian_cancer_event) ~
                        strata(birth_cohort) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_ovarian_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, ovarian_cancer_event) ~
                        strata(birth_cohort) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_ovarian_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, ovarian_cancer_event) ~
                        strata(birth_cohort) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_ovarian_cancer, function(y)
            coxph(Surv(recruitment_age, censor_age, ovarian_cancer_event) ~
                   strata(birth_cohort) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_ovarian_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, ovarian_cancer_event) ~
                        strata(birth_cohort) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_ovarian_cancer <- as.list(seq(1,length(exposures))) # create list to store model results
pool_ovarian_cancer <- pblapply(exposures, ovarian_cancer_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_ovarian_cancer[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
ovarian_cancer_rest <- rbindlist(smry)

# rename column for exposure
names(ovarian_cancer_rest)[names(ovarian_cancer_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
ovarian_cancer_rest$"exp(Beta)" <- exp(ovarian_cancer_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
ovarian_cancer_rest$"exp(Beta)_2.5%" <- exp(ovarian_cancer_rest$`2.5 %`)
ovarian_cancer_rest$"exp(Beta)_97.5%" <- exp(ovarian_cancer_rest$`97.5 %`)

# rename column for betas
names(ovarian_cancer_rest)[names(ovarian_cancer_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(ovarian_cancer_rest)[names(ovarian_cancer_rest) == "2.5 %"] <- "Beta_2.5%"
names(ovarian_cancer_rest)[names(ovarian_cancer_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_ovarian_cancer[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_ovarian_cancer[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_ovarian_cancer[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_ovarian_cancer[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_ovarian_cancer[rest][[j]]$pooled$estimate / sqrt(pool_ovarian_cancer[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_ovarian_cancer[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_ovarian_cancer[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
ovarian_cancer_rest <- cbind(ovarian_cancer_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(ovarian_cancer_rest$Exposure, ovarian_cancer_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
ovarian_cancer_rest$p.value <- ifelse(ovarian_cancer_rest$p.value == 0, 
                            ovarian_cancer_rest$p.value.full,
                            ovarian_cancer_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(ovarian_cancer_rest[which(ovarian_cancer_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

ovarian_cancer_rest <- ovarian_cancer_rest[!grepl("recruitment_centre", ovarian_cancer_rest$Exposure), ]
ovarian_cancer_rest <- ovarian_cancer_rest[!grepl("hshld_income", ovarian_cancer_rest$Exposure), ]
ovarian_cancer_rest <- ovarian_cancer_rest[!grepl("education_years", ovarian_cancer_rest$Exposure), ]
ovarian_cancer_rest <- ovarian_cancer_rest[!grepl("ethnicity", ovarian_cancer_rest$Exposure), ]
ovarian_cancer_rest <- ovarian_cancer_rest[!grepl("smoking_status", ovarian_cancer_rest$Exposure), ]
ovarian_cancer_rest <- ovarian_cancer_rest[!grepl("IPAQ_activity_group", ovarian_cancer_rest$Exposure), ]
ovarian_cancer_rest <- ovarian_cancer_rest[!grepl("overall_health", ovarian_cancer_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
ovarian_cancer_rest$Exposure <- gsub(".L", "", ovarian_cancer_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_ovarian_cancer[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
ovarian_cancer_smoke <- rbindlist(smry)

# rename column for exposure
names(ovarian_cancer_smoke)[names(ovarian_cancer_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
ovarian_cancer_smoke$"exp(Beta)" <- exp(ovarian_cancer_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
ovarian_cancer_smoke$"exp(Beta)_2.5%" <- exp(ovarian_cancer_smoke$`2.5 %`)
ovarian_cancer_smoke$"exp(Beta)_97.5%" <- exp(ovarian_cancer_smoke$`97.5 %`)

# rename column for betas
names(ovarian_cancer_smoke)[names(ovarian_cancer_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(ovarian_cancer_smoke)[names(ovarian_cancer_smoke) == "2.5 %"] <- "Beta_2.5%"
names(ovarian_cancer_smoke)[names(ovarian_cancer_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_ovarian_cancer[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_ovarian_cancer[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_ovarian_cancer[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_ovarian_cancer[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_ovarian_cancer[smoke][[j]]$pooled$estimate / sqrt(pool_ovarian_cancer[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_ovarian_cancer[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_ovarian_cancer[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
ovarian_cancer_smoke <- cbind(ovarian_cancer_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(ovarian_cancer_smoke$Exposure, ovarian_cancer_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
ovarian_cancer_smoke$p.value <- ifelse(ovarian_cancer_smoke$p.value == 0,
                            ovarian_cancer_smoke$p.value.full,
                            ovarian_cancer_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(ovarian_cancer_smoke[which(ovarian_cancer_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
ovarian_cancer_smoke <- ovarian_cancer_smoke[!grepl("recruitment_centre", ovarian_cancer_smoke$Exposure), ]
ovarian_cancer_smoke <- ovarian_cancer_smoke[!grepl("hshld_income", ovarian_cancer_smoke$Exposure), ]
ovarian_cancer_smoke <- ovarian_cancer_smoke[!grepl("education_years", ovarian_cancer_smoke$Exposure), ]
ovarian_cancer_smoke <- ovarian_cancer_smoke[!grepl("ethnicity", ovarian_cancer_smoke$Exposure), ]
ovarian_cancer_smoke <- ovarian_cancer_smoke[!grepl("IPAQ_activity_group", ovarian_cancer_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
ovarian_cancer_smoke$Exposure <- gsub(".L", "", ovarian_cancer_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
ovarian_cancer_pa <- summary(pool_ovarian_cancer[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(ovarian_cancer_pa)[names(ovarian_cancer_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
ovarian_cancer_pa$"exp(Beta)" <- exp(ovarian_cancer_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
ovarian_cancer_pa$"exp(Beta)_2.5%" <- exp(ovarian_cancer_pa$`2.5 %`)
ovarian_cancer_pa$"exp(Beta)_97.5%" <- exp(ovarian_cancer_pa$`97.5 %`)

# rename column for betas
names(ovarian_cancer_pa)[names(ovarian_cancer_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(ovarian_cancer_pa)[names(ovarian_cancer_pa) == "2.5 %"] <- "Beta_2.5%"
names(ovarian_cancer_pa)[names(ovarian_cancer_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_ovarian_cancer[[ipaq]]$pooled$estimate / sqrt(pool_ovarian_cancer[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_ovarian_cancer[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_ovarian_cancer[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
ovarian_cancer_pa <- cbind(ovarian_cancer_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(ovarian_cancer_pa$Exposure, ovarian_cancer_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
ovarian_cancer_pa$p.value <- ifelse(ovarian_cancer_pa$p.value == 0,
                            ovarian_cancer_pa$p.value.full,
                            ovarian_cancer_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(ovarian_cancer_pa[which(ovarian_cancer_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
ovarian_cancer_pa <- ovarian_cancer_pa[!grepl("recruitment_centre", ovarian_cancer_pa$Exposure), ]
ovarian_cancer_pa <- ovarian_cancer_pa[!grepl("hshld_income", ovarian_cancer_pa$Exposure), ]
ovarian_cancer_pa <- ovarian_cancer_pa[!grepl("education_years", ovarian_cancer_pa$Exposure), ]
ovarian_cancer_pa <- ovarian_cancer_pa[!grepl("ethnicity", ovarian_cancer_pa$Exposure), ]
ovarian_cancer_pa <- ovarian_cancer_pa[!grepl("smoking_status", ovarian_cancer_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
ovarian_cancer_pa$Exposure <- gsub(".L", "", ovarian_cancer_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
ovarian_cancer_covars <- summary(pool_ovarian_cancer[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(ovarian_cancer_covars)[names(ovarian_cancer_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
ovarian_cancer_covars$"exp(Beta)" <- exp(ovarian_cancer_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
ovarian_cancer_covars$"exp(Beta)_2.5%" <- exp(ovarian_cancer_covars$`2.5 %`)
ovarian_cancer_covars$"exp(Beta)_97.5%" <- exp(ovarian_cancer_covars$`97.5 %`)

# rename column for betas
names(ovarian_cancer_covars)[names(ovarian_cancer_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(ovarian_cancer_covars)[names(ovarian_cancer_covars) == "2.5 %"] <- "Beta_2.5%"
names(ovarian_cancer_covars)[names(ovarian_cancer_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_ovarian_cancer[covars][[1]]$pooled$estimate / sqrt(pool_ovarian_cancer[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_ovarian_cancer[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_ovarian_cancer[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
ovarian_cancer_covars <- cbind(ovarian_cancer_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(ovarian_cancer_covars$Exposure, ovarian_cancer_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
ovarian_cancer_covars$p.value <- ifelse(ovarian_cancer_covars$p.value == 0,
                            ovarian_cancer_covars$p.value.full,
                            ovarian_cancer_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(ovarian_cancer_covars[which(ovarian_cancer_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
ovarian_cancer_covars <- ovarian_cancer_covars[!grepl("smoking_status", ovarian_cancer_covars$Exposure), ]
ovarian_cancer_covars <- ovarian_cancer_covars[!grepl("IPAQ_activity_group", ovarian_cancer_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
ovarian_cancer_covars$Exposure <- gsub(".L", "", ovarian_cancer_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(ovarian_cancer_rest, ovarian_cancer_smoke, ovarian_cancer_pa, ovarian_cancer_covars)

# merge with rbind
ovarian_cancer_total <- as.data.frame(do.call(rbind, dfs))

### Categories -

## map variable names to results
ovarian_cancer_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  ovarian_cancer_total$Variable[ovarian_cancer_total$Exposure %in% ovarian_cancer_total$Exposure[substring(
    ovarian_cancer_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
ovarian_cancer_total <- merge(ovarian_cancer_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
ovarian_cancer_total$FDR <- p.adjust(ovarian_cancer_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
ovarian_cancer_total <- subset(ovarian_cancer_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
ovarian_cancer_table <- 
    subset(ovarian_cancer_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
ovarian_cancer_table$Significant <- 
    ifelse(ovarian_cancer_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(ovarian_cancer_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[10]] <- ovarian_cancer_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_ovarian_cancer[[1]]))

# remove disease-specific dataset for memory
rm(all_data_ovarian_cancer)

```

# Prostate cancer

```{r prostate_cancer_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$prostate_cancer_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_prostate_cancer <- NA
    x$baseline_prostate_cancer[baseline_ncd] <- 1
    x$baseline_prostate_cancer[which(x$prostate_cancer_baseline_dx == 1)] <- 1
    x$baseline_prostate_cancer[which(is.na(x$baseline_prostate_cancer))] <- 0
    x$baseline_prostate_cancer <- factor(x$baseline_prostate_cancer)
    
    return(x)
}

# run function in each dataset
all_data_prostate_cancer <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline and to just men
all_data_prostate_cancer <- lapply(all_data_prostate_cancer, function(x) {
  x <- x[which(x$baseline_prostate_cancer == 0), ]
  x <- x[which(x$sex == "Male"), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_prostate_cancer[[1]]))
sample_sizes[11] <- nrow(all_data_prostate_cancer[[1]])

### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_prostate_cancer)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_prostate_cancer[[j]]$time <- 
        as.numeric(all_data_prostate_cancer[[j]]$prostate_cancer_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_prostate_cancer[[j]]$censor_age <-
        all_data_prostate_cancer[[j]]$recruitment_age + all_data_prostate_cancer[[j]]$time 
}

### Setting exposures 

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# load male-specific XWAS results
load(paste0(path, "/results/full cohort/sex-specific results/ACM_XWAS_results_sept_07_2022_men_summary.RData"))
male_vars <- XWAS_total$Variable[which(XWAS_total$Category == "Male reproductive factors" & XWAS_total$FDR.rep < 0.05)]

exposures <- c(exposures, male_vars)

# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
prostate_cancer_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_prostate_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, prostate_cancer_event) ~
                        strata(birth_cohort) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group + ",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_prostate_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, prostate_cancer_event) ~
                        strata(birth_cohort) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_prostate_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, prostate_cancer_event) ~
                        strata(birth_cohort) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_prostate_cancer, function(y)
            coxph(Surv(recruitment_age, censor_age, prostate_cancer_event) ~
                      strata(birth_cohort) +
                      recruitment_centre + education_years + hshld_income + ethnicity + 
                      IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_prostate_cancer, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, prostate_cancer_event) ~
                        strata(birth_cohort) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + ",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_prostate_cancer <- as.list(seq(1,length(exposures))) # create list to store model results
pool_prostate_cancer <- pblapply(exposures, prostate_cancer_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_prostate_cancer[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
prostate_cancer_rest <- rbindlist(smry)

# rename column for exposure
names(prostate_cancer_rest)[names(prostate_cancer_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
prostate_cancer_rest$"exp(Beta)" <- exp(prostate_cancer_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
prostate_cancer_rest$"exp(Beta)_2.5%" <- exp(prostate_cancer_rest$`2.5 %`)
prostate_cancer_rest$"exp(Beta)_97.5%" <- exp(prostate_cancer_rest$`97.5 %`)

# rename column for betas
names(prostate_cancer_rest)[names(prostate_cancer_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(prostate_cancer_rest)[names(prostate_cancer_rest) == "2.5 %"] <- "Beta_2.5%"
names(prostate_cancer_rest)[names(prostate_cancer_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_prostate_cancer[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_prostate_cancer[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_prostate_cancer[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_prostate_cancer[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_prostate_cancer[rest][[j]]$pooled$estimate / sqrt(pool_prostate_cancer[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_prostate_cancer[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_prostate_cancer[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
prostate_cancer_rest <- cbind(prostate_cancer_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(prostate_cancer_rest$Exposure, prostate_cancer_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
prostate_cancer_rest$p.value <- ifelse(prostate_cancer_rest$p.value == 0, 
                            prostate_cancer_rest$p.value.full,
                            prostate_cancer_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(prostate_cancer_rest[which(prostate_cancer_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

prostate_cancer_rest <- prostate_cancer_rest[!grepl("recruitment_centre", prostate_cancer_rest$Exposure), ]
prostate_cancer_rest <- prostate_cancer_rest[!grepl("hshld_income", prostate_cancer_rest$Exposure), ]
prostate_cancer_rest <- prostate_cancer_rest[!grepl("education_years", prostate_cancer_rest$Exposure), ]
prostate_cancer_rest <- prostate_cancer_rest[!grepl("ethnicity", prostate_cancer_rest$Exposure), ]
prostate_cancer_rest <- prostate_cancer_rest[!grepl("smoking_status", prostate_cancer_rest$Exposure), ]
prostate_cancer_rest <- prostate_cancer_rest[!grepl("IPAQ_activity_group", prostate_cancer_rest$Exposure), ]
prostate_cancer_rest <- prostate_cancer_rest[!grepl("overall_health", prostate_cancer_rest$Exposure), ]


# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
prostate_cancer_rest$Exposure <- gsub(".L", "", prostate_cancer_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_prostate_cancer[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
prostate_cancer_smoke <- rbindlist(smry)

# rename column for exposure
names(prostate_cancer_smoke)[names(prostate_cancer_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
prostate_cancer_smoke$"exp(Beta)" <- exp(prostate_cancer_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
prostate_cancer_smoke$"exp(Beta)_2.5%" <- exp(prostate_cancer_smoke$`2.5 %`)
prostate_cancer_smoke$"exp(Beta)_97.5%" <- exp(prostate_cancer_smoke$`97.5 %`)

# rename column for betas
names(prostate_cancer_smoke)[names(prostate_cancer_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(prostate_cancer_smoke)[names(prostate_cancer_smoke) == "2.5 %"] <- "Beta_2.5%"
names(prostate_cancer_smoke)[names(prostate_cancer_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_prostate_cancer[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_prostate_cancer[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_prostate_cancer[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_prostate_cancer[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_prostate_cancer[smoke][[j]]$pooled$estimate / sqrt(pool_prostate_cancer[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_prostate_cancer[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_prostate_cancer[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
prostate_cancer_smoke <- cbind(prostate_cancer_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(prostate_cancer_smoke$Exposure, prostate_cancer_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
prostate_cancer_smoke$p.value <- ifelse(prostate_cancer_smoke$p.value == 0,
                            prostate_cancer_smoke$p.value.full,
                            prostate_cancer_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(prostate_cancer_smoke[which(prostate_cancer_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
prostate_cancer_smoke <- prostate_cancer_smoke[!grepl("recruitment_centre", prostate_cancer_smoke$Exposure), ]
prostate_cancer_smoke <- prostate_cancer_smoke[!grepl("hshld_income", prostate_cancer_smoke$Exposure), ]
prostate_cancer_smoke <- prostate_cancer_smoke[!grepl("education_years", prostate_cancer_smoke$Exposure), ]
prostate_cancer_smoke <- prostate_cancer_smoke[!grepl("ethnicity", prostate_cancer_smoke$Exposure), ]
prostate_cancer_smoke <- prostate_cancer_smoke[!grepl("IPAQ_activity_group", prostate_cancer_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
prostate_cancer_smoke$Exposure <- gsub(".L", "", prostate_cancer_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
prostate_cancer_pa <- summary(pool_prostate_cancer[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(prostate_cancer_pa)[names(prostate_cancer_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
prostate_cancer_pa$"exp(Beta)" <- exp(prostate_cancer_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
prostate_cancer_pa$"exp(Beta)_2.5%" <- exp(prostate_cancer_pa$`2.5 %`)
prostate_cancer_pa$"exp(Beta)_97.5%" <- exp(prostate_cancer_pa$`97.5 %`)

# rename column for betas
names(prostate_cancer_pa)[names(prostate_cancer_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(prostate_cancer_pa)[names(prostate_cancer_pa) == "2.5 %"] <- "Beta_2.5%"
names(prostate_cancer_pa)[names(prostate_cancer_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_prostate_cancer[[ipaq]]$pooled$estimate / sqrt(pool_prostate_cancer[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_prostate_cancer[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_prostate_cancer[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
prostate_cancer_pa <- cbind(prostate_cancer_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(prostate_cancer_pa$Exposure, prostate_cancer_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
prostate_cancer_pa$p.value <- ifelse(prostate_cancer_pa$p.value == 0,
                            prostate_cancer_pa$p.value.full,
                            prostate_cancer_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(prostate_cancer_pa[which(prostate_cancer_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
prostate_cancer_pa <- prostate_cancer_pa[!grepl("recruitment_centre", prostate_cancer_pa$Exposure), ]
prostate_cancer_pa <- prostate_cancer_pa[!grepl("hshld_income", prostate_cancer_pa$Exposure), ]
prostate_cancer_pa <- prostate_cancer_pa[!grepl("education_years", prostate_cancer_pa$Exposure), ]
prostate_cancer_pa <- prostate_cancer_pa[!grepl("ethnicity", prostate_cancer_pa$Exposure), ]
prostate_cancer_pa <- prostate_cancer_pa[!grepl("smoking_status", prostate_cancer_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
prostate_cancer_pa$Exposure <- gsub(".L", "", prostate_cancer_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
prostate_cancer_covars <- summary(pool_prostate_cancer[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(prostate_cancer_covars)[names(prostate_cancer_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
prostate_cancer_covars$"exp(Beta)" <- exp(prostate_cancer_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
prostate_cancer_covars$"exp(Beta)_2.5%" <- exp(prostate_cancer_covars$`2.5 %`)
prostate_cancer_covars$"exp(Beta)_97.5%" <- exp(prostate_cancer_covars$`97.5 %`)

# rename column for betas
names(prostate_cancer_covars)[names(prostate_cancer_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(prostate_cancer_covars)[names(prostate_cancer_covars) == "2.5 %"] <- "Beta_2.5%"
names(prostate_cancer_covars)[names(prostate_cancer_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_prostate_cancer[covars][[1]]$pooled$estimate / sqrt(pool_prostate_cancer[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_prostate_cancer[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_prostate_cancer[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
prostate_cancer_covars <- cbind(prostate_cancer_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(prostate_cancer_covars$Exposure, prostate_cancer_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
prostate_cancer_covars$p.value <- ifelse(prostate_cancer_covars$p.value == 0,
                            prostate_cancer_covars$p.value.full,
                            prostate_cancer_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(prostate_cancer_covars[which(prostate_cancer_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
prostate_cancer_covars <- prostate_cancer_covars[!grepl("smoking_status", prostate_cancer_covars$Exposure), ]
prostate_cancer_covars <- prostate_cancer_covars[!grepl("IPAQ_activity_group", prostate_cancer_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
prostate_cancer_covars$Exposure <- gsub(".L", "", prostate_cancer_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(prostate_cancer_rest, prostate_cancer_smoke, prostate_cancer_pa, prostate_cancer_covars)

# merge with rbind
prostate_cancer_total <- as.data.frame(do.call(rbind, dfs))

### Categories -

## map variable names to results
prostate_cancer_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  prostate_cancer_total$Variable[prostate_cancer_total$Exposure %in% prostate_cancer_total$Exposure[substring(
    prostate_cancer_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
prostate_cancer_total <- merge(prostate_cancer_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
prostate_cancer_total$FDR <- p.adjust(prostate_cancer_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
prostate_cancer_total <- subset(prostate_cancer_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
prostate_cancer_table <- 
    subset(prostate_cancer_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
prostate_cancer_table$Significant <- 
    ifelse(prostate_cancer_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(prostate_cancer_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[11]] <- prostate_cancer_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_prostate_cancer[[1]]))

# remove disease-specific dataset for memory
rm(all_data_prostate_cancer)

```

# Type 2 diabetes

```{r diabetes_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$diabetes_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_diabetes <- NA
    x$baseline_diabetes[baseline_ncd] <- 1
    x$baseline_diabetes[which(x$diabetes_diagnosis == "Yes")] <- 1
    x$baseline_diabetes[which(x$diabetes_baseline_dx == 1)] <- 1
    x$baseline_diabetes[which(x$insulin == "Yes")] <- 1
    x$baseline_diabetes[which(x$hbA1c >= 48)] <- 1
    x$baseline_diabetes[which(x$glucose >= 11.1)] <- 1
    x$baseline_diabetes[which(is.na(x$baseline_diabetes))] <- 0
    x$baseline_diabetes <- factor(x$baseline_diabetes)
    
    return(x)
}

# run function in each dataset
all_data_diabetes <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_diabetes <- lapply(all_data_diabetes, function(x) {
  x <- x[which(x$baseline_diabetes == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_diabetes[[1]]))
sample_sizes[12] <- nrow(all_data_diabetes[[1]])


### Survival variables

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_diabetes)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_diabetes[[j]]$time <- 
        as.numeric(all_data_diabetes[[j]]$diabetes_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_diabetes[[j]]$censor_age <-
        all_data_diabetes[[j]]$recruitment_age + all_data_diabetes[[j]]$time 
}

### Setting exposures

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
diabetes_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_diabetes, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, diabetes_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_diabetes, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, diabetes_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_diabetes, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, diabetes_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_diabetes, function(y)
            coxph(Surv(recruitment_age, censor_age, diabetes_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_diabetes, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, diabetes_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_diabetes <- as.list(seq(1,length(exposures))) # create list to store model results
pool_diabetes <- pblapply(exposures, diabetes_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_diabetes[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
diabetes_rest <- rbindlist(smry)

# rename column for exposure
names(diabetes_rest)[names(diabetes_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
diabetes_rest$"exp(Beta)" <- exp(diabetes_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
diabetes_rest$"exp(Beta)_2.5%" <- exp(diabetes_rest$`2.5 %`)
diabetes_rest$"exp(Beta)_97.5%" <- exp(diabetes_rest$`97.5 %`)

# rename column for betas
names(diabetes_rest)[names(diabetes_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(diabetes_rest)[names(diabetes_rest) == "2.5 %"] <- "Beta_2.5%"
names(diabetes_rest)[names(diabetes_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_diabetes[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_diabetes[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_diabetes[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_diabetes[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_diabetes[rest][[j]]$pooled$estimate / sqrt(pool_diabetes[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_diabetes[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_diabetes[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
diabetes_rest <- cbind(diabetes_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(diabetes_rest$Exposure, diabetes_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
diabetes_rest$p.value <- ifelse(diabetes_rest$p.value == 0, 
                            diabetes_rest$p.value.full,
                            diabetes_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(diabetes_rest[which(diabetes_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

diabetes_rest <- diabetes_rest[!grepl("recruitment_centre", diabetes_rest$Exposure), ]
diabetes_rest <- diabetes_rest[!grepl("hshld_income", diabetes_rest$Exposure), ]
diabetes_rest <- diabetes_rest[!grepl("education_years", diabetes_rest$Exposure), ]
diabetes_rest <- diabetes_rest[!grepl("ethnicity", diabetes_rest$Exposure), ]
diabetes_rest <- diabetes_rest[!grepl("smoking_status", diabetes_rest$Exposure), ]
diabetes_rest <- diabetes_rest[!grepl("IPAQ_activity_group", diabetes_rest$Exposure), ]
diabetes_rest <- diabetes_rest[!grepl("overall_health", diabetes_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
diabetes_rest$Exposure <- gsub(".L", "", diabetes_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_diabetes[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
diabetes_smoke <- rbindlist(smry)

# rename column for exposure
names(diabetes_smoke)[names(diabetes_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
diabetes_smoke$"exp(Beta)" <- exp(diabetes_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
diabetes_smoke$"exp(Beta)_2.5%" <- exp(diabetes_smoke$`2.5 %`)
diabetes_smoke$"exp(Beta)_97.5%" <- exp(diabetes_smoke$`97.5 %`)

# rename column for betas
names(diabetes_smoke)[names(diabetes_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(diabetes_smoke)[names(diabetes_smoke) == "2.5 %"] <- "Beta_2.5%"
names(diabetes_smoke)[names(diabetes_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_diabetes[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_diabetes[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_diabetes[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_diabetes[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_diabetes[smoke][[j]]$pooled$estimate / sqrt(pool_diabetes[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_diabetes[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_diabetes[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
diabetes_smoke <- cbind(diabetes_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(diabetes_smoke$Exposure, diabetes_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
diabetes_smoke$p.value <- ifelse(diabetes_smoke$p.value == 0,
                            diabetes_smoke$p.value.full,
                            diabetes_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(diabetes_smoke[which(diabetes_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
diabetes_smoke <- diabetes_smoke[!grepl("recruitment_centre", diabetes_smoke$Exposure), ]
diabetes_smoke <- diabetes_smoke[!grepl("hshld_income", diabetes_smoke$Exposure), ]
diabetes_smoke <- diabetes_smoke[!grepl("education_years", diabetes_smoke$Exposure), ]
diabetes_smoke <- diabetes_smoke[!grepl("ethnicity", diabetes_smoke$Exposure), ]
diabetes_smoke <- diabetes_smoke[!grepl("IPAQ_activity_group", diabetes_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
diabetes_smoke$Exposure <- gsub(".L", "", diabetes_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
diabetes_pa <- summary(pool_diabetes[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(diabetes_pa)[names(diabetes_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
diabetes_pa$"exp(Beta)" <- exp(diabetes_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
diabetes_pa$"exp(Beta)_2.5%" <- exp(diabetes_pa$`2.5 %`)
diabetes_pa$"exp(Beta)_97.5%" <- exp(diabetes_pa$`97.5 %`)

# rename column for betas
names(diabetes_pa)[names(diabetes_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(diabetes_pa)[names(diabetes_pa) == "2.5 %"] <- "Beta_2.5%"
names(diabetes_pa)[names(diabetes_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_diabetes[[ipaq]]$pooled$estimate / sqrt(pool_diabetes[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_diabetes[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_diabetes[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
diabetes_pa <- cbind(diabetes_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(diabetes_pa$Exposure, diabetes_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
diabetes_pa$p.value <- ifelse(diabetes_pa$p.value == 0,
                            diabetes_pa$p.value.full,
                            diabetes_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(diabetes_pa[which(diabetes_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
diabetes_pa <- diabetes_pa[!grepl("recruitment_centre", diabetes_pa$Exposure), ]
diabetes_pa <- diabetes_pa[!grepl("hshld_income", diabetes_pa$Exposure), ]
diabetes_pa <- diabetes_pa[!grepl("education_years", diabetes_pa$Exposure), ]
diabetes_pa <- diabetes_pa[!grepl("ethnicity", diabetes_pa$Exposure), ]
diabetes_pa <- diabetes_pa[!grepl("smoking_status", diabetes_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
diabetes_pa$Exposure <- gsub(".L", "", diabetes_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
diabetes_covars <- summary(pool_diabetes[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(diabetes_covars)[names(diabetes_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
diabetes_covars$"exp(Beta)" <- exp(diabetes_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
diabetes_covars$"exp(Beta)_2.5%" <- exp(diabetes_covars$`2.5 %`)
diabetes_covars$"exp(Beta)_97.5%" <- exp(diabetes_covars$`97.5 %`)

# rename column for betas
names(diabetes_covars)[names(diabetes_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(diabetes_covars)[names(diabetes_covars) == "2.5 %"] <- "Beta_2.5%"
names(diabetes_covars)[names(diabetes_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_diabetes[covars][[1]]$pooled$estimate / sqrt(pool_diabetes[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_diabetes[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_diabetes[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
diabetes_covars <- cbind(diabetes_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(diabetes_covars$Exposure, diabetes_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
diabetes_covars$p.value <- ifelse(diabetes_covars$p.value == 0,
                            diabetes_covars$p.value.full,
                            diabetes_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(diabetes_covars[which(diabetes_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
diabetes_covars <- diabetes_covars[!grepl("smoking_status", diabetes_covars$Exposure), ]
diabetes_covars <- diabetes_covars[!grepl("IPAQ_activity_group", diabetes_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
diabetes_covars$Exposure <- gsub(".L", "", diabetes_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(diabetes_rest, diabetes_smoke, diabetes_pa, diabetes_covars)

# merge with rbind
diabetes_total <- as.data.frame(do.call(rbind, dfs))

### Categories 

## map variable names to results
diabetes_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  diabetes_total$Variable[diabetes_total$Exposure %in% diabetes_total$Exposure[substring(
    diabetes_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
diabetes_total <- merge(diabetes_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
diabetes_total$FDR <- p.adjust(diabetes_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
diabetes_total <- subset(diabetes_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
diabetes_table <- 
    subset(diabetes_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
diabetes_table$Significant <- 
    ifelse(diabetes_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(diabetes_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[12]] <- diabetes_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_diabetes[[1]]))

# remove disease-specific dataset for memory
rm(all_data_diabetes)

```

# Cardiovascular disease

```{r cvd_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$CVD_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_cvd <- NA
    x$baseline_cvd[baseline_ncd] <- 1
    x$baseline_cvd[which(x$heart_attack_diagnosis == "Yes")] <- 1
    x$baseline_cvd[which(x$angina_diagnosis == "Yes")] <- 1
    x$baseline_cvd[which(x$CVD_baseline_dx == 1)] <- 1
    x$baseline_cvd[which(is.na(x$baseline_cvd))] <- 0
    x$baseline_cvd <- factor(x$baseline_cvd)
    
    return(x)
}

# run function in each dataset
all_data_cvd <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_cvd <- lapply(all_data_cvd, function(x) {
  x <- x[which(x$baseline_cvd == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_cvd[[1]]))
sample_sizes[13] <- nrow(all_data_cvd[[1]])


### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_cvd)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_cvd[[j]]$time <- 
        as.numeric(all_data_cvd[[j]]$CVD_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_cvd[[j]]$censor_age <-
        all_data_cvd[[j]]$recruitment_age + all_data_cvd[[j]]$time 
}

### Setting exposures 

# # load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models 

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
cvd_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_cvd, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, CVD_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_cvd, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, CVD_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_cvd, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, CVD_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_cvd, function(y)
            coxph(Surv(recruitment_age, censor_age, CVD_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_cvd, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, CVD_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_cvd <- as.list(seq(1,length(exposures))) # create list to store model results
pool_cvd <- pblapply(exposures, cvd_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_cvd[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
cvd_rest <- rbindlist(smry)

# rename column for exposure
names(cvd_rest)[names(cvd_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
cvd_rest$"exp(Beta)" <- exp(cvd_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
cvd_rest$"exp(Beta)_2.5%" <- exp(cvd_rest$`2.5 %`)
cvd_rest$"exp(Beta)_97.5%" <- exp(cvd_rest$`97.5 %`)

# rename column for betas
names(cvd_rest)[names(cvd_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(cvd_rest)[names(cvd_rest) == "2.5 %"] <- "Beta_2.5%"
names(cvd_rest)[names(cvd_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_cvd[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_cvd[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_cvd[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_cvd[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_cvd[rest][[j]]$pooled$estimate / sqrt(pool_cvd[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_cvd[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_cvd[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
cvd_rest <- cbind(cvd_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(cvd_rest$Exposure, cvd_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
cvd_rest$p.value <- ifelse(cvd_rest$p.value == 0, 
                            cvd_rest$p.value.full,
                            cvd_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(cvd_rest[which(cvd_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

cvd_rest <- cvd_rest[!grepl("recruitment_centre", cvd_rest$Exposure), ]
cvd_rest <- cvd_rest[!grepl("hshld_income", cvd_rest$Exposure), ]
cvd_rest <- cvd_rest[!grepl("education_years", cvd_rest$Exposure), ]
cvd_rest <- cvd_rest[!grepl("ethnicity", cvd_rest$Exposure), ]
cvd_rest <- cvd_rest[!grepl("smoking_status", cvd_rest$Exposure), ]
cvd_rest <- cvd_rest[!grepl("IPAQ_activity_group", cvd_rest$Exposure), ]
cvd_rest <- cvd_rest[!grepl("overall_health", cvd_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
cvd_rest$Exposure <- gsub(".L", "", cvd_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_cvd[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
cvd_smoke <- rbindlist(smry)

# rename column for exposure
names(cvd_smoke)[names(cvd_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
cvd_smoke$"exp(Beta)" <- exp(cvd_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
cvd_smoke$"exp(Beta)_2.5%" <- exp(cvd_smoke$`2.5 %`)
cvd_smoke$"exp(Beta)_97.5%" <- exp(cvd_smoke$`97.5 %`)

# rename column for betas
names(cvd_smoke)[names(cvd_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(cvd_smoke)[names(cvd_smoke) == "2.5 %"] <- "Beta_2.5%"
names(cvd_smoke)[names(cvd_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_cvd[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_cvd[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_cvd[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_cvd[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_cvd[smoke][[j]]$pooled$estimate / sqrt(pool_cvd[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_cvd[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_cvd[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
cvd_smoke <- cbind(cvd_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(cvd_smoke$Exposure, cvd_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
cvd_smoke$p.value <- ifelse(cvd_smoke$p.value == 0,
                            cvd_smoke$p.value.full,
                            cvd_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(cvd_smoke[which(cvd_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
cvd_smoke <- cvd_smoke[!grepl("recruitment_centre", cvd_smoke$Exposure), ]
cvd_smoke <- cvd_smoke[!grepl("hshld_income", cvd_smoke$Exposure), ]
cvd_smoke <- cvd_smoke[!grepl("education_years", cvd_smoke$Exposure), ]
cvd_smoke <- cvd_smoke[!grepl("ethnicity", cvd_smoke$Exposure), ]
cvd_smoke <- cvd_smoke[!grepl("IPAQ_activity_group", cvd_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
cvd_smoke$Exposure <- gsub(".L", "", cvd_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
cvd_pa <- summary(pool_cvd[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(cvd_pa)[names(cvd_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
cvd_pa$"exp(Beta)" <- exp(cvd_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
cvd_pa$"exp(Beta)_2.5%" <- exp(cvd_pa$`2.5 %`)
cvd_pa$"exp(Beta)_97.5%" <- exp(cvd_pa$`97.5 %`)

# rename column for betas
names(cvd_pa)[names(cvd_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(cvd_pa)[names(cvd_pa) == "2.5 %"] <- "Beta_2.5%"
names(cvd_pa)[names(cvd_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_cvd[[ipaq]]$pooled$estimate / sqrt(pool_cvd[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_cvd[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_cvd[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
cvd_pa <- cbind(cvd_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(cvd_pa$Exposure, cvd_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
cvd_pa$p.value <- ifelse(cvd_pa$p.value == 0,
                            cvd_pa$p.value.full,
                            cvd_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(cvd_pa[which(cvd_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
cvd_pa <- cvd_pa[!grepl("recruitment_centre", cvd_pa$Exposure), ]
cvd_pa <- cvd_pa[!grepl("hshld_income", cvd_pa$Exposure), ]
cvd_pa <- cvd_pa[!grepl("education_years", cvd_pa$Exposure), ]
cvd_pa <- cvd_pa[!grepl("ethnicity", cvd_pa$Exposure), ]
cvd_pa <- cvd_pa[!grepl("smoking_status", cvd_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
cvd_pa$Exposure <- gsub(".L", "", cvd_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
cvd_covars <- summary(pool_cvd[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(cvd_covars)[names(cvd_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
cvd_covars$"exp(Beta)" <- exp(cvd_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
cvd_covars$"exp(Beta)_2.5%" <- exp(cvd_covars$`2.5 %`)
cvd_covars$"exp(Beta)_97.5%" <- exp(cvd_covars$`97.5 %`)

# rename column for betas
names(cvd_covars)[names(cvd_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(cvd_covars)[names(cvd_covars) == "2.5 %"] <- "Beta_2.5%"
names(cvd_covars)[names(cvd_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_cvd[covars][[1]]$pooled$estimate / sqrt(pool_cvd[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_cvd[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_cvd[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
cvd_covars <- cbind(cvd_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(cvd_covars$Exposure, cvd_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
cvd_covars$p.value <- ifelse(cvd_covars$p.value == 0,
                            cvd_covars$p.value.full,
                            cvd_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(cvd_covars[which(cvd_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
cvd_covars <- cvd_covars[!grepl("smoking_status", cvd_covars$Exposure), ]
cvd_covars <- cvd_covars[!grepl("IPAQ_activity_group", cvd_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
cvd_covars$Exposure <- gsub(".L", "", cvd_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(cvd_rest, cvd_smoke, cvd_pa, cvd_covars)

# merge with rbind
cvd_total <- as.data.frame(do.call(rbind, dfs))

### Categories 

## map variable names to results
cvd_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  cvd_total$Variable[cvd_total$Exposure %in% cvd_total$Exposure[substring(
    cvd_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
cvd_total <- merge(cvd_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
cvd_total$FDR <- p.adjust(cvd_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
cvd_total <- subset(cvd_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
cvd_table <- 
    subset(cvd_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
cvd_table$Significant <- 
    ifelse(cvd_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(cvd_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[13]] <- cvd_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_cvd[[1]]))

# remove disease-specific dataset for memory
rm(all_data_cvd)

```

# Cerebrovascular disease

```{r cerebro_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$cerebro_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_cerebro <- NA
    x$baseline_cerebro[baseline_ncd] <- 1
    x$baseline_cerebro[which(x$stroke_diagnosis == "Yes")] <- 1
    x$baseline_cerebro[which(x$cerebro_baseline_dx == 1)] <- 1
    x$baseline_cerebro[which(is.na(x$baseline_cerebro))] <- 0
    x$baseline_cerebro <- factor(x$baseline_cerebro)
    
    return(x)
}

# run function in each dataset
all_data_cerebro <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_cerebro <- lapply(all_data_cerebro, function(x) {
  x <- x[which(x$baseline_cerebro == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_cerebro[[1]]))
sample_sizes[14] <- nrow(all_data_cerebro[[1]])


### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_cerebro)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_cerebro[[j]]$time <- 
        as.numeric(all_data_cerebro[[j]]$cerebro_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_cerebro[[j]]$censor_age <-
        all_data_cerebro[[j]]$recruitment_age + all_data_cerebro[[j]]$time 
}

### Setting exposures 

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models 

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
cerebro_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_cerebro, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, cerebro_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_cerebro, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, cerebro_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_cerebro, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, cerebro_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_cerebro, function(y)
            coxph(Surv(recruitment_age, censor_age, cerebro_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_cerebro, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, cerebro_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_cerebro <- as.list(seq(1,length(exposures))) # create list to store model results
pool_cerebro <- pblapply(exposures, cerebro_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_cerebro[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
cerebro_rest <- rbindlist(smry)

# rename column for exposure
names(cerebro_rest)[names(cerebro_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
cerebro_rest$"exp(Beta)" <- exp(cerebro_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
cerebro_rest$"exp(Beta)_2.5%" <- exp(cerebro_rest$`2.5 %`)
cerebro_rest$"exp(Beta)_97.5%" <- exp(cerebro_rest$`97.5 %`)

# rename column for betas
names(cerebro_rest)[names(cerebro_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(cerebro_rest)[names(cerebro_rest) == "2.5 %"] <- "Beta_2.5%"
names(cerebro_rest)[names(cerebro_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_cerebro[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_cerebro[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_cerebro[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_cerebro[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_cerebro[rest][[j]]$pooled$estimate / sqrt(pool_cerebro[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_cerebro[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_cerebro[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
cerebro_rest <- cbind(cerebro_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(cerebro_rest$Exposure, cerebro_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
cerebro_rest$p.value <- ifelse(cerebro_rest$p.value == 0, 
                            cerebro_rest$p.value.full,
                            cerebro_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(cerebro_rest[which(cerebro_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

cerebro_rest <- cerebro_rest[!grepl("recruitment_centre", cerebro_rest$Exposure), ]
cerebro_rest <- cerebro_rest[!grepl("hshld_income", cerebro_rest$Exposure), ]
cerebro_rest <- cerebro_rest[!grepl("education_years", cerebro_rest$Exposure), ]
cerebro_rest <- cerebro_rest[!grepl("ethnicity", cerebro_rest$Exposure), ]
cerebro_rest <- cerebro_rest[!grepl("smoking_status", cerebro_rest$Exposure), ]
cerebro_rest <- cerebro_rest[!grepl("IPAQ_activity_group", cerebro_rest$Exposure), ]
cerebro_rest <- cerebro_rest[!grepl("overall_health", cerebro_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
cerebro_rest$Exposure <- gsub(".L", "", cerebro_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_cerebro[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
cerebro_smoke <- rbindlist(smry)

# rename column for exposure
names(cerebro_smoke)[names(cerebro_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
cerebro_smoke$"exp(Beta)" <- exp(cerebro_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
cerebro_smoke$"exp(Beta)_2.5%" <- exp(cerebro_smoke$`2.5 %`)
cerebro_smoke$"exp(Beta)_97.5%" <- exp(cerebro_smoke$`97.5 %`)

# rename column for betas
names(cerebro_smoke)[names(cerebro_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(cerebro_smoke)[names(cerebro_smoke) == "2.5 %"] <- "Beta_2.5%"
names(cerebro_smoke)[names(cerebro_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_cerebro[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_cerebro[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_cerebro[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_cerebro[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_cerebro[smoke][[j]]$pooled$estimate / sqrt(pool_cerebro[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_cerebro[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_cerebro[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
cerebro_smoke <- cbind(cerebro_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(cerebro_smoke$Exposure, cerebro_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
cerebro_smoke$p.value <- ifelse(cerebro_smoke$p.value == 0,
                            cerebro_smoke$p.value.full,
                            cerebro_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(cerebro_smoke[which(cerebro_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
cerebro_smoke <- cerebro_smoke[!grepl("recruitment_centre", cerebro_smoke$Exposure), ]
cerebro_smoke <- cerebro_smoke[!grepl("hshld_income", cerebro_smoke$Exposure), ]
cerebro_smoke <- cerebro_smoke[!grepl("education_years", cerebro_smoke$Exposure), ]
cerebro_smoke <- cerebro_smoke[!grepl("ethnicity", cerebro_smoke$Exposure), ]
cerebro_smoke <- cerebro_smoke[!grepl("IPAQ_activity_group", cerebro_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
cerebro_smoke$Exposure <- gsub(".L", "", cerebro_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
cerebro_pa <- summary(pool_cerebro[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(cerebro_pa)[names(cerebro_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
cerebro_pa$"exp(Beta)" <- exp(cerebro_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
cerebro_pa$"exp(Beta)_2.5%" <- exp(cerebro_pa$`2.5 %`)
cerebro_pa$"exp(Beta)_97.5%" <- exp(cerebro_pa$`97.5 %`)

# rename column for betas
names(cerebro_pa)[names(cerebro_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(cerebro_pa)[names(cerebro_pa) == "2.5 %"] <- "Beta_2.5%"
names(cerebro_pa)[names(cerebro_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_cerebro[[ipaq]]$pooled$estimate / sqrt(pool_cerebro[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_cerebro[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_cerebro[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
cerebro_pa <- cbind(cerebro_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(cerebro_pa$Exposure, cerebro_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
cerebro_pa$p.value <- ifelse(cerebro_pa$p.value == 0,
                            cerebro_pa$p.value.full,
                            cerebro_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(cerebro_pa[which(cerebro_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
cerebro_pa <- cerebro_pa[!grepl("recruitment_centre", cerebro_pa$Exposure), ]
cerebro_pa <- cerebro_pa[!grepl("hshld_income", cerebro_pa$Exposure), ]
cerebro_pa <- cerebro_pa[!grepl("education_years", cerebro_pa$Exposure), ]
cerebro_pa <- cerebro_pa[!grepl("ethnicity", cerebro_pa$Exposure), ]
cerebro_pa <- cerebro_pa[!grepl("smoking_status", cerebro_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
cerebro_pa$Exposure <- gsub(".L", "", cerebro_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
cerebro_covars <- summary(pool_cerebro[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(cerebro_covars)[names(cerebro_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
cerebro_covars$"exp(Beta)" <- exp(cerebro_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
cerebro_covars$"exp(Beta)_2.5%" <- exp(cerebro_covars$`2.5 %`)
cerebro_covars$"exp(Beta)_97.5%" <- exp(cerebro_covars$`97.5 %`)

# rename column for betas
names(cerebro_covars)[names(cerebro_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(cerebro_covars)[names(cerebro_covars) == "2.5 %"] <- "Beta_2.5%"
names(cerebro_covars)[names(cerebro_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_cerebro[covars][[1]]$pooled$estimate / sqrt(pool_cerebro[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_cerebro[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_cerebro[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
cerebro_covars <- cbind(cerebro_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(cerebro_covars$Exposure, cerebro_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
cerebro_covars$p.value <- ifelse(cerebro_covars$p.value == 0,
                            cerebro_covars$p.value.full,
                            cerebro_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(cerebro_covars[which(cerebro_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
cerebro_covars <- cerebro_covars[!grepl("smoking_status", cerebro_covars$Exposure), ]
cerebro_covars <- cerebro_covars[!grepl("IPAQ_activity_group", cerebro_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
cerebro_covars$Exposure <- gsub(".L", "", cerebro_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(cerebro_rest, cerebro_smoke, cerebro_pa, cerebro_covars)

# merge with rbind
cerebro_total <- as.data.frame(do.call(rbind, dfs))

### Categories 

## map variable names to results
cerebro_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  cerebro_total$Variable[cerebro_total$Exposure %in% cerebro_total$Exposure[substring(
    cerebro_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
cerebro_total <- merge(cerebro_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
cerebro_total$FDR <- p.adjust(cerebro_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
cerebro_total <- subset(cerebro_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
cerebro_table <- 
    subset(cerebro_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
cerebro_table$Significant <- 
    ifelse(cerebro_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(cerebro_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[14]] <- cerebro_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_cerebro[[1]]))

# remove disease-specific dataset for memory
rm(all_data_cerebro)

```

# Emphysema, COPD

```{r copd_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$COPD_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_copd <- NA
    x$baseline_copd[baseline_ncd] <- 1
    x$baseline_copd[which(x$bronchitis_emphysema_diagnosis == "Yes")] <- 1
    x$baseline_copd[which(x$COPD_baseline_dx == 1)] <- 1
    x$baseline_copd[which(is.na(x$baseline_copd))] <- 0
    x$baseline_copd <- factor(x$baseline_copd)
    
    return(x)
}

# run function in each dataset
all_data_copd <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_copd <- lapply(all_data_copd, function(x) {
  x <- x[which(x$baseline_copd == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_copd[[1]]))
sample_sizes[15] <- nrow(all_data_copd[[1]])

### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_copd)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_copd[[j]]$time <- 
        as.numeric(all_data_copd[[j]]$COPD_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_copd[[j]]$censor_age <-
        all_data_copd[[j]]$recruitment_age + all_data_copd[[j]]$time 
}

### Setting exposures 

# # load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models 

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
copd_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_copd, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, COPD_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_copd, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, COPD_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_copd, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, COPD_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_copd, function(y)
            coxph(Surv(recruitment_age, censor_age, COPD_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_copd, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, COPD_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_copd <- as.list(seq(1,length(exposures))) # create list to store model results
pool_copd <- pblapply(exposures, copd_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_copd[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
copd_rest <- rbindlist(smry)

# rename column for exposure
names(copd_rest)[names(copd_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
copd_rest$"exp(Beta)" <- exp(copd_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
copd_rest$"exp(Beta)_2.5%" <- exp(copd_rest$`2.5 %`)
copd_rest$"exp(Beta)_97.5%" <- exp(copd_rest$`97.5 %`)

# rename column for betas
names(copd_rest)[names(copd_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(copd_rest)[names(copd_rest) == "2.5 %"] <- "Beta_2.5%"
names(copd_rest)[names(copd_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values 

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_copd[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_copd[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_copd[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_copd[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_copd[rest][[j]]$pooled$estimate / sqrt(pool_copd[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_copd[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_copd[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
copd_rest <- cbind(copd_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(copd_rest$Exposure, copd_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
copd_rest$p.value <- ifelse(copd_rest$p.value == 0, 
                            copd_rest$p.value.full,
                            copd_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(copd_rest[which(copd_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

copd_rest <- copd_rest[!grepl("recruitment_centre", copd_rest$Exposure), ]
copd_rest <- copd_rest[!grepl("hshld_income", copd_rest$Exposure), ]
copd_rest <- copd_rest[!grepl("education_years", copd_rest$Exposure), ]
copd_rest <- copd_rest[!grepl("ethnicity", copd_rest$Exposure), ]
copd_rest <- copd_rest[!grepl("smoking_status", copd_rest$Exposure), ]
copd_rest <- copd_rest[!grepl("IPAQ_activity_group", copd_rest$Exposure), ]
copd_rest <- copd_rest[!grepl("overall_health", copd_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
copd_rest$Exposure <- gsub(".L", "", copd_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_copd[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
copd_smoke <- rbindlist(smry)

# rename column for exposure
names(copd_smoke)[names(copd_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
copd_smoke$"exp(Beta)" <- exp(copd_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
copd_smoke$"exp(Beta)_2.5%" <- exp(copd_smoke$`2.5 %`)
copd_smoke$"exp(Beta)_97.5%" <- exp(copd_smoke$`97.5 %`)

# rename column for betas
names(copd_smoke)[names(copd_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(copd_smoke)[names(copd_smoke) == "2.5 %"] <- "Beta_2.5%"
names(copd_smoke)[names(copd_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_copd[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_copd[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_copd[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_copd[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_copd[smoke][[j]]$pooled$estimate / sqrt(pool_copd[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_copd[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_copd[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
copd_smoke <- cbind(copd_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(copd_smoke$Exposure, copd_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
copd_smoke$p.value <- ifelse(copd_smoke$p.value == 0,
                            copd_smoke$p.value.full,
                            copd_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(copd_smoke[which(copd_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
copd_smoke <- copd_smoke[!grepl("recruitment_centre", copd_smoke$Exposure), ]
copd_smoke <- copd_smoke[!grepl("hshld_income", copd_smoke$Exposure), ]
copd_smoke <- copd_smoke[!grepl("education_years", copd_smoke$Exposure), ]
copd_smoke <- copd_smoke[!grepl("ethnicity", copd_smoke$Exposure), ]
copd_smoke <- copd_smoke[!grepl("IPAQ_activity_group", copd_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
copd_smoke$Exposure <- gsub(".L", "", copd_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
copd_pa <- summary(pool_copd[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(copd_pa)[names(copd_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
copd_pa$"exp(Beta)" <- exp(copd_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
copd_pa$"exp(Beta)_2.5%" <- exp(copd_pa$`2.5 %`)
copd_pa$"exp(Beta)_97.5%" <- exp(copd_pa$`97.5 %`)

# rename column for betas
names(copd_pa)[names(copd_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(copd_pa)[names(copd_pa) == "2.5 %"] <- "Beta_2.5%"
names(copd_pa)[names(copd_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_copd[[ipaq]]$pooled$estimate / sqrt(pool_copd[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_copd[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_copd[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
copd_pa <- cbind(copd_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(copd_pa$Exposure, copd_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
copd_pa$p.value <- ifelse(copd_pa$p.value == 0,
                            copd_pa$p.value.full,
                            copd_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(copd_pa[which(copd_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
copd_pa <- copd_pa[!grepl("recruitment_centre", copd_pa$Exposure), ]
copd_pa <- copd_pa[!grepl("hshld_income", copd_pa$Exposure), ]
copd_pa <- copd_pa[!grepl("education_years", copd_pa$Exposure), ]
copd_pa <- copd_pa[!grepl("ethnicity", copd_pa$Exposure), ]
copd_pa <- copd_pa[!grepl("smoking_status", copd_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
copd_pa$Exposure <- gsub(".L", "", copd_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
copd_covars <- summary(pool_copd[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(copd_covars)[names(copd_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
copd_covars$"exp(Beta)" <- exp(copd_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
copd_covars$"exp(Beta)_2.5%" <- exp(copd_covars$`2.5 %`)
copd_covars$"exp(Beta)_97.5%" <- exp(copd_covars$`97.5 %`)

# rename column for betas
names(copd_covars)[names(copd_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(copd_covars)[names(copd_covars) == "2.5 %"] <- "Beta_2.5%"
names(copd_covars)[names(copd_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_copd[covars][[1]]$pooled$estimate / sqrt(pool_copd[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_copd[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_copd[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
copd_covars <- cbind(copd_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(copd_covars$Exposure, copd_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
copd_covars$p.value <- ifelse(copd_covars$p.value == 0,
                            copd_covars$p.value.full,
                            copd_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(copd_covars[which(copd_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
copd_covars <- copd_covars[!grepl("smoking_status", copd_covars$Exposure), ]
copd_covars <- copd_covars[!grepl("IPAQ_activity_group", copd_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
copd_covars$Exposure <- gsub(".L", "", copd_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(copd_rest, copd_smoke, copd_pa, copd_covars)

# merge with rbind
copd_total <- as.data.frame(do.call(rbind, dfs))

### Categories 

## map variable names to results
copd_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  copd_total$Variable[copd_total$Exposure %in% copd_total$Exposure[substring(
    copd_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
copd_total <- merge(copd_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
copd_total$FDR <- p.adjust(copd_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
copd_total <- subset(copd_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
copd_table <- 
    subset(copd_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
copd_table$Significant <- 
    ifelse(copd_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(copd_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[15]] <- copd_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_copd[[1]]))

# remove disease-specific dataset for memory
rm(all_data_copd)

```

# Chronic liver diseases

```{r liver_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$liver_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_liver <- NA
    x$baseline_liver[baseline_ncd] <- 1
    x$baseline_liver[which(x$liver_baseline_dx == 1)] <- 1
    x$baseline_liver[which(is.na(x$baseline_liver))] <- 0
    x$baseline_liver <- factor(x$baseline_liver)
    
    return(x)
}

# run function in each dataset
all_data_liver <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_liver <- lapply(all_data_liver, function(x) {
  x <- x[which(x$baseline_liver == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_liver[[1]]))
sample_sizes[16] <- nrow(all_data_liver[[1]])


### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_liver)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_liver[[j]]$time <- 
        as.numeric(all_data_liver[[j]]$liver_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_liver[[j]]$censor_age <-
        all_data_liver[[j]]$recruitment_age + all_data_liver[[j]]$time 
}

### Setting exposures 

# # load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models 

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
liver_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_liver, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, liver_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_liver, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, liver_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_liver, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, liver_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_liver, function(y)
            coxph(Surv(recruitment_age, censor_age, liver_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_liver, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, liver_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_liver <- as.list(seq(1,length(exposures))) # create list to store model results
pool_liver <- pblapply(exposures, liver_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_liver[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
liver_rest <- rbindlist(smry)

# rename column for exposure
names(liver_rest)[names(liver_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
liver_rest$"exp(Beta)" <- exp(liver_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
liver_rest$"exp(Beta)_2.5%" <- exp(liver_rest$`2.5 %`)
liver_rest$"exp(Beta)_97.5%" <- exp(liver_rest$`97.5 %`)

# rename column for betas
names(liver_rest)[names(liver_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(liver_rest)[names(liver_rest) == "2.5 %"] <- "Beta_2.5%"
names(liver_rest)[names(liver_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_liver[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_liver[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_liver[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_liver[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_liver[rest][[j]]$pooled$estimate / sqrt(pool_liver[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_liver[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_liver[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
liver_rest <- cbind(liver_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(liver_rest$Exposure, liver_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
liver_rest$p.value <- ifelse(liver_rest$p.value == 0, 
                            liver_rest$p.value.full,
                            liver_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(liver_rest[which(liver_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

liver_rest <- liver_rest[!grepl("recruitment_centre", liver_rest$Exposure), ]
liver_rest <- liver_rest[!grepl("hshld_income", liver_rest$Exposure), ]
liver_rest <- liver_rest[!grepl("education_years", liver_rest$Exposure), ]
liver_rest <- liver_rest[!grepl("ethnicity", liver_rest$Exposure), ]
liver_rest <- liver_rest[!grepl("smoking_status", liver_rest$Exposure), ]
liver_rest <- liver_rest[!grepl("IPAQ_activity_group", liver_rest$Exposure), ]
liver_rest <- liver_rest[!grepl("overall_health", liver_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
liver_rest$Exposure <- gsub(".L", "", liver_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_liver[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
liver_smoke <- rbindlist(smry)

# rename column for exposure
names(liver_smoke)[names(liver_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
liver_smoke$"exp(Beta)" <- exp(liver_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
liver_smoke$"exp(Beta)_2.5%" <- exp(liver_smoke$`2.5 %`)
liver_smoke$"exp(Beta)_97.5%" <- exp(liver_smoke$`97.5 %`)

# rename column for betas
names(liver_smoke)[names(liver_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(liver_smoke)[names(liver_smoke) == "2.5 %"] <- "Beta_2.5%"
names(liver_smoke)[names(liver_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_liver[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_liver[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_liver[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_liver[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_liver[smoke][[j]]$pooled$estimate / sqrt(pool_liver[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_liver[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_liver[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
liver_smoke <- cbind(liver_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(liver_smoke$Exposure, liver_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
liver_smoke$p.value <- ifelse(liver_smoke$p.value == 0,
                            liver_smoke$p.value.full,
                            liver_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(liver_smoke[which(liver_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
liver_smoke <- liver_smoke[!grepl("recruitment_centre", liver_smoke$Exposure), ]
liver_smoke <- liver_smoke[!grepl("hshld_income", liver_smoke$Exposure), ]
liver_smoke <- liver_smoke[!grepl("education_years", liver_smoke$Exposure), ]
liver_smoke <- liver_smoke[!grepl("ethnicity", liver_smoke$Exposure), ]
liver_smoke <- liver_smoke[!grepl("IPAQ_activity_group", liver_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
liver_smoke$Exposure <- gsub(".L", "", liver_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
liver_pa <- summary(pool_liver[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(liver_pa)[names(liver_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
liver_pa$"exp(Beta)" <- exp(liver_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
liver_pa$"exp(Beta)_2.5%" <- exp(liver_pa$`2.5 %`)
liver_pa$"exp(Beta)_97.5%" <- exp(liver_pa$`97.5 %`)

# rename column for betas
names(liver_pa)[names(liver_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(liver_pa)[names(liver_pa) == "2.5 %"] <- "Beta_2.5%"
names(liver_pa)[names(liver_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_liver[[ipaq]]$pooled$estimate / sqrt(pool_liver[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_liver[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_liver[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
liver_pa <- cbind(liver_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(liver_pa$Exposure, liver_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
liver_pa$p.value <- ifelse(liver_pa$p.value == 0,
                            liver_pa$p.value.full,
                            liver_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(liver_pa[which(liver_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
liver_pa <- liver_pa[!grepl("recruitment_centre", liver_pa$Exposure), ]
liver_pa <- liver_pa[!grepl("hshld_income", liver_pa$Exposure), ]
liver_pa <- liver_pa[!grepl("education_years", liver_pa$Exposure), ]
liver_pa <- liver_pa[!grepl("ethnicity", liver_pa$Exposure), ]
liver_pa <- liver_pa[!grepl("smoking_status", liver_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
liver_pa$Exposure <- gsub(".L", "", liver_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
liver_covars <- summary(pool_liver[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(liver_covars)[names(liver_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
liver_covars$"exp(Beta)" <- exp(liver_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
liver_covars$"exp(Beta)_2.5%" <- exp(liver_covars$`2.5 %`)
liver_covars$"exp(Beta)_97.5%" <- exp(liver_covars$`97.5 %`)

# rename column for betas
names(liver_covars)[names(liver_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(liver_covars)[names(liver_covars) == "2.5 %"] <- "Beta_2.5%"
names(liver_covars)[names(liver_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_liver[covars][[1]]$pooled$estimate / sqrt(pool_liver[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_liver[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_liver[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
liver_covars <- cbind(liver_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(liver_covars$Exposure, liver_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
liver_covars$p.value <- ifelse(liver_covars$p.value == 0,
                            liver_covars$p.value.full,
                            liver_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(liver_covars[which(liver_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
liver_covars <- liver_covars[!grepl("smoking_status", liver_covars$Exposure), ]
liver_covars <- liver_covars[!grepl("IPAQ_activity_group", liver_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
liver_covars$Exposure <- gsub(".L", "", liver_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(liver_rest, liver_smoke, liver_pa, liver_covars)

# merge with rbind
liver_total <- as.data.frame(do.call(rbind, dfs))

### Categories 

## map variable names to results
liver_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  liver_total$Variable[liver_total$Exposure %in% liver_total$Exposure[substring(
    liver_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
liver_total <- merge(liver_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
liver_total$FDR <- p.adjust(liver_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
liver_total <- subset(liver_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
liver_table <- 
    subset(liver_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
liver_table$Significant <- 
    ifelse(liver_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(liver_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[16]] <- liver_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_liver[[1]]))

# remove disease-specific dataset for memory
rm(all_data_liver)

```

# Chronic kidney diseases

```{r kidney_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$kidney_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_kidney <- NA
    x$baseline_kidney[baseline_ncd] <- 1
    x$baseline_kidney[which(x$kidney_baseline_dx == 1)] <- 1
    x$baseline_kidney[which(is.na(x$baseline_kidney))] <- 0
    x$baseline_kidney <- factor(x$baseline_kidney)
    
    return(x)
}

# run function in each dataset
all_data_kidney <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_kidney <- lapply(all_data_kidney, function(x) {
  x <- x[which(x$baseline_kidney == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_kidney[[1]]))
sample_sizes[17] <- nrow(all_data_kidney[[1]])

### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_kidney)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_kidney[[j]]$time <- 
        as.numeric(all_data_kidney[[j]]$kidney_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_kidney[[j]]$censor_age <-
        all_data_kidney[[j]]$recruitment_age + all_data_kidney[[j]]$time 
}

### Setting exposures 
# 
# # load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models 

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
kidney_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_kidney, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, kidney_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_kidney, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, kidney_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_kidney, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, kidney_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_kidney, function(y)
            coxph(Surv(recruitment_age, censor_age, kidney_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_kidney, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, kidney_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_kidney <- as.list(seq(1,length(exposures))) # create list to store model results
pool_kidney <- pblapply(exposures, kidney_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_kidney[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
kidney_rest <- rbindlist(smry)

# rename column for exposure
names(kidney_rest)[names(kidney_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
kidney_rest$"exp(Beta)" <- exp(kidney_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
kidney_rest$"exp(Beta)_2.5%" <- exp(kidney_rest$`2.5 %`)
kidney_rest$"exp(Beta)_97.5%" <- exp(kidney_rest$`97.5 %`)

# rename column for betas
names(kidney_rest)[names(kidney_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(kidney_rest)[names(kidney_rest) == "2.5 %"] <- "Beta_2.5%"
names(kidney_rest)[names(kidney_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_kidney[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_kidney[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_kidney[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_kidney[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_kidney[rest][[j]]$pooled$estimate / sqrt(pool_kidney[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_kidney[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_kidney[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
kidney_rest <- cbind(kidney_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(kidney_rest$Exposure, kidney_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
kidney_rest$p.value <- ifelse(kidney_rest$p.value == 0, 
                            kidney_rest$p.value.full,
                            kidney_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(kidney_rest[which(kidney_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

kidney_rest <- kidney_rest[!grepl("recruitment_centre", kidney_rest$Exposure), ]
kidney_rest <- kidney_rest[!grepl("hshld_income", kidney_rest$Exposure), ]
kidney_rest <- kidney_rest[!grepl("education_years", kidney_rest$Exposure), ]
kidney_rest <- kidney_rest[!grepl("ethnicity", kidney_rest$Exposure), ]
kidney_rest <- kidney_rest[!grepl("smoking_status", kidney_rest$Exposure), ]
kidney_rest <- kidney_rest[!grepl("IPAQ_activity_group", kidney_rest$Exposure), ]
kidney_rest <- kidney_rest[!grepl("overall_health", kidney_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
kidney_rest$Exposure <- gsub(".L", "", kidney_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_kidney[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
kidney_smoke <- rbindlist(smry)

# rename column for exposure
names(kidney_smoke)[names(kidney_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
kidney_smoke$"exp(Beta)" <- exp(kidney_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
kidney_smoke$"exp(Beta)_2.5%" <- exp(kidney_smoke$`2.5 %`)
kidney_smoke$"exp(Beta)_97.5%" <- exp(kidney_smoke$`97.5 %`)

# rename column for betas
names(kidney_smoke)[names(kidney_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(kidney_smoke)[names(kidney_smoke) == "2.5 %"] <- "Beta_2.5%"
names(kidney_smoke)[names(kidney_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_kidney[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_kidney[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_kidney[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_kidney[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_kidney[smoke][[j]]$pooled$estimate / sqrt(pool_kidney[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_kidney[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_kidney[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
kidney_smoke <- cbind(kidney_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(kidney_smoke$Exposure, kidney_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
kidney_smoke$p.value <- ifelse(kidney_smoke$p.value == 0,
                            kidney_smoke$p.value.full,
                            kidney_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(kidney_smoke[which(kidney_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
kidney_smoke <- kidney_smoke[!grepl("recruitment_centre", kidney_smoke$Exposure), ]
kidney_smoke <- kidney_smoke[!grepl("hshld_income", kidney_smoke$Exposure), ]
kidney_smoke <- kidney_smoke[!grepl("education_years", kidney_smoke$Exposure), ]
kidney_smoke <- kidney_smoke[!grepl("ethnicity", kidney_smoke$Exposure), ]
kidney_smoke <- kidney_smoke[!grepl("IPAQ_activity_group", kidney_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
kidney_smoke$Exposure <- gsub(".L", "", kidney_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
kidney_pa <- summary(pool_kidney[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(kidney_pa)[names(kidney_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
kidney_pa$"exp(Beta)" <- exp(kidney_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
kidney_pa$"exp(Beta)_2.5%" <- exp(kidney_pa$`2.5 %`)
kidney_pa$"exp(Beta)_97.5%" <- exp(kidney_pa$`97.5 %`)

# rename column for betas
names(kidney_pa)[names(kidney_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(kidney_pa)[names(kidney_pa) == "2.5 %"] <- "Beta_2.5%"
names(kidney_pa)[names(kidney_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_kidney[[ipaq]]$pooled$estimate / sqrt(pool_kidney[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_kidney[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_kidney[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
kidney_pa <- cbind(kidney_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(kidney_pa$Exposure, kidney_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
kidney_pa$p.value <- ifelse(kidney_pa$p.value == 0,
                            kidney_pa$p.value.full,
                            kidney_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(kidney_pa[which(kidney_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
kidney_pa <- kidney_pa[!grepl("recruitment_centre", kidney_pa$Exposure), ]
kidney_pa <- kidney_pa[!grepl("hshld_income", kidney_pa$Exposure), ]
kidney_pa <- kidney_pa[!grepl("education_years", kidney_pa$Exposure), ]
kidney_pa <- kidney_pa[!grepl("ethnicity", kidney_pa$Exposure), ]
kidney_pa <- kidney_pa[!grepl("smoking_status", kidney_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
kidney_pa$Exposure <- gsub(".L", "", kidney_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
kidney_covars <- summary(pool_kidney[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(kidney_covars)[names(kidney_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
kidney_covars$"exp(Beta)" <- exp(kidney_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
kidney_covars$"exp(Beta)_2.5%" <- exp(kidney_covars$`2.5 %`)
kidney_covars$"exp(Beta)_97.5%" <- exp(kidney_covars$`97.5 %`)

# rename column for betas
names(kidney_covars)[names(kidney_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(kidney_covars)[names(kidney_covars) == "2.5 %"] <- "Beta_2.5%"
names(kidney_covars)[names(kidney_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_kidney[covars][[1]]$pooled$estimate / sqrt(pool_kidney[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_kidney[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_kidney[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
kidney_covars <- cbind(kidney_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(kidney_covars$Exposure, kidney_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
kidney_covars$p.value <- ifelse(kidney_covars$p.value == 0,
                            kidney_covars$p.value.full,
                            kidney_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(kidney_covars[which(kidney_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
kidney_covars <- kidney_covars[!grepl("smoking_status", kidney_covars$Exposure), ]
kidney_covars <- kidney_covars[!grepl("IPAQ_activity_group", kidney_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
kidney_covars$Exposure <- gsub(".L", "", kidney_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(kidney_rest, kidney_smoke, kidney_pa, kidney_covars)

# merge with rbind
kidney_total <- as.data.frame(do.call(rbind, dfs))

### Categories 

## map variable names to results
kidney_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  kidney_total$Variable[kidney_total$Exposure %in% kidney_total$Exposure[substring(
    kidney_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
kidney_total <- merge(kidney_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
kidney_total$FDR <- p.adjust(kidney_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
kidney_total <- subset(kidney_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
kidney_table <- 
    subset(kidney_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
kidney_table$Significant <- 
    ifelse(kidney_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(kidney_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[17]] <- kidney_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_kidney[[1]]))

# remove disease-specific dataset for memory
rm(all_data_kidney)

```

# All-cause dementia

```{r all_dementia_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$all_dementia_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_all_dementia <- NA
    x$baseline_all_dementia[baseline_ncd] <- 1
    x$baseline_all_dementia[which(x$all_dementia_baseline_dx == 1)] <- 1
    x$baseline_all_dementia[which(is.na(x$baseline_all_dementia))] <- 0
    x$baseline_all_dementia <- factor(x$baseline_all_dementia)
    
    return(x)
}

# run function in each dataset
all_data_all_dementia <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_all_dementia <- lapply(all_data_all_dementia, function(x) {
  x <- x[which(x$baseline_all_dementia == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_all_dementia[[1]]))
sample_sizes[18] <- nrow(all_data_all_dementia[[1]])


### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_all_dementia)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_all_dementia[[j]]$time <- 
        as.numeric(all_data_all_dementia[[j]]$all_dementia_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_all_dementia[[j]]$censor_age <-
        all_data_all_dementia[[j]]$recruitment_age + all_data_all_dementia[[j]]$time 
}

### Setting exposures 

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models 

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
all_dementia_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_all_dementia, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, all_dementia_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_all_dementia, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, all_dementia_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_all_dementia, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, all_dementia_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_all_dementia, function(y)
            coxph(Surv(recruitment_age, censor_age, all_dementia_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_all_dementia, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, all_dementia_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_all_dementia <- as.list(seq(1,length(exposures))) # create list to store model results
pool_all_dementia <- pblapply(exposures, all_dementia_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_all_dementia[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
all_dementia_rest <- rbindlist(smry)

# rename column for exposure
names(all_dementia_rest)[names(all_dementia_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
all_dementia_rest$"exp(Beta)" <- exp(all_dementia_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
all_dementia_rest$"exp(Beta)_2.5%" <- exp(all_dementia_rest$`2.5 %`)
all_dementia_rest$"exp(Beta)_97.5%" <- exp(all_dementia_rest$`97.5 %`)

# rename column for betas
names(all_dementia_rest)[names(all_dementia_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(all_dementia_rest)[names(all_dementia_rest) == "2.5 %"] <- "Beta_2.5%"
names(all_dementia_rest)[names(all_dementia_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_all_dementia[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_all_dementia[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_all_dementia[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_all_dementia[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_all_dementia[rest][[j]]$pooled$estimate / sqrt(pool_all_dementia[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_all_dementia[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_all_dementia[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
all_dementia_rest <- cbind(all_dementia_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(all_dementia_rest$Exposure, all_dementia_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
all_dementia_rest$p.value <- ifelse(all_dementia_rest$p.value == 0, 
                            all_dementia_rest$p.value.full,
                            all_dementia_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(all_dementia_rest[which(all_dementia_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

all_dementia_rest <- all_dementia_rest[!grepl("recruitment_centre", all_dementia_rest$Exposure), ]
all_dementia_rest <- all_dementia_rest[!grepl("hshld_income", all_dementia_rest$Exposure), ]
all_dementia_rest <- all_dementia_rest[!grepl("education_years", all_dementia_rest$Exposure), ]
all_dementia_rest <- all_dementia_rest[!grepl("ethnicity", all_dementia_rest$Exposure), ]
all_dementia_rest <- all_dementia_rest[!grepl("smoking_status", all_dementia_rest$Exposure), ]
all_dementia_rest <- all_dementia_rest[!grepl("IPAQ_activity_group", all_dementia_rest$Exposure), ]
all_dementia_rest <- all_dementia_rest[!grepl("overall_health", all_dementia_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
all_dementia_rest$Exposure <- gsub(".L", "", all_dementia_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_all_dementia[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
all_dementia_smoke <- rbindlist(smry)

# rename column for exposure
names(all_dementia_smoke)[names(all_dementia_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
all_dementia_smoke$"exp(Beta)" <- exp(all_dementia_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
all_dementia_smoke$"exp(Beta)_2.5%" <- exp(all_dementia_smoke$`2.5 %`)
all_dementia_smoke$"exp(Beta)_97.5%" <- exp(all_dementia_smoke$`97.5 %`)

# rename column for betas
names(all_dementia_smoke)[names(all_dementia_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(all_dementia_smoke)[names(all_dementia_smoke) == "2.5 %"] <- "Beta_2.5%"
names(all_dementia_smoke)[names(all_dementia_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_all_dementia[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_all_dementia[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_all_dementia[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_all_dementia[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_all_dementia[smoke][[j]]$pooled$estimate / sqrt(pool_all_dementia[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_all_dementia[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_all_dementia[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
all_dementia_smoke <- cbind(all_dementia_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(all_dementia_smoke$Exposure, all_dementia_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
all_dementia_smoke$p.value <- ifelse(all_dementia_smoke$p.value == 0,
                            all_dementia_smoke$p.value.full,
                            all_dementia_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(all_dementia_smoke[which(all_dementia_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
all_dementia_smoke <- all_dementia_smoke[!grepl("recruitment_centre", all_dementia_smoke$Exposure), ]
all_dementia_smoke <- all_dementia_smoke[!grepl("hshld_income", all_dementia_smoke$Exposure), ]
all_dementia_smoke <- all_dementia_smoke[!grepl("education_years", all_dementia_smoke$Exposure), ]
all_dementia_smoke <- all_dementia_smoke[!grepl("ethnicity", all_dementia_smoke$Exposure), ]
all_dementia_smoke <- all_dementia_smoke[!grepl("IPAQ_activity_group", all_dementia_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
all_dementia_smoke$Exposure <- gsub(".L", "", all_dementia_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
all_dementia_pa <- summary(pool_all_dementia[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(all_dementia_pa)[names(all_dementia_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
all_dementia_pa$"exp(Beta)" <- exp(all_dementia_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
all_dementia_pa$"exp(Beta)_2.5%" <- exp(all_dementia_pa$`2.5 %`)
all_dementia_pa$"exp(Beta)_97.5%" <- exp(all_dementia_pa$`97.5 %`)

# rename column for betas
names(all_dementia_pa)[names(all_dementia_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(all_dementia_pa)[names(all_dementia_pa) == "2.5 %"] <- "Beta_2.5%"
names(all_dementia_pa)[names(all_dementia_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_all_dementia[[ipaq]]$pooled$estimate / sqrt(pool_all_dementia[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_all_dementia[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_all_dementia[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
all_dementia_pa <- cbind(all_dementia_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(all_dementia_pa$Exposure, all_dementia_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
all_dementia_pa$p.value <- ifelse(all_dementia_pa$p.value == 0,
                            all_dementia_pa$p.value.full,
                            all_dementia_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(all_dementia_pa[which(all_dementia_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
all_dementia_pa <- all_dementia_pa[!grepl("recruitment_centre", all_dementia_pa$Exposure), ]
all_dementia_pa <- all_dementia_pa[!grepl("hshld_income", all_dementia_pa$Exposure), ]
all_dementia_pa <- all_dementia_pa[!grepl("education_years", all_dementia_pa$Exposure), ]
all_dementia_pa <- all_dementia_pa[!grepl("ethnicity", all_dementia_pa$Exposure), ]
all_dementia_pa <- all_dementia_pa[!grepl("smoking_status", all_dementia_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
all_dementia_pa$Exposure <- gsub(".L", "", all_dementia_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
all_dementia_covars <- summary(pool_all_dementia[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(all_dementia_covars)[names(all_dementia_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
all_dementia_covars$"exp(Beta)" <- exp(all_dementia_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
all_dementia_covars$"exp(Beta)_2.5%" <- exp(all_dementia_covars$`2.5 %`)
all_dementia_covars$"exp(Beta)_97.5%" <- exp(all_dementia_covars$`97.5 %`)

# rename column for betas
names(all_dementia_covars)[names(all_dementia_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(all_dementia_covars)[names(all_dementia_covars) == "2.5 %"] <- "Beta_2.5%"
names(all_dementia_covars)[names(all_dementia_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_all_dementia[covars][[1]]$pooled$estimate / sqrt(pool_all_dementia[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_all_dementia[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_all_dementia[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
all_dementia_covars <- cbind(all_dementia_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(all_dementia_covars$Exposure, all_dementia_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
all_dementia_covars$p.value <- ifelse(all_dementia_covars$p.value == 0,
                            all_dementia_covars$p.value.full,
                            all_dementia_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(all_dementia_covars[which(all_dementia_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
all_dementia_covars <- all_dementia_covars[!grepl("smoking_status", all_dementia_covars$Exposure), ]
all_dementia_covars <- all_dementia_covars[!grepl("IPAQ_activity_group", all_dementia_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
all_dementia_covars$Exposure <- gsub(".L", "", all_dementia_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(all_dementia_rest, all_dementia_smoke, all_dementia_pa, all_dementia_covars)

# merge with rbind
all_dementia_total <- as.data.frame(do.call(rbind, dfs))

### Categories 

## map variable names to results
all_dementia_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  all_dementia_total$Variable[all_dementia_total$Exposure %in% all_dementia_total$Exposure[substring(
    all_dementia_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
all_dementia_total <- merge(all_dementia_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
all_dementia_total$FDR <- p.adjust(all_dementia_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
all_dementia_total <- subset(all_dementia_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
all_dementia_table <- 
    subset(all_dementia_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
all_dementia_table$Significant <- 
    ifelse(all_dementia_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(all_dementia_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[18]] <- all_dementia_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_all_dementia[[1]]))

# remove disease-specific dataset for memory
rm(all_data_all_dementia)

```

# Vascular dementia

```{r vasc_dementia_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$vasc_dementia_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_vasc_dementia <- NA
    x$baseline_vasc_dementia[baseline_ncd] <- 1
    x$baseline_vasc_dementia[which(x$vasc_dementia_baseline_dx == 1)] <- 1
    x$baseline_vasc_dementia[which(is.na(x$baseline_vasc_dementia))] <- 0
    x$baseline_vasc_dementia <- factor(x$baseline_vasc_dementia)
    
    return(x)
}

# run function in each dataset
all_data_vasc_dementia <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_vasc_dementia <- lapply(all_data_vasc_dementia, function(x) {
  x <- x[which(x$baseline_vasc_dementia == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_vasc_dementia[[1]]))
sample_sizes[19] <- nrow(all_data_vasc_dementia[[1]])


### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_vasc_dementia)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_vasc_dementia[[j]]$time <- 
        as.numeric(all_data_vasc_dementia[[j]]$vasc_dementia_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_vasc_dementia[[j]]$censor_age <-
        all_data_vasc_dementia[[j]]$recruitment_age + all_data_vasc_dementia[[j]]$time 
}

### Setting exposures 

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models 

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
vasc_dementia_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_vasc_dementia, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, vasc_dementia_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_vasc_dementia, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, vasc_dementia_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_vasc_dementia, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, vasc_dementia_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_vasc_dementia, function(y)
            coxph(Surv(recruitment_age, censor_age, vasc_dementia_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_vasc_dementia, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, vasc_dementia_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_vasc_dementia <- as.list(seq(1,length(exposures))) # create list to store model results
pool_vasc_dementia <- pblapply(exposures, vasc_dementia_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_vasc_dementia[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
vasc_dementia_rest <- rbindlist(smry)

# rename column for exposure
names(vasc_dementia_rest)[names(vasc_dementia_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
vasc_dementia_rest$"exp(Beta)" <- exp(vasc_dementia_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
vasc_dementia_rest$"exp(Beta)_2.5%" <- exp(vasc_dementia_rest$`2.5 %`)
vasc_dementia_rest$"exp(Beta)_97.5%" <- exp(vasc_dementia_rest$`97.5 %`)

# rename column for betas
names(vasc_dementia_rest)[names(vasc_dementia_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(vasc_dementia_rest)[names(vasc_dementia_rest) == "2.5 %"] <- "Beta_2.5%"
names(vasc_dementia_rest)[names(vasc_dementia_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_vasc_dementia[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_vasc_dementia[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_vasc_dementia[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_vasc_dementia[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_vasc_dementia[rest][[j]]$pooled$estimate / sqrt(pool_vasc_dementia[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_vasc_dementia[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_vasc_dementia[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
vasc_dementia_rest <- cbind(vasc_dementia_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(vasc_dementia_rest$Exposure, vasc_dementia_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
vasc_dementia_rest$p.value <- ifelse(vasc_dementia_rest$p.value == 0, 
                            vasc_dementia_rest$p.value.full,
                            vasc_dementia_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(vasc_dementia_rest[which(vasc_dementia_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

vasc_dementia_rest <- vasc_dementia_rest[!grepl("recruitment_centre", vasc_dementia_rest$Exposure), ]
vasc_dementia_rest <- vasc_dementia_rest[!grepl("hshld_income", vasc_dementia_rest$Exposure), ]
vasc_dementia_rest <- vasc_dementia_rest[!grepl("education_years", vasc_dementia_rest$Exposure), ]
vasc_dementia_rest <- vasc_dementia_rest[!grepl("ethnicity", vasc_dementia_rest$Exposure), ]
vasc_dementia_rest <- vasc_dementia_rest[!grepl("smoking_status", vasc_dementia_rest$Exposure), ]
vasc_dementia_rest <- vasc_dementia_rest[!grepl("IPAQ_activity_group", vasc_dementia_rest$Exposure), ]
vasc_dementia_rest <- vasc_dementia_rest[!grepl("overall_health", vasc_dementia_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
vasc_dementia_rest$Exposure <- gsub(".L", "", vasc_dementia_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_vasc_dementia[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
vasc_dementia_smoke <- rbindlist(smry)

# rename column for exposure
names(vasc_dementia_smoke)[names(vasc_dementia_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
vasc_dementia_smoke$"exp(Beta)" <- exp(vasc_dementia_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
vasc_dementia_smoke$"exp(Beta)_2.5%" <- exp(vasc_dementia_smoke$`2.5 %`)
vasc_dementia_smoke$"exp(Beta)_97.5%" <- exp(vasc_dementia_smoke$`97.5 %`)

# rename column for betas
names(vasc_dementia_smoke)[names(vasc_dementia_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(vasc_dementia_smoke)[names(vasc_dementia_smoke) == "2.5 %"] <- "Beta_2.5%"
names(vasc_dementia_smoke)[names(vasc_dementia_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_vasc_dementia[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_vasc_dementia[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_vasc_dementia[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_vasc_dementia[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_vasc_dementia[smoke][[j]]$pooled$estimate / sqrt(pool_vasc_dementia[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_vasc_dementia[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_vasc_dementia[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
vasc_dementia_smoke <- cbind(vasc_dementia_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(vasc_dementia_smoke$Exposure, vasc_dementia_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
vasc_dementia_smoke$p.value <- ifelse(vasc_dementia_smoke$p.value == 0,
                            vasc_dementia_smoke$p.value.full,
                            vasc_dementia_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(vasc_dementia_smoke[which(vasc_dementia_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
vasc_dementia_smoke <- vasc_dementia_smoke[!grepl("recruitment_centre", vasc_dementia_smoke$Exposure), ]
vasc_dementia_smoke <- vasc_dementia_smoke[!grepl("hshld_income", vasc_dementia_smoke$Exposure), ]
vasc_dementia_smoke <- vasc_dementia_smoke[!grepl("education_years", vasc_dementia_smoke$Exposure), ]
vasc_dementia_smoke <- vasc_dementia_smoke[!grepl("ethnicity", vasc_dementia_smoke$Exposure), ]
vasc_dementia_smoke <- vasc_dementia_smoke[!grepl("IPAQ_activity_group", vasc_dementia_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
vasc_dementia_smoke$Exposure <- gsub(".L", "", vasc_dementia_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
vasc_dementia_pa <- summary(pool_vasc_dementia[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(vasc_dementia_pa)[names(vasc_dementia_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
vasc_dementia_pa$"exp(Beta)" <- exp(vasc_dementia_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
vasc_dementia_pa$"exp(Beta)_2.5%" <- exp(vasc_dementia_pa$`2.5 %`)
vasc_dementia_pa$"exp(Beta)_97.5%" <- exp(vasc_dementia_pa$`97.5 %`)

# rename column for betas
names(vasc_dementia_pa)[names(vasc_dementia_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(vasc_dementia_pa)[names(vasc_dementia_pa) == "2.5 %"] <- "Beta_2.5%"
names(vasc_dementia_pa)[names(vasc_dementia_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_vasc_dementia[[ipaq]]$pooled$estimate / sqrt(pool_vasc_dementia[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_vasc_dementia[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_vasc_dementia[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
vasc_dementia_pa <- cbind(vasc_dementia_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(vasc_dementia_pa$Exposure, vasc_dementia_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
vasc_dementia_pa$p.value <- ifelse(vasc_dementia_pa$p.value == 0,
                            vasc_dementia_pa$p.value.full,
                            vasc_dementia_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(vasc_dementia_pa[which(vasc_dementia_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
vasc_dementia_pa <- vasc_dementia_pa[!grepl("recruitment_centre", vasc_dementia_pa$Exposure), ]
vasc_dementia_pa <- vasc_dementia_pa[!grepl("hshld_income", vasc_dementia_pa$Exposure), ]
vasc_dementia_pa <- vasc_dementia_pa[!grepl("education_years", vasc_dementia_pa$Exposure), ]
vasc_dementia_pa <- vasc_dementia_pa[!grepl("ethnicity", vasc_dementia_pa$Exposure), ]
vasc_dementia_pa <- vasc_dementia_pa[!grepl("smoking_status", vasc_dementia_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
vasc_dementia_pa$Exposure <- gsub(".L", "", vasc_dementia_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
vasc_dementia_covars <- summary(pool_vasc_dementia[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(vasc_dementia_covars)[names(vasc_dementia_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
vasc_dementia_covars$"exp(Beta)" <- exp(vasc_dementia_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
vasc_dementia_covars$"exp(Beta)_2.5%" <- exp(vasc_dementia_covars$`2.5 %`)
vasc_dementia_covars$"exp(Beta)_97.5%" <- exp(vasc_dementia_covars$`97.5 %`)

# rename column for betas
names(vasc_dementia_covars)[names(vasc_dementia_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(vasc_dementia_covars)[names(vasc_dementia_covars) == "2.5 %"] <- "Beta_2.5%"
names(vasc_dementia_covars)[names(vasc_dementia_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_vasc_dementia[covars][[1]]$pooled$estimate / sqrt(pool_vasc_dementia[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_vasc_dementia[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_vasc_dementia[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
vasc_dementia_covars <- cbind(vasc_dementia_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(vasc_dementia_covars$Exposure, vasc_dementia_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
vasc_dementia_covars$p.value <- ifelse(vasc_dementia_covars$p.value == 0,
                            vasc_dementia_covars$p.value.full,
                            vasc_dementia_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(vasc_dementia_covars[which(vasc_dementia_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
vasc_dementia_covars <- vasc_dementia_covars[!grepl("smoking_status", vasc_dementia_covars$Exposure), ]
vasc_dementia_covars <- vasc_dementia_covars[!grepl("IPAQ_activity_group", vasc_dementia_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
vasc_dementia_covars$Exposure <- gsub(".L", "", vasc_dementia_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(vasc_dementia_rest, vasc_dementia_smoke, vasc_dementia_pa, vasc_dementia_covars)

# merge with rbind
vasc_dementia_total <- as.data.frame(do.call(rbind, dfs))

### Categories 

## map variable names to results
vasc_dementia_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  vasc_dementia_total$Variable[vasc_dementia_total$Exposure %in% vasc_dementia_total$Exposure[substring(
    vasc_dementia_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
vasc_dementia_total <- merge(vasc_dementia_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
vasc_dementia_total$FDR <- p.adjust(vasc_dementia_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
vasc_dementia_total <- subset(vasc_dementia_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
vasc_dementia_table <- 
    subset(vasc_dementia_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
vasc_dementia_table$Significant <- 
    ifelse(vasc_dementia_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(vasc_dementia_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[19]] <- vasc_dementia_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_vasc_dementia[[1]]))

# remove disease-specific dataset for memory
rm(all_data_vasc_dementia)

```

# Alzheimer's disease

```{r alzheimers_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$alzheimers_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_alzheimers <- NA
    x$baseline_alzheimers[baseline_ncd] <- 1
    x$baseline_alzheimers[which(x$alzheimers_baseline_dx == 1)] <- 1
    x$baseline_alzheimers[which(is.na(x$baseline_alzheimers))] <- 0
    x$baseline_alzheimers <- factor(x$baseline_alzheimers)
    
    return(x)
}

# run function in each dataset
all_data_alzheimers <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_alzheimers <- lapply(all_data_alzheimers, function(x) {
  x <- x[which(x$baseline_alzheimers == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_alzheimers[[1]]))
sample_sizes[20] <- nrow(all_data_alzheimers[[1]])


### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_alzheimers)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_alzheimers[[j]]$time <- 
        as.numeric(all_data_alzheimers[[j]]$alzheimers_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_alzheimers[[j]]$censor_age <-
        all_data_alzheimers[[j]]$recruitment_age + all_data_alzheimers[[j]]$time 
}

### Setting exposures 

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models 

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
alzheimers_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_alzheimers, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, alzheimers_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_alzheimers, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, alzheimers_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_alzheimers, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, alzheimers_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_alzheimers, function(y)
            coxph(Surv(recruitment_age, censor_age, alzheimers_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_alzheimers, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, alzheimers_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_alzheimers <- as.list(seq(1,length(exposures))) # create list to store model results
pool_alzheimers <- pblapply(exposures, alzheimers_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_alzheimers[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
alzheimers_rest <- rbindlist(smry)

# rename column for exposure
names(alzheimers_rest)[names(alzheimers_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
alzheimers_rest$"exp(Beta)" <- exp(alzheimers_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
alzheimers_rest$"exp(Beta)_2.5%" <- exp(alzheimers_rest$`2.5 %`)
alzheimers_rest$"exp(Beta)_97.5%" <- exp(alzheimers_rest$`97.5 %`)

# rename column for betas
names(alzheimers_rest)[names(alzheimers_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(alzheimers_rest)[names(alzheimers_rest) == "2.5 %"] <- "Beta_2.5%"
names(alzheimers_rest)[names(alzheimers_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_alzheimers[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_alzheimers[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_alzheimers[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_alzheimers[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_alzheimers[rest][[j]]$pooled$estimate / sqrt(pool_alzheimers[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_alzheimers[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_alzheimers[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
alzheimers_rest <- cbind(alzheimers_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(alzheimers_rest$Exposure, alzheimers_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
alzheimers_rest$p.value <- ifelse(alzheimers_rest$p.value == 0, 
                            alzheimers_rest$p.value.full,
                            alzheimers_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(alzheimers_rest[which(alzheimers_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

alzheimers_rest <- alzheimers_rest[!grepl("recruitment_centre", alzheimers_rest$Exposure), ]
alzheimers_rest <- alzheimers_rest[!grepl("hshld_income", alzheimers_rest$Exposure), ]
alzheimers_rest <- alzheimers_rest[!grepl("education_years", alzheimers_rest$Exposure), ]
alzheimers_rest <- alzheimers_rest[!grepl("ethnicity", alzheimers_rest$Exposure), ]
alzheimers_rest <- alzheimers_rest[!grepl("smoking_status", alzheimers_rest$Exposure), ]
alzheimers_rest <- alzheimers_rest[!grepl("IPAQ_activity_group", alzheimers_rest$Exposure), ]
alzheimers_rest <- alzheimers_rest[!grepl("overall_health", alzheimers_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
alzheimers_rest$Exposure <- gsub(".L", "", alzheimers_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_alzheimers[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
alzheimers_smoke <- rbindlist(smry)

# rename column for exposure
names(alzheimers_smoke)[names(alzheimers_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
alzheimers_smoke$"exp(Beta)" <- exp(alzheimers_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
alzheimers_smoke$"exp(Beta)_2.5%" <- exp(alzheimers_smoke$`2.5 %`)
alzheimers_smoke$"exp(Beta)_97.5%" <- exp(alzheimers_smoke$`97.5 %`)

# rename column for betas
names(alzheimers_smoke)[names(alzheimers_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(alzheimers_smoke)[names(alzheimers_smoke) == "2.5 %"] <- "Beta_2.5%"
names(alzheimers_smoke)[names(alzheimers_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_alzheimers[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_alzheimers[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_alzheimers[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_alzheimers[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_alzheimers[smoke][[j]]$pooled$estimate / sqrt(pool_alzheimers[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_alzheimers[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_alzheimers[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
alzheimers_smoke <- cbind(alzheimers_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(alzheimers_smoke$Exposure, alzheimers_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
alzheimers_smoke$p.value <- ifelse(alzheimers_smoke$p.value == 0,
                            alzheimers_smoke$p.value.full,
                            alzheimers_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(alzheimers_smoke[which(alzheimers_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
alzheimers_smoke <- alzheimers_smoke[!grepl("recruitment_centre", alzheimers_smoke$Exposure), ]
alzheimers_smoke <- alzheimers_smoke[!grepl("hshld_income", alzheimers_smoke$Exposure), ]
alzheimers_smoke <- alzheimers_smoke[!grepl("education_years", alzheimers_smoke$Exposure), ]
alzheimers_smoke <- alzheimers_smoke[!grepl("ethnicity", alzheimers_smoke$Exposure), ]
alzheimers_smoke <- alzheimers_smoke[!grepl("IPAQ_activity_group", alzheimers_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
alzheimers_smoke$Exposure <- gsub(".L", "", alzheimers_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
alzheimers_pa <- summary(pool_alzheimers[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(alzheimers_pa)[names(alzheimers_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
alzheimers_pa$"exp(Beta)" <- exp(alzheimers_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
alzheimers_pa$"exp(Beta)_2.5%" <- exp(alzheimers_pa$`2.5 %`)
alzheimers_pa$"exp(Beta)_97.5%" <- exp(alzheimers_pa$`97.5 %`)

# rename column for betas
names(alzheimers_pa)[names(alzheimers_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(alzheimers_pa)[names(alzheimers_pa) == "2.5 %"] <- "Beta_2.5%"
names(alzheimers_pa)[names(alzheimers_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_alzheimers[[ipaq]]$pooled$estimate / sqrt(pool_alzheimers[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_alzheimers[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_alzheimers[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
alzheimers_pa <- cbind(alzheimers_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(alzheimers_pa$Exposure, alzheimers_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
alzheimers_pa$p.value <- ifelse(alzheimers_pa$p.value == 0,
                            alzheimers_pa$p.value.full,
                            alzheimers_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(alzheimers_pa[which(alzheimers_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
alzheimers_pa <- alzheimers_pa[!grepl("recruitment_centre", alzheimers_pa$Exposure), ]
alzheimers_pa <- alzheimers_pa[!grepl("hshld_income", alzheimers_pa$Exposure), ]
alzheimers_pa <- alzheimers_pa[!grepl("education_years", alzheimers_pa$Exposure), ]
alzheimers_pa <- alzheimers_pa[!grepl("ethnicity", alzheimers_pa$Exposure), ]
alzheimers_pa <- alzheimers_pa[!grepl("smoking_status", alzheimers_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
alzheimers_pa$Exposure <- gsub(".L", "", alzheimers_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
alzheimers_covars <- summary(pool_alzheimers[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(alzheimers_covars)[names(alzheimers_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
alzheimers_covars$"exp(Beta)" <- exp(alzheimers_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
alzheimers_covars$"exp(Beta)_2.5%" <- exp(alzheimers_covars$`2.5 %`)
alzheimers_covars$"exp(Beta)_97.5%" <- exp(alzheimers_covars$`97.5 %`)

# rename column for betas
names(alzheimers_covars)[names(alzheimers_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(alzheimers_covars)[names(alzheimers_covars) == "2.5 %"] <- "Beta_2.5%"
names(alzheimers_covars)[names(alzheimers_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_alzheimers[covars][[1]]$pooled$estimate / sqrt(pool_alzheimers[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_alzheimers[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_alzheimers[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
alzheimers_covars <- cbind(alzheimers_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(alzheimers_covars$Exposure, alzheimers_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
alzheimers_covars$p.value <- ifelse(alzheimers_covars$p.value == 0,
                            alzheimers_covars$p.value.full,
                            alzheimers_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(alzheimers_covars[which(alzheimers_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
alzheimers_covars <- alzheimers_covars[!grepl("smoking_status", alzheimers_covars$Exposure), ]
alzheimers_covars <- alzheimers_covars[!grepl("IPAQ_activity_group", alzheimers_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
alzheimers_covars$Exposure <- gsub(".L", "", alzheimers_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(alzheimers_rest, alzheimers_smoke, alzheimers_pa, alzheimers_covars)

# merge with rbind
alzheimers_total <- as.data.frame(do.call(rbind, dfs))

### Categories 

## map variable names to results
alzheimers_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  alzheimers_total$Variable[alzheimers_total$Exposure %in% alzheimers_total$Exposure[substring(
    alzheimers_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
alzheimers_total <- merge(alzheimers_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
alzheimers_total$FDR <- p.adjust(alzheimers_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
alzheimers_total <- subset(alzheimers_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
alzheimers_table <- 
    subset(alzheimers_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
alzheimers_table$Significant <- 
    ifelse(alzheimers_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(alzheimers_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[20]] <- alzheimers_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_alzheimers[[1]]))

# remove disease-specific dataset for memory
rm(all_data_alzheimers)

```

# Parkinson's disease

```{r parkinsons_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$parkinsons_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_parkinsons <- NA
    x$baseline_parkinsons[baseline_ncd] <- 1
    x$baseline_parkinsons[which(x$parkinsons_baseline_dx == 1)] <- 1
    x$baseline_parkinsons[which(is.na(x$baseline_parkinsons))] <- 0
    x$baseline_parkinsons <- factor(x$baseline_parkinsons)
    
    return(x)
}

# run function in each dataset
all_data_parkinsons <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_parkinsons <- lapply(all_data_parkinsons, function(x) {
  x <- x[which(x$baseline_parkinsons == 0), ]
  return(x)
})

# print sample size for analysis (after exclusions)
cat(nrow(all_data_parkinsons[[1]]))
sample_sizes[21] <- nrow(all_data_parkinsons[[1]])


### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_parkinsons)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_parkinsons[[j]]$time <- 
        as.numeric(all_data_parkinsons[[j]]$parkinsons_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_parkinsons[[j]]$censor_age <-
        all_data_parkinsons[[j]]$recruitment_age + all_data_parkinsons[[j]]$time 
}

### Setting exposures 

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models 

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
parkinsons_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_parkinsons, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, parkinsons_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_parkinsons, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, parkinsons_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_parkinsons, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, parkinsons_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_parkinsons, function(y)
            coxph(Surv(recruitment_age, censor_age, parkinsons_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_parkinsons, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, parkinsons_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_parkinsons <- as.list(seq(1,length(exposures))) # create list to store model results
pool_parkinsons <- pblapply(exposures, parkinsons_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_parkinsons[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
parkinsons_rest <- rbindlist(smry)

# rename column for exposure
names(parkinsons_rest)[names(parkinsons_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
parkinsons_rest$"exp(Beta)" <- exp(parkinsons_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
parkinsons_rest$"exp(Beta)_2.5%" <- exp(parkinsons_rest$`2.5 %`)
parkinsons_rest$"exp(Beta)_97.5%" <- exp(parkinsons_rest$`97.5 %`)

# rename column for betas
names(parkinsons_rest)[names(parkinsons_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(parkinsons_rest)[names(parkinsons_rest) == "2.5 %"] <- "Beta_2.5%"
names(parkinsons_rest)[names(parkinsons_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_parkinsons[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_parkinsons[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_parkinsons[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_parkinsons[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_parkinsons[rest][[j]]$pooled$estimate / sqrt(pool_parkinsons[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_parkinsons[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_parkinsons[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
parkinsons_rest <- cbind(parkinsons_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(parkinsons_rest$Exposure, parkinsons_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
parkinsons_rest$p.value <- ifelse(parkinsons_rest$p.value == 0, 
                            parkinsons_rest$p.value.full,
                            parkinsons_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(parkinsons_rest[which(parkinsons_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

parkinsons_rest <- parkinsons_rest[!grepl("recruitment_centre", parkinsons_rest$Exposure), ]
parkinsons_rest <- parkinsons_rest[!grepl("hshld_income", parkinsons_rest$Exposure), ]
parkinsons_rest <- parkinsons_rest[!grepl("education_years", parkinsons_rest$Exposure), ]
parkinsons_rest <- parkinsons_rest[!grepl("ethnicity", parkinsons_rest$Exposure), ]
parkinsons_rest <- parkinsons_rest[!grepl("smoking_status", parkinsons_rest$Exposure), ]
parkinsons_rest <- parkinsons_rest[!grepl("IPAQ_activity_group", parkinsons_rest$Exposure), ]
parkinsons_rest <- parkinsons_rest[!grepl("overall_health", parkinsons_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
parkinsons_rest$Exposure <- gsub(".L", "", parkinsons_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_parkinsons[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
parkinsons_smoke <- rbindlist(smry)

# rename column for exposure
names(parkinsons_smoke)[names(parkinsons_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
parkinsons_smoke$"exp(Beta)" <- exp(parkinsons_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
parkinsons_smoke$"exp(Beta)_2.5%" <- exp(parkinsons_smoke$`2.5 %`)
parkinsons_smoke$"exp(Beta)_97.5%" <- exp(parkinsons_smoke$`97.5 %`)

# rename column for betas
names(parkinsons_smoke)[names(parkinsons_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(parkinsons_smoke)[names(parkinsons_smoke) == "2.5 %"] <- "Beta_2.5%"
names(parkinsons_smoke)[names(parkinsons_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_parkinsons[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_parkinsons[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_parkinsons[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_parkinsons[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_parkinsons[smoke][[j]]$pooled$estimate / sqrt(pool_parkinsons[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_parkinsons[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_parkinsons[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
parkinsons_smoke <- cbind(parkinsons_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(parkinsons_smoke$Exposure, parkinsons_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
parkinsons_smoke$p.value <- ifelse(parkinsons_smoke$p.value == 0,
                            parkinsons_smoke$p.value.full,
                            parkinsons_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(parkinsons_smoke[which(parkinsons_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
parkinsons_smoke <- parkinsons_smoke[!grepl("recruitment_centre", parkinsons_smoke$Exposure), ]
parkinsons_smoke <- parkinsons_smoke[!grepl("hshld_income", parkinsons_smoke$Exposure), ]
parkinsons_smoke <- parkinsons_smoke[!grepl("education_years", parkinsons_smoke$Exposure), ]
parkinsons_smoke <- parkinsons_smoke[!grepl("ethnicity", parkinsons_smoke$Exposure), ]
parkinsons_smoke <- parkinsons_smoke[!grepl("IPAQ_activity_group", parkinsons_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
parkinsons_smoke$Exposure <- gsub(".L", "", parkinsons_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
parkinsons_pa <- summary(pool_parkinsons[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(parkinsons_pa)[names(parkinsons_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
parkinsons_pa$"exp(Beta)" <- exp(parkinsons_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
parkinsons_pa$"exp(Beta)_2.5%" <- exp(parkinsons_pa$`2.5 %`)
parkinsons_pa$"exp(Beta)_97.5%" <- exp(parkinsons_pa$`97.5 %`)

# rename column for betas
names(parkinsons_pa)[names(parkinsons_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(parkinsons_pa)[names(parkinsons_pa) == "2.5 %"] <- "Beta_2.5%"
names(parkinsons_pa)[names(parkinsons_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_parkinsons[[ipaq]]$pooled$estimate / sqrt(pool_parkinsons[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_parkinsons[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_parkinsons[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
parkinsons_pa <- cbind(parkinsons_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(parkinsons_pa$Exposure, parkinsons_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
parkinsons_pa$p.value <- ifelse(parkinsons_pa$p.value == 0,
                            parkinsons_pa$p.value.full,
                            parkinsons_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(parkinsons_pa[which(parkinsons_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
parkinsons_pa <- parkinsons_pa[!grepl("recruitment_centre", parkinsons_pa$Exposure), ]
parkinsons_pa <- parkinsons_pa[!grepl("hshld_income", parkinsons_pa$Exposure), ]
parkinsons_pa <- parkinsons_pa[!grepl("education_years", parkinsons_pa$Exposure), ]
parkinsons_pa <- parkinsons_pa[!grepl("ethnicity", parkinsons_pa$Exposure), ]
parkinsons_pa <- parkinsons_pa[!grepl("smoking_status", parkinsons_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
parkinsons_pa$Exposure <- gsub(".L", "", parkinsons_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
parkinsons_covars <- summary(pool_parkinsons[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(parkinsons_covars)[names(parkinsons_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
parkinsons_covars$"exp(Beta)" <- exp(parkinsons_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
parkinsons_covars$"exp(Beta)_2.5%" <- exp(parkinsons_covars$`2.5 %`)
parkinsons_covars$"exp(Beta)_97.5%" <- exp(parkinsons_covars$`97.5 %`)

# rename column for betas
names(parkinsons_covars)[names(parkinsons_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(parkinsons_covars)[names(parkinsons_covars) == "2.5 %"] <- "Beta_2.5%"
names(parkinsons_covars)[names(parkinsons_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_parkinsons[covars][[1]]$pooled$estimate / sqrt(pool_parkinsons[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_parkinsons[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_parkinsons[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
parkinsons_covars <- cbind(parkinsons_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(parkinsons_covars$Exposure, parkinsons_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
parkinsons_covars$p.value <- ifelse(parkinsons_covars$p.value == 0,
                            parkinsons_covars$p.value.full,
                            parkinsons_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(parkinsons_covars[which(parkinsons_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
parkinsons_covars <- parkinsons_covars[!grepl("smoking_status", parkinsons_covars$Exposure), ]
parkinsons_covars <- parkinsons_covars[!grepl("IPAQ_activity_group", parkinsons_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
parkinsons_covars$Exposure <- gsub(".L", "", parkinsons_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(parkinsons_rest, parkinsons_smoke, parkinsons_pa, parkinsons_covars)

# merge with rbind
parkinsons_total <- as.data.frame(do.call(rbind, dfs))

### Categories 

## map variable names to results
parkinsons_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  parkinsons_total$Variable[parkinsons_total$Exposure %in% parkinsons_total$Exposure[substring(
    parkinsons_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
parkinsons_total <- merge(parkinsons_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
parkinsons_total$FDR <- p.adjust(parkinsons_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
parkinsons_total <- subset(parkinsons_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
parkinsons_table <- 
    subset(parkinsons_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
parkinsons_table$Significant <- 
    ifelse(parkinsons_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(parkinsons_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[21]] <- parkinsons_table

# print sample size for analysis (after exclusions)
cat(nrow(all_data_parkinsons[[1]]))

# remove disease-specific dataset for memory
rm(all_data_parkinsons)

```

# Rheumatoid arthritis

```{r rheumatoid_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$rheumatoid_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_rheumatoid <- NA
    x$baseline_rheumatoid[baseline_ncd] <- 1
    x$baseline_rheumatoid[which(x$rheumatoid_baseline_dx == 1)] <- 1
    x$baseline_rheumatoid[which(is.na(x$baseline_rheumatoid))] <- 0
    x$baseline_rheumatoid <- factor(x$baseline_rheumatoid)
    
    return(x)
}

# run function in each dataset
all_data_rheumatoid <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_rheumatoid <- lapply(all_data_rheumatoid, function(x) {
  x <- x[which(x$baseline_rheumatoid == 0), ]
  return(x)
})


# print sample size for analysis (after exclusions)
cat(nrow(all_data_rheumatoid[[1]]))
sample_sizes[22] <- nrow(all_data_rheumatoid[[1]])


### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_rheumatoid)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_rheumatoid[[j]]$time <- 
        as.numeric(all_data_rheumatoid[[j]]$rheumatoid_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_rheumatoid[[j]]$censor_age <-
        all_data_rheumatoid[[j]]$recruitment_age + all_data_rheumatoid[[j]]$time 
}

### Setting exposures 

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models 

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
rheumatoid_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_rheumatoid, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, rheumatoid_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_rheumatoid, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, rheumatoid_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_rheumatoid, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, rheumatoid_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_rheumatoid, function(y)
            coxph(Surv(recruitment_age, censor_age, rheumatoid_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_rheumatoid, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, rheumatoid_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_rheumatoid <- as.list(seq(1,length(exposures))) # create list to store model results
pool_rheumatoid <- pblapply(exposures, rheumatoid_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_rheumatoid[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
rheumatoid_rest <- rbindlist(smry)

# rename column for exposure
names(rheumatoid_rest)[names(rheumatoid_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
rheumatoid_rest$"exp(Beta)" <- exp(rheumatoid_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
rheumatoid_rest$"exp(Beta)_2.5%" <- exp(rheumatoid_rest$`2.5 %`)
rheumatoid_rest$"exp(Beta)_97.5%" <- exp(rheumatoid_rest$`97.5 %`)

# rename column for betas
names(rheumatoid_rest)[names(rheumatoid_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(rheumatoid_rest)[names(rheumatoid_rest) == "2.5 %"] <- "Beta_2.5%"
names(rheumatoid_rest)[names(rheumatoid_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_rheumatoid[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_rheumatoid[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_rheumatoid[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_rheumatoid[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_rheumatoid[rest][[j]]$pooled$estimate / sqrt(pool_rheumatoid[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_rheumatoid[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_rheumatoid[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
rheumatoid_rest <- cbind(rheumatoid_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(rheumatoid_rest$Exposure, rheumatoid_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
rheumatoid_rest$p.value <- ifelse(rheumatoid_rest$p.value == 0, 
                            rheumatoid_rest$p.value.full,
                            rheumatoid_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(rheumatoid_rest[which(rheumatoid_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

rheumatoid_rest <- rheumatoid_rest[!grepl("recruitment_centre", rheumatoid_rest$Exposure), ]
rheumatoid_rest <- rheumatoid_rest[!grepl("hshld_income", rheumatoid_rest$Exposure), ]
rheumatoid_rest <- rheumatoid_rest[!grepl("education_years", rheumatoid_rest$Exposure), ]
rheumatoid_rest <- rheumatoid_rest[!grepl("ethnicity", rheumatoid_rest$Exposure), ]
rheumatoid_rest <- rheumatoid_rest[!grepl("smoking_status", rheumatoid_rest$Exposure), ]
rheumatoid_rest <- rheumatoid_rest[!grepl("IPAQ_activity_group", rheumatoid_rest$Exposure), ]
rheumatoid_rest <- rheumatoid_rest[!grepl("overall_health", rheumatoid_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
rheumatoid_rest$Exposure <- gsub(".L", "", rheumatoid_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_rheumatoid[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
rheumatoid_smoke <- rbindlist(smry)

# rename column for exposure
names(rheumatoid_smoke)[names(rheumatoid_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
rheumatoid_smoke$"exp(Beta)" <- exp(rheumatoid_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
rheumatoid_smoke$"exp(Beta)_2.5%" <- exp(rheumatoid_smoke$`2.5 %`)
rheumatoid_smoke$"exp(Beta)_97.5%" <- exp(rheumatoid_smoke$`97.5 %`)

# rename column for betas
names(rheumatoid_smoke)[names(rheumatoid_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(rheumatoid_smoke)[names(rheumatoid_smoke) == "2.5 %"] <- "Beta_2.5%"
names(rheumatoid_smoke)[names(rheumatoid_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_rheumatoid[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_rheumatoid[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_rheumatoid[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_rheumatoid[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_rheumatoid[smoke][[j]]$pooled$estimate / sqrt(pool_rheumatoid[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_rheumatoid[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_rheumatoid[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
rheumatoid_smoke <- cbind(rheumatoid_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(rheumatoid_smoke$Exposure, rheumatoid_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
rheumatoid_smoke$p.value <- ifelse(rheumatoid_smoke$p.value == 0,
                            rheumatoid_smoke$p.value.full,
                            rheumatoid_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(rheumatoid_smoke[which(rheumatoid_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
rheumatoid_smoke <- rheumatoid_smoke[!grepl("recruitment_centre", rheumatoid_smoke$Exposure), ]
rheumatoid_smoke <- rheumatoid_smoke[!grepl("hshld_income", rheumatoid_smoke$Exposure), ]
rheumatoid_smoke <- rheumatoid_smoke[!grepl("education_years", rheumatoid_smoke$Exposure), ]
rheumatoid_smoke <- rheumatoid_smoke[!grepl("ethnicity", rheumatoid_smoke$Exposure), ]
rheumatoid_smoke <- rheumatoid_smoke[!grepl("IPAQ_activity_group", rheumatoid_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
rheumatoid_smoke$Exposure <- gsub(".L", "", rheumatoid_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
rheumatoid_pa <- summary(pool_rheumatoid[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(rheumatoid_pa)[names(rheumatoid_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
rheumatoid_pa$"exp(Beta)" <- exp(rheumatoid_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
rheumatoid_pa$"exp(Beta)_2.5%" <- exp(rheumatoid_pa$`2.5 %`)
rheumatoid_pa$"exp(Beta)_97.5%" <- exp(rheumatoid_pa$`97.5 %`)

# rename column for betas
names(rheumatoid_pa)[names(rheumatoid_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(rheumatoid_pa)[names(rheumatoid_pa) == "2.5 %"] <- "Beta_2.5%"
names(rheumatoid_pa)[names(rheumatoid_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_rheumatoid[[ipaq]]$pooled$estimate / sqrt(pool_rheumatoid[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_rheumatoid[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_rheumatoid[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
rheumatoid_pa <- cbind(rheumatoid_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(rheumatoid_pa$Exposure, rheumatoid_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
rheumatoid_pa$p.value <- ifelse(rheumatoid_pa$p.value == 0,
                            rheumatoid_pa$p.value.full,
                            rheumatoid_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(rheumatoid_pa[which(rheumatoid_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
rheumatoid_pa <- rheumatoid_pa[!grepl("recruitment_centre", rheumatoid_pa$Exposure), ]
rheumatoid_pa <- rheumatoid_pa[!grepl("hshld_income", rheumatoid_pa$Exposure), ]
rheumatoid_pa <- rheumatoid_pa[!grepl("education_years", rheumatoid_pa$Exposure), ]
rheumatoid_pa <- rheumatoid_pa[!grepl("ethnicity", rheumatoid_pa$Exposure), ]
rheumatoid_pa <- rheumatoid_pa[!grepl("smoking_status", rheumatoid_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
rheumatoid_pa$Exposure <- gsub(".L", "", rheumatoid_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
rheumatoid_covars <- summary(pool_rheumatoid[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(rheumatoid_covars)[names(rheumatoid_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
rheumatoid_covars$"exp(Beta)" <- exp(rheumatoid_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
rheumatoid_covars$"exp(Beta)_2.5%" <- exp(rheumatoid_covars$`2.5 %`)
rheumatoid_covars$"exp(Beta)_97.5%" <- exp(rheumatoid_covars$`97.5 %`)

# rename column for betas
names(rheumatoid_covars)[names(rheumatoid_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(rheumatoid_covars)[names(rheumatoid_covars) == "2.5 %"] <- "Beta_2.5%"
names(rheumatoid_covars)[names(rheumatoid_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_rheumatoid[covars][[1]]$pooled$estimate / sqrt(pool_rheumatoid[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_rheumatoid[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_rheumatoid[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
rheumatoid_covars <- cbind(rheumatoid_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(rheumatoid_covars$Exposure, rheumatoid_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
rheumatoid_covars$p.value <- ifelse(rheumatoid_covars$p.value == 0,
                            rheumatoid_covars$p.value.full,
                            rheumatoid_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(rheumatoid_covars[which(rheumatoid_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
rheumatoid_covars <- rheumatoid_covars[!grepl("smoking_status", rheumatoid_covars$Exposure), ]
rheumatoid_covars <- rheumatoid_covars[!grepl("IPAQ_activity_group", rheumatoid_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
rheumatoid_covars$Exposure <- gsub(".L", "", rheumatoid_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(rheumatoid_rest, rheumatoid_smoke, rheumatoid_pa, rheumatoid_covars)

# merge with rbind
rheumatoid_total <- as.data.frame(do.call(rbind, dfs))

### Categories 

## map variable names to results
rheumatoid_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  rheumatoid_total$Variable[rheumatoid_total$Exposure %in% rheumatoid_total$Exposure[substring(
    rheumatoid_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
rheumatoid_total <- merge(rheumatoid_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
rheumatoid_total$FDR <- p.adjust(rheumatoid_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
rheumatoid_total <- subset(rheumatoid_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
rheumatoid_table <- 
    subset(rheumatoid_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
rheumatoid_table$Significant <- 
    ifelse(rheumatoid_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(rheumatoid_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[22]] <- rheumatoid_table


# print sample size for analysis (after exclusions)
cat(nrow(all_data_rheumatoid[[1]]))

# remove disease-specific dataset for memory
rm(all_data_rheumatoid)

```

# Macular degeneration

```{r macular_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$macular_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_macular <- NA
    x$baseline_macular[baseline_ncd] <- 1
    x$baseline_macular[which(x$macular_baseline_dx == 1)] <- 1
    x$baseline_macular[which(is.na(x$baseline_macular))] <- 0
    x$baseline_macular <- factor(x$baseline_macular)
    
    return(x)
}

# run function in each dataset
all_data_macular <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_macular <- lapply(all_data_macular, function(x) {
  x <- x[which(x$baseline_macular == 0), ]
  return(x)
})


# print sample size for analysis (after exclusions)
cat(nrow(all_data_macular[[1]]))
sample_sizes[23] <- nrow(all_data_macular[[1]])


### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_macular)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_macular[[j]]$time <- 
        as.numeric(all_data_macular[[j]]$macular_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_macular[[j]]$censor_age <-
        all_data_macular[[j]]$recruitment_age + all_data_macular[[j]]$time 
}

### Setting exposures 

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models 

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
macular_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_macular, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, macular_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_macular, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, macular_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_macular, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, macular_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_macular, function(y)
            coxph(Surv(recruitment_age, censor_age, macular_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_macular, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, macular_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_macular <- as.list(seq(1,length(exposures))) # create list to store model results
pool_macular <- pblapply(exposures, macular_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_macular[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
macular_rest <- rbindlist(smry)

# rename column for exposure
names(macular_rest)[names(macular_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
macular_rest$"exp(Beta)" <- exp(macular_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
macular_rest$"exp(Beta)_2.5%" <- exp(macular_rest$`2.5 %`)
macular_rest$"exp(Beta)_97.5%" <- exp(macular_rest$`97.5 %`)

# rename column for betas
names(macular_rest)[names(macular_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(macular_rest)[names(macular_rest) == "2.5 %"] <- "Beta_2.5%"
names(macular_rest)[names(macular_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_macular[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_macular[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_macular[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_macular[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_macular[rest][[j]]$pooled$estimate / sqrt(pool_macular[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_macular[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_macular[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
macular_rest <- cbind(macular_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(macular_rest$Exposure, macular_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
macular_rest$p.value <- ifelse(macular_rest$p.value == 0, 
                            macular_rest$p.value.full,
                            macular_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(macular_rest[which(macular_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

macular_rest <- macular_rest[!grepl("recruitment_centre", macular_rest$Exposure), ]
macular_rest <- macular_rest[!grepl("hshld_income", macular_rest$Exposure), ]
macular_rest <- macular_rest[!grepl("education_years", macular_rest$Exposure), ]
macular_rest <- macular_rest[!grepl("ethnicity", macular_rest$Exposure), ]
macular_rest <- macular_rest[!grepl("smoking_status", macular_rest$Exposure), ]
macular_rest <- macular_rest[!grepl("IPAQ_activity_group", macular_rest$Exposure), ]
macular_rest <- macular_rest[!grepl("overall_health", macular_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
macular_rest$Exposure <- gsub(".L", "", macular_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_macular[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
macular_smoke <- rbindlist(smry)

# rename column for exposure
names(macular_smoke)[names(macular_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
macular_smoke$"exp(Beta)" <- exp(macular_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
macular_smoke$"exp(Beta)_2.5%" <- exp(macular_smoke$`2.5 %`)
macular_smoke$"exp(Beta)_97.5%" <- exp(macular_smoke$`97.5 %`)

# rename column for betas
names(macular_smoke)[names(macular_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(macular_smoke)[names(macular_smoke) == "2.5 %"] <- "Beta_2.5%"
names(macular_smoke)[names(macular_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_macular[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_macular[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_macular[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_macular[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_macular[smoke][[j]]$pooled$estimate / sqrt(pool_macular[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_macular[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_macular[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
macular_smoke <- cbind(macular_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(macular_smoke$Exposure, macular_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
macular_smoke$p.value <- ifelse(macular_smoke$p.value == 0,
                            macular_smoke$p.value.full,
                            macular_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(macular_smoke[which(macular_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
macular_smoke <- macular_smoke[!grepl("recruitment_centre", macular_smoke$Exposure), ]
macular_smoke <- macular_smoke[!grepl("hshld_income", macular_smoke$Exposure), ]
macular_smoke <- macular_smoke[!grepl("education_years", macular_smoke$Exposure), ]
macular_smoke <- macular_smoke[!grepl("ethnicity", macular_smoke$Exposure), ]
macular_smoke <- macular_smoke[!grepl("IPAQ_activity_group", macular_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
macular_smoke$Exposure <- gsub(".L", "", macular_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
macular_pa <- summary(pool_macular[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(macular_pa)[names(macular_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
macular_pa$"exp(Beta)" <- exp(macular_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
macular_pa$"exp(Beta)_2.5%" <- exp(macular_pa$`2.5 %`)
macular_pa$"exp(Beta)_97.5%" <- exp(macular_pa$`97.5 %`)

# rename column for betas
names(macular_pa)[names(macular_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(macular_pa)[names(macular_pa) == "2.5 %"] <- "Beta_2.5%"
names(macular_pa)[names(macular_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_macular[[ipaq]]$pooled$estimate / sqrt(pool_macular[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_macular[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_macular[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
macular_pa <- cbind(macular_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(macular_pa$Exposure, macular_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
macular_pa$p.value <- ifelse(macular_pa$p.value == 0,
                            macular_pa$p.value.full,
                            macular_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(macular_pa[which(macular_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
macular_pa <- macular_pa[!grepl("recruitment_centre", macular_pa$Exposure), ]
macular_pa <- macular_pa[!grepl("hshld_income", macular_pa$Exposure), ]
macular_pa <- macular_pa[!grepl("education_years", macular_pa$Exposure), ]
macular_pa <- macular_pa[!grepl("ethnicity", macular_pa$Exposure), ]
macular_pa <- macular_pa[!grepl("smoking_status", macular_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
macular_pa$Exposure <- gsub(".L", "", macular_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
macular_covars <- summary(pool_macular[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(macular_covars)[names(macular_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
macular_covars$"exp(Beta)" <- exp(macular_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
macular_covars$"exp(Beta)_2.5%" <- exp(macular_covars$`2.5 %`)
macular_covars$"exp(Beta)_97.5%" <- exp(macular_covars$`97.5 %`)

# rename column for betas
names(macular_covars)[names(macular_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(macular_covars)[names(macular_covars) == "2.5 %"] <- "Beta_2.5%"
names(macular_covars)[names(macular_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_macular[covars][[1]]$pooled$estimate / sqrt(pool_macular[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_macular[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_macular[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
macular_covars <- cbind(macular_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(macular_covars$Exposure, macular_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
macular_covars$p.value <- ifelse(macular_covars$p.value == 0,
                            macular_covars$p.value.full,
                            macular_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(macular_covars[which(macular_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
macular_covars <- macular_covars[!grepl("smoking_status", macular_covars$Exposure), ]
macular_covars <- macular_covars[!grepl("IPAQ_activity_group", macular_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
macular_covars$Exposure <- gsub(".L", "", macular_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(macular_rest, macular_smoke, macular_pa, macular_covars)

# merge with rbind
macular_total <- as.data.frame(do.call(rbind, dfs))

### Categories 

## map variable names to results
macular_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  macular_total$Variable[macular_total$Exposure %in% macular_total$Exposure[substring(
    macular_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
macular_total <- merge(macular_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
macular_total$FDR <- p.adjust(macular_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
macular_total <- subset(macular_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
macular_table <- 
    subset(macular_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
macular_table$Significant <- 
    ifelse(macular_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(macular_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[23]] <- macular_table


# print sample size for analysis (after exclusions)
cat(nrow(all_data_macular[[1]]))

# remove disease-specific dataset for memory
rm(all_data_macular)

```

# Osteoporosis

```{r osteoporosis_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$osteoporosis_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_osteoporosis <- NA
    x$baseline_osteoporosis[baseline_ncd] <- 1
    x$baseline_osteoporosis[which(x$osteoporosis_baseline_dx == 1)] <- 1
    x$baseline_osteoporosis[which(is.na(x$baseline_osteoporosis))] <- 0
    x$baseline_osteoporosis <- factor(x$baseline_osteoporosis)
    
    return(x)
}

# run function in each dataset
all_data_osteoporosis <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_osteoporosis <- lapply(all_data_osteoporosis, function(x) {
  x <- x[which(x$baseline_osteoporosis == 0), ]
  return(x)
})


# print sample size for analysis (after exclusions)
cat(nrow(all_data_osteoporosis[[1]]))
sample_sizes[24] <- nrow(all_data_osteoporosis[[1]])


### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_osteoporosis)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_osteoporosis[[j]]$time <- 
        as.numeric(all_data_osteoporosis[[j]]$osteoporosis_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_osteoporosis[[j]]$censor_age <-
        all_data_osteoporosis[[j]]$recruitment_age + all_data_osteoporosis[[j]]$time 
}

### Setting exposures 

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models 

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
osteoporosis_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_osteoporosis, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, osteoporosis_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_osteoporosis, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, osteoporosis_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_osteoporosis, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, osteoporosis_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_osteoporosis, function(y)
            coxph(Surv(recruitment_age, censor_age, osteoporosis_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_osteoporosis, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, osteoporosis_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_osteoporosis <- as.list(seq(1,length(exposures))) # create list to store model results
pool_osteoporosis <- pblapply(exposures, osteoporosis_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_osteoporosis[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
osteoporosis_rest <- rbindlist(smry)

# rename column for exposure
names(osteoporosis_rest)[names(osteoporosis_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
osteoporosis_rest$"exp(Beta)" <- exp(osteoporosis_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
osteoporosis_rest$"exp(Beta)_2.5%" <- exp(osteoporosis_rest$`2.5 %`)
osteoporosis_rest$"exp(Beta)_97.5%" <- exp(osteoporosis_rest$`97.5 %`)

# rename column for betas
names(osteoporosis_rest)[names(osteoporosis_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(osteoporosis_rest)[names(osteoporosis_rest) == "2.5 %"] <- "Beta_2.5%"
names(osteoporosis_rest)[names(osteoporosis_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_osteoporosis[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_osteoporosis[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_osteoporosis[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_osteoporosis[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_osteoporosis[rest][[j]]$pooled$estimate / sqrt(pool_osteoporosis[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_osteoporosis[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_osteoporosis[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
osteoporosis_rest <- cbind(osteoporosis_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(osteoporosis_rest$Exposure, osteoporosis_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
osteoporosis_rest$p.value <- ifelse(osteoporosis_rest$p.value == 0, 
                            osteoporosis_rest$p.value.full,
                            osteoporosis_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(osteoporosis_rest[which(osteoporosis_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

osteoporosis_rest <- osteoporosis_rest[!grepl("recruitment_centre", osteoporosis_rest$Exposure), ]
osteoporosis_rest <- osteoporosis_rest[!grepl("hshld_income", osteoporosis_rest$Exposure), ]
osteoporosis_rest <- osteoporosis_rest[!grepl("education_years", osteoporosis_rest$Exposure), ]
osteoporosis_rest <- osteoporosis_rest[!grepl("ethnicity", osteoporosis_rest$Exposure), ]
osteoporosis_rest <- osteoporosis_rest[!grepl("smoking_status", osteoporosis_rest$Exposure), ]
osteoporosis_rest <- osteoporosis_rest[!grepl("IPAQ_activity_group", osteoporosis_rest$Exposure), ]
osteoporosis_rest <- osteoporosis_rest[!grepl("overall_health", osteoporosis_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
osteoporosis_rest$Exposure <- gsub(".L", "", osteoporosis_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_osteoporosis[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
osteoporosis_smoke <- rbindlist(smry)

# rename column for exposure
names(osteoporosis_smoke)[names(osteoporosis_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
osteoporosis_smoke$"exp(Beta)" <- exp(osteoporosis_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
osteoporosis_smoke$"exp(Beta)_2.5%" <- exp(osteoporosis_smoke$`2.5 %`)
osteoporosis_smoke$"exp(Beta)_97.5%" <- exp(osteoporosis_smoke$`97.5 %`)

# rename column for betas
names(osteoporosis_smoke)[names(osteoporosis_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(osteoporosis_smoke)[names(osteoporosis_smoke) == "2.5 %"] <- "Beta_2.5%"
names(osteoporosis_smoke)[names(osteoporosis_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_osteoporosis[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_osteoporosis[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_osteoporosis[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_osteoporosis[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_osteoporosis[smoke][[j]]$pooled$estimate / sqrt(pool_osteoporosis[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_osteoporosis[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_osteoporosis[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
osteoporosis_smoke <- cbind(osteoporosis_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(osteoporosis_smoke$Exposure, osteoporosis_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
osteoporosis_smoke$p.value <- ifelse(osteoporosis_smoke$p.value == 0,
                            osteoporosis_smoke$p.value.full,
                            osteoporosis_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(osteoporosis_smoke[which(osteoporosis_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
osteoporosis_smoke <- osteoporosis_smoke[!grepl("recruitment_centre", osteoporosis_smoke$Exposure), ]
osteoporosis_smoke <- osteoporosis_smoke[!grepl("hshld_income", osteoporosis_smoke$Exposure), ]
osteoporosis_smoke <- osteoporosis_smoke[!grepl("education_years", osteoporosis_smoke$Exposure), ]
osteoporosis_smoke <- osteoporosis_smoke[!grepl("ethnicity", osteoporosis_smoke$Exposure), ]
osteoporosis_smoke <- osteoporosis_smoke[!grepl("IPAQ_activity_group", osteoporosis_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
osteoporosis_smoke$Exposure <- gsub(".L", "", osteoporosis_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
osteoporosis_pa <- summary(pool_osteoporosis[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(osteoporosis_pa)[names(osteoporosis_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
osteoporosis_pa$"exp(Beta)" <- exp(osteoporosis_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
osteoporosis_pa$"exp(Beta)_2.5%" <- exp(osteoporosis_pa$`2.5 %`)
osteoporosis_pa$"exp(Beta)_97.5%" <- exp(osteoporosis_pa$`97.5 %`)

# rename column for betas
names(osteoporosis_pa)[names(osteoporosis_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(osteoporosis_pa)[names(osteoporosis_pa) == "2.5 %"] <- "Beta_2.5%"
names(osteoporosis_pa)[names(osteoporosis_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_osteoporosis[[ipaq]]$pooled$estimate / sqrt(pool_osteoporosis[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_osteoporosis[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_osteoporosis[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
osteoporosis_pa <- cbind(osteoporosis_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(osteoporosis_pa$Exposure, osteoporosis_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
osteoporosis_pa$p.value <- ifelse(osteoporosis_pa$p.value == 0,
                            osteoporosis_pa$p.value.full,
                            osteoporosis_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(osteoporosis_pa[which(osteoporosis_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
osteoporosis_pa <- osteoporosis_pa[!grepl("recruitment_centre", osteoporosis_pa$Exposure), ]
osteoporosis_pa <- osteoporosis_pa[!grepl("hshld_income", osteoporosis_pa$Exposure), ]
osteoporosis_pa <- osteoporosis_pa[!grepl("education_years", osteoporosis_pa$Exposure), ]
osteoporosis_pa <- osteoporosis_pa[!grepl("ethnicity", osteoporosis_pa$Exposure), ]
osteoporosis_pa <- osteoporosis_pa[!grepl("smoking_status", osteoporosis_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
osteoporosis_pa$Exposure <- gsub(".L", "", osteoporosis_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
osteoporosis_covars <- summary(pool_osteoporosis[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(osteoporosis_covars)[names(osteoporosis_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
osteoporosis_covars$"exp(Beta)" <- exp(osteoporosis_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
osteoporosis_covars$"exp(Beta)_2.5%" <- exp(osteoporosis_covars$`2.5 %`)
osteoporosis_covars$"exp(Beta)_97.5%" <- exp(osteoporosis_covars$`97.5 %`)

# rename column for betas
names(osteoporosis_covars)[names(osteoporosis_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(osteoporosis_covars)[names(osteoporosis_covars) == "2.5 %"] <- "Beta_2.5%"
names(osteoporosis_covars)[names(osteoporosis_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_osteoporosis[covars][[1]]$pooled$estimate / sqrt(pool_osteoporosis[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_osteoporosis[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_osteoporosis[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
osteoporosis_covars <- cbind(osteoporosis_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(osteoporosis_covars$Exposure, osteoporosis_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
osteoporosis_covars$p.value <- ifelse(osteoporosis_covars$p.value == 0,
                            osteoporosis_covars$p.value.full,
                            osteoporosis_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(osteoporosis_covars[which(osteoporosis_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
osteoporosis_covars <- osteoporosis_covars[!grepl("smoking_status", osteoporosis_covars$Exposure), ]
osteoporosis_covars <- osteoporosis_covars[!grepl("IPAQ_activity_group", osteoporosis_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
osteoporosis_covars$Exposure <- gsub(".L", "", osteoporosis_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(osteoporosis_rest, osteoporosis_smoke, osteoporosis_pa, osteoporosis_covars)

# merge with rbind
osteoporosis_total <- as.data.frame(do.call(rbind, dfs))

### Categories 

## map variable names to results
osteoporosis_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  osteoporosis_total$Variable[osteoporosis_total$Exposure %in% osteoporosis_total$Exposure[substring(
    osteoporosis_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
osteoporosis_total <- merge(osteoporosis_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
osteoporosis_total$FDR <- p.adjust(osteoporosis_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
osteoporosis_total <- subset(osteoporosis_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
osteoporosis_table <- 
    subset(osteoporosis_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
osteoporosis_table$Significant <- 
    ifelse(osteoporosis_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(osteoporosis_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[24]] <- osteoporosis_table


# print sample size for analysis (after exclusions)
cat(nrow(all_data_osteoporosis[[1]]))

# remove disease-specific dataset for memory
rm(all_data_osteoporosis)

```

# Osteoarthritis

```{r osteoarthritis_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Participant exclusions 

# function to identify prevalent disease cases at baseline
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$osteoarthritis_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_osteoarthritis <- NA
    x$baseline_osteoarthritis[baseline_ncd] <- 1
    x$baseline_osteoarthritis[which(x$osteoarthritis_baseline_dx == 1)] <- 1
    x$baseline_osteoarthritis[which(is.na(x$baseline_osteoarthritis))] <- 0
    x$baseline_osteoarthritis <- factor(x$baseline_osteoarthritis)
    
    return(x)
}

# run function in each dataset
all_data_osteoarthritis <- lapply(all_data_ncd, identify_prev_cases)

# subset to those without disease at baseline
all_data_osteoarthritis <- lapply(all_data_osteoarthritis, function(x) {
  x <- x[which(x$baseline_osteoarthritis == 0), ]
  return(x)
})


# print sample size for analysis (after exclusions)
cat(nrow(all_data_osteoarthritis[[1]]))
sample_sizes[25] <- nrow(all_data_osteoarthritis[[1]])


### Survival variables 

# create age at censoring variables for age-at-risk analysis
for(j in seq_along(all_data_osteoarthritis)) {
    # divide survival time (days) by 365.25 to get time in years
    # change to numeric because survival time is a difftime object
    all_data_osteoarthritis[[j]]$time <- 
        as.numeric(all_data_osteoarthritis[[j]]$osteoarthritis_survival_time / 365.25) 
    # add time (years) to recruitment age to get censor age
    all_data_osteoarthritis[[j]]$censor_age <-
        all_data_osteoarthritis[[j]]$recruitment_age + all_data_osteoarthritis[[j]]$time 
}

### Setting exposures 

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models 

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
osteoarthritis_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_osteoarthritis, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, osteoarthritis_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_osteoarthritis, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, osteoarthritis_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status +",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_osteoarthritis, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, osteoarthritis_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_osteoarthritis, function(y)
            coxph(Surv(recruitment_age, censor_age, osteoarthritis_event) ~
                   strata(birth_cohort, sex) +
                   recruitment_centre + education_years + hshld_income + ethnicity + 
                   IPAQ_activity_group + smoking_status, 
               data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_osteoarthritis, function(y)
            coxph(as.formula(
                paste0(
                    "Surv(recruitment_age, censor_age, osteoarthritis_event) ~
                        strata(birth_cohort, sex) +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group +",
                    x
                )
            ), data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_osteoarthritis <- as.list(seq(1,length(exposures))) # create list to store model results
pool_osteoarthritis <- pblapply(exposures, osteoarthritis_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_osteoarthritis[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
osteoarthritis_rest <- rbindlist(smry)

# rename column for exposure
names(osteoarthritis_rest)[names(osteoarthritis_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
osteoarthritis_rest$"exp(Beta)" <- exp(osteoarthritis_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
osteoarthritis_rest$"exp(Beta)_2.5%" <- exp(osteoarthritis_rest$`2.5 %`)
osteoarthritis_rest$"exp(Beta)_97.5%" <- exp(osteoarthritis_rest$`97.5 %`)

# rename column for betas
names(osteoarthritis_rest)[names(osteoarthritis_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(osteoarthritis_rest)[names(osteoarthritis_rest) == "2.5 %"] <- "Beta_2.5%"
names(osteoarthritis_rest)[names(osteoarthritis_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_osteoarthritis[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_osteoarthritis[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_osteoarthritis[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_osteoarthritis[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_osteoarthritis[rest][[j]]$pooled$estimate / sqrt(pool_osteoarthritis[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_osteoarthritis[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_osteoarthritis[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
osteoarthritis_rest <- cbind(osteoarthritis_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(osteoarthritis_rest$Exposure, osteoarthritis_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
osteoarthritis_rest$p.value <- ifelse(osteoarthritis_rest$p.value == 0, 
                            osteoarthritis_rest$p.value.full,
                            osteoarthritis_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(osteoarthritis_rest[which(osteoarthritis_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

osteoarthritis_rest <- osteoarthritis_rest[!grepl("recruitment_centre", osteoarthritis_rest$Exposure), ]
osteoarthritis_rest <- osteoarthritis_rest[!grepl("hshld_income", osteoarthritis_rest$Exposure), ]
osteoarthritis_rest <- osteoarthritis_rest[!grepl("education_years", osteoarthritis_rest$Exposure), ]
osteoarthritis_rest <- osteoarthritis_rest[!grepl("ethnicity", osteoarthritis_rest$Exposure), ]
osteoarthritis_rest <- osteoarthritis_rest[!grepl("smoking_status", osteoarthritis_rest$Exposure), ]
osteoarthritis_rest <- osteoarthritis_rest[!grepl("IPAQ_activity_group", osteoarthritis_rest$Exposure), ]
osteoarthritis_rest <- osteoarthritis_rest[!grepl("overall_health", osteoarthritis_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
osteoarthritis_rest$Exposure <- gsub(".L", "", osteoarthritis_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_osteoarthritis[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
osteoarthritis_smoke <- rbindlist(smry)

# rename column for exposure
names(osteoarthritis_smoke)[names(osteoarthritis_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
osteoarthritis_smoke$"exp(Beta)" <- exp(osteoarthritis_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
osteoarthritis_smoke$"exp(Beta)_2.5%" <- exp(osteoarthritis_smoke$`2.5 %`)
osteoarthritis_smoke$"exp(Beta)_97.5%" <- exp(osteoarthritis_smoke$`97.5 %`)

# rename column for betas
names(osteoarthritis_smoke)[names(osteoarthritis_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(osteoarthritis_smoke)[names(osteoarthritis_smoke) == "2.5 %"] <- "Beta_2.5%"
names(osteoarthritis_smoke)[names(osteoarthritis_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_osteoarthritis[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_osteoarthritis[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_osteoarthritis[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_osteoarthritis[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_osteoarthritis[smoke][[j]]$pooled$estimate / sqrt(pool_osteoarthritis[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_osteoarthritis[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_osteoarthritis[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
osteoarthritis_smoke <- cbind(osteoarthritis_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(osteoarthritis_smoke$Exposure, osteoarthritis_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
osteoarthritis_smoke$p.value <- ifelse(osteoarthritis_smoke$p.value == 0,
                            osteoarthritis_smoke$p.value.full,
                            osteoarthritis_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(osteoarthritis_smoke[which(osteoarthritis_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
osteoarthritis_smoke <- osteoarthritis_smoke[!grepl("recruitment_centre", osteoarthritis_smoke$Exposure), ]
osteoarthritis_smoke <- osteoarthritis_smoke[!grepl("hshld_income", osteoarthritis_smoke$Exposure), ]
osteoarthritis_smoke <- osteoarthritis_smoke[!grepl("education_years", osteoarthritis_smoke$Exposure), ]
osteoarthritis_smoke <- osteoarthritis_smoke[!grepl("ethnicity", osteoarthritis_smoke$Exposure), ]
osteoarthritis_smoke <- osteoarthritis_smoke[!grepl("IPAQ_activity_group", osteoarthritis_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
osteoarthritis_smoke$Exposure <- gsub(".L", "", osteoarthritis_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
osteoarthritis_pa <- summary(pool_osteoarthritis[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(osteoarthritis_pa)[names(osteoarthritis_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
osteoarthritis_pa$"exp(Beta)" <- exp(osteoarthritis_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
osteoarthritis_pa$"exp(Beta)_2.5%" <- exp(osteoarthritis_pa$`2.5 %`)
osteoarthritis_pa$"exp(Beta)_97.5%" <- exp(osteoarthritis_pa$`97.5 %`)

# rename column for betas
names(osteoarthritis_pa)[names(osteoarthritis_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(osteoarthritis_pa)[names(osteoarthritis_pa) == "2.5 %"] <- "Beta_2.5%"
names(osteoarthritis_pa)[names(osteoarthritis_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_osteoarthritis[[ipaq]]$pooled$estimate / sqrt(pool_osteoarthritis[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_osteoarthritis[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_osteoarthritis[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
osteoarthritis_pa <- cbind(osteoarthritis_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(osteoarthritis_pa$Exposure, osteoarthritis_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
osteoarthritis_pa$p.value <- ifelse(osteoarthritis_pa$p.value == 0,
                            osteoarthritis_pa$p.value.full,
                            osteoarthritis_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(osteoarthritis_pa[which(osteoarthritis_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
osteoarthritis_pa <- osteoarthritis_pa[!grepl("recruitment_centre", osteoarthritis_pa$Exposure), ]
osteoarthritis_pa <- osteoarthritis_pa[!grepl("hshld_income", osteoarthritis_pa$Exposure), ]
osteoarthritis_pa <- osteoarthritis_pa[!grepl("education_years", osteoarthritis_pa$Exposure), ]
osteoarthritis_pa <- osteoarthritis_pa[!grepl("ethnicity", osteoarthritis_pa$Exposure), ]
osteoarthritis_pa <- osteoarthritis_pa[!grepl("smoking_status", osteoarthritis_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
osteoarthritis_pa$Exposure <- gsub(".L", "", osteoarthritis_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
osteoarthritis_covars <- summary(pool_osteoarthritis[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(osteoarthritis_covars)[names(osteoarthritis_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
osteoarthritis_covars$"exp(Beta)" <- exp(osteoarthritis_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
osteoarthritis_covars$"exp(Beta)_2.5%" <- exp(osteoarthritis_covars$`2.5 %`)
osteoarthritis_covars$"exp(Beta)_97.5%" <- exp(osteoarthritis_covars$`97.5 %`)

# rename column for betas
names(osteoarthritis_covars)[names(osteoarthritis_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(osteoarthritis_covars)[names(osteoarthritis_covars) == "2.5 %"] <- "Beta_2.5%"
names(osteoarthritis_covars)[names(osteoarthritis_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_osteoarthritis[covars][[1]]$pooled$estimate / sqrt(pool_osteoarthritis[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_osteoarthritis[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_osteoarthritis[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
osteoarthritis_covars <- cbind(osteoarthritis_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(osteoarthritis_covars$Exposure, osteoarthritis_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
osteoarthritis_covars$p.value <- ifelse(osteoarthritis_covars$p.value == 0,
                            osteoarthritis_covars$p.value.full,
                            osteoarthritis_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(osteoarthritis_covars[which(osteoarthritis_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
osteoarthritis_covars <- osteoarthritis_covars[!grepl("smoking_status", osteoarthritis_covars$Exposure), ]
osteoarthritis_covars <- osteoarthritis_covars[!grepl("IPAQ_activity_group", osteoarthritis_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
osteoarthritis_covars$Exposure <- gsub(".L", "", osteoarthritis_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(osteoarthritis_rest, osteoarthritis_smoke, osteoarthritis_pa, osteoarthritis_covars)

# merge with rbind
osteoarthritis_total <- as.data.frame(do.call(rbind, dfs))

### Categories 

## map variable names to results
osteoarthritis_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  osteoarthritis_total$Variable[osteoarthritis_total$Exposure %in% osteoarthritis_total$Exposure[substring(
    osteoarthritis_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
osteoarthritis_total <- merge(osteoarthritis_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
osteoarthritis_total$FDR <- p.adjust(osteoarthritis_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
osteoarthritis_total <- subset(osteoarthritis_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "exp(Beta)",
                                "exp(Beta)_2.5%",
                                "exp(Beta)_97.5%",
                                "p.value",
                                "FDR",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

### output results
options(scipen = 999)
# subset results to columns for table
osteoarthritis_table <- 
    subset(osteoarthritis_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
osteoarthritis_table$Significant <- 
    ifelse(osteoarthritis_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(osteoarthritis_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[25]] <- osteoarthritis_table


# print sample size for analysis (after exclusions)
cat(nrow(all_data_osteoarthritis[[1]]))

# remove disease-specific dataset for memory
rm(all_data_osteoarthritis)

```

# Hypertension

```{r cs_hypertension_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

# create prevalent hypertension variable
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$hypertension_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_hypertension <- NA
    x$baseline_hypertension[baseline_ncd] <- 1
    x$baseline_hypertension[which(x$hypertension_baseline_dx == 1)] <- 1
    x$baseline_hypertension[which(x$high_blood_pressure_diagnosis == "Yes")] <- 1
    x$baseline_hypertension[which(x$blood_pressure_meds == "Yes")] <- 1
    # x$baseline_hypertension[which((x$systolic_bp/x$diastolic_bp) >= 140/90)] <- 1
    x$baseline_hypertension[which(is.na(x$baseline_hypertension))] <- 0
    x$baseline_hypertension <- factor(x$baseline_hypertension)
    x$baseline_hypertension <- relevel(x$baseline_hypertension, ref = "0")
    
    return(x)
}

# run function in each dataset
all_data_ncd <- lapply(all_data_ncd, identify_prev_cases)

# print sample size for analysis (after exclusions)
sample_sizes[26] <- nrow(all_data_ncd[[1]])


### Setting exposures 

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models 

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
hypertension_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_ncd, function(y)
            glm(as.formula(
                paste0(
                    "baseline_hypertension ~
                        recruitment_age + sex +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group + ",
                    x
                )
            ), family = "binomial", data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_ncd, function(y)
            glm(as.formula(
                paste0(
                    "baseline_hypertension ~
                        recruitment_age + sex +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + ",
                    x
                )
            ), family = "binomial", data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_ncd, function(y)
            glm(as.formula(
                paste0(
                    "baseline_hypertension ~
                        recruitment_age + sex +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), family = "binomial", data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_ncd, function(y)
            glm(baseline_hypertension ~
                    recruitment_age + sex +
                    recruitment_centre + education_years + hshld_income + ethnicity +
                    IPAQ_activity_group + smoking_status, 
                family = "binomial",
                data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_ncd, function(y)
            glm(as.formula(
                paste0(
                    "baseline_hypertension ~
                        recruitment_age + sex +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + ",
                    x
                )
            ), family = "binomial", data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_hypertension <- as.list(seq(1,length(exposures))) # create list to store model results
pool_hypertension <- pblapply(exposures, hypertension_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_hypertension[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
hypertension_rest <- rbindlist(smry)

# rename column for exposure
names(hypertension_rest)[names(hypertension_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
hypertension_rest$"exp(Beta)" <- exp(hypertension_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
hypertension_rest$"exp(Beta)_2.5%" <- exp(hypertension_rest$`2.5 %`)
hypertension_rest$"exp(Beta)_97.5%" <- exp(hypertension_rest$`97.5 %`)

# rename column for betas
names(hypertension_rest)[names(hypertension_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(hypertension_rest)[names(hypertension_rest) == "2.5 %"] <- "Beta_2.5%"
names(hypertension_rest)[names(hypertension_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_hypertension[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_hypertension[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_hypertension[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_hypertension[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_hypertension[rest][[j]]$pooled$estimate / sqrt(pool_hypertension[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_hypertension[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_hypertension[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
hypertension_rest <- cbind(hypertension_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(hypertension_rest$Exposure, hypertension_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
hypertension_rest$p.value <- ifelse(hypertension_rest$p.value == 0, 
                            hypertension_rest$p.value.full,
                            hypertension_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(hypertension_rest[which(hypertension_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

hypertension_rest <- hypertension_rest[!grepl("recruitment_age", hypertension_rest$Exposure), ]
hypertension_rest <- hypertension_rest[!grepl("sexMale", hypertension_rest$Exposure), ]
hypertension_rest <- hypertension_rest[!grepl("recruitment_centre", hypertension_rest$Exposure), ]
hypertension_rest <- hypertension_rest[!grepl("hshld_income", hypertension_rest$Exposure), ]
hypertension_rest <- hypertension_rest[!grepl("education_years", hypertension_rest$Exposure), ]
hypertension_rest <- hypertension_rest[!grepl("ethnicity", hypertension_rest$Exposure), ]
hypertension_rest <- hypertension_rest[!grepl("smoking_status", hypertension_rest$Exposure), ]
hypertension_rest <- hypertension_rest[!grepl("IPAQ_activity_group", hypertension_rest$Exposure), ]
hypertension_rest <- hypertension_rest[!grepl("overall_health", hypertension_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
hypertension_rest$Exposure <- gsub(".L", "", hypertension_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_hypertension[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
hypertension_smoke <- rbindlist(smry)

# rename column for exposure
names(hypertension_smoke)[names(hypertension_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
hypertension_smoke$"exp(Beta)" <- exp(hypertension_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
hypertension_smoke$"exp(Beta)_2.5%" <- exp(hypertension_smoke$`2.5 %`)
hypertension_smoke$"exp(Beta)_97.5%" <- exp(hypertension_smoke$`97.5 %`)

# rename column for betas
names(hypertension_smoke)[names(hypertension_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(hypertension_smoke)[names(hypertension_smoke) == "2.5 %"] <- "Beta_2.5%"
names(hypertension_smoke)[names(hypertension_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_hypertension[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_hypertension[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_hypertension[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_hypertension[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_hypertension[smoke][[j]]$pooled$estimate / sqrt(pool_hypertension[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_hypertension[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_hypertension[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
hypertension_smoke <- cbind(hypertension_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(hypertension_smoke$Exposure, hypertension_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
hypertension_smoke$p.value <- ifelse(hypertension_smoke$p.value == 0,
                            hypertension_smoke$p.value.full,
                            hypertension_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(hypertension_smoke[which(hypertension_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
hypertension_smoke <- hypertension_smoke[!grepl("recruitment_age", hypertension_smoke$Exposure), ]
hypertension_smoke <- hypertension_smoke[!grepl("sexMale", hypertension_smoke$Exposure), ]
hypertension_smoke <- hypertension_smoke[!grepl("recruitment_centre", hypertension_smoke$Exposure), ]
hypertension_smoke <- hypertension_smoke[!grepl("hshld_income", hypertension_smoke$Exposure), ]
hypertension_smoke <- hypertension_smoke[!grepl("education_years", hypertension_smoke$Exposure), ]
hypertension_smoke <- hypertension_smoke[!grepl("ethnicity", hypertension_smoke$Exposure), ]
hypertension_smoke <- hypertension_smoke[!grepl("IPAQ_activity_group", hypertension_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
hypertension_smoke$Exposure <- gsub(".L", "", hypertension_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
hypertension_pa <- summary(pool_hypertension[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(hypertension_pa)[names(hypertension_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
hypertension_pa$"exp(Beta)" <- exp(hypertension_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
hypertension_pa$"exp(Beta)_2.5%" <- exp(hypertension_pa$`2.5 %`)
hypertension_pa$"exp(Beta)_97.5%" <- exp(hypertension_pa$`97.5 %`)

# rename column for betas
names(hypertension_pa)[names(hypertension_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(hypertension_pa)[names(hypertension_pa) == "2.5 %"] <- "Beta_2.5%"
names(hypertension_pa)[names(hypertension_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_hypertension[[ipaq]]$pooled$estimate / sqrt(pool_hypertension[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_hypertension[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_hypertension[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
hypertension_pa <- cbind(hypertension_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(hypertension_pa$Exposure, hypertension_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
hypertension_pa$p.value <- ifelse(hypertension_pa$p.value == 0,
                            hypertension_pa$p.value.full,
                            hypertension_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(hypertension_pa[which(hypertension_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
hypertension_pa <- hypertension_pa[!grepl("recruitment_age", hypertension_pa$Exposure), ]
hypertension_pa <- hypertension_pa[!grepl("sexMale", hypertension_pa$Exposure), ]
hypertension_pa <- hypertension_pa[!grepl("recruitment_centre", hypertension_pa$Exposure), ]
hypertension_pa <- hypertension_pa[!grepl("hshld_income", hypertension_pa$Exposure), ]
hypertension_pa <- hypertension_pa[!grepl("education_years", hypertension_pa$Exposure), ]
hypertension_pa <- hypertension_pa[!grepl("ethnicity", hypertension_pa$Exposure), ]
hypertension_pa <- hypertension_pa[!grepl("smoking_status", hypertension_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
hypertension_pa$Exposure <- gsub(".L", "", hypertension_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
hypertension_covars <- summary(pool_hypertension[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(hypertension_covars)[names(hypertension_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
hypertension_covars$"exp(Beta)" <- exp(hypertension_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
hypertension_covars$"exp(Beta)_2.5%" <- exp(hypertension_covars$`2.5 %`)
hypertension_covars$"exp(Beta)_97.5%" <- exp(hypertension_covars$`97.5 %`)

# rename column for betas
names(hypertension_covars)[names(hypertension_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(hypertension_covars)[names(hypertension_covars) == "2.5 %"] <- "Beta_2.5%"
names(hypertension_covars)[names(hypertension_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_hypertension[covars][[1]]$pooled$estimate / sqrt(pool_hypertension[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_hypertension[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_hypertension[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
hypertension_covars <- cbind(hypertension_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(hypertension_covars$Exposure, hypertension_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
hypertension_covars$p.value <- ifelse(hypertension_covars$p.value == 0,
                            hypertension_covars$p.value.full,
                            hypertension_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(hypertension_covars[which(hypertension_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
hypertension_covars <- hypertension_covars[!grepl("recruitment_age", hypertension_covars$Exposure), ]
hypertension_covars <- hypertension_covars[!grepl("sexMale", hypertension_covars$Exposure), ]
hypertension_covars <- hypertension_covars[!grepl("smoking_status", hypertension_covars$Exposure), ]
hypertension_covars <- hypertension_covars[!grepl("IPAQ_activity_group", hypertension_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
hypertension_covars$Exposure <- gsub(".L", "", hypertension_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(hypertension_rest, hypertension_smoke, hypertension_pa, hypertension_covars)

# merge with rbind
hypertension_total <- as.data.frame(do.call(rbind, dfs))

### Categories 

## map variable names to results
hypertension_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  hypertension_total$Variable[hypertension_total$Exposure %in% hypertension_total$Exposure[substring(
    hypertension_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
hypertension_total <- merge(hypertension_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
hypertension_total$FDR <- p.adjust(hypertension_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
cs_hypertension_total <- subset(hypertension_total,
                           select = c("Exposure",
                                      "Beta",
                                      "Beta_2.5%",
                                      "Beta_97.5%",
                                      "exp(Beta)",
                                      "exp(Beta)_2.5%",
                                      "exp(Beta)_97.5%",
                                      "p.value",
                                      "FDR",
                                      "std.error",
                                      "statistic",
                                      "df",
                                      "Variable",
                                      "Category"
                           ))

### output results
options(scipen = 999)
# subset results to columns for table
cs_hypertension_table <- 
    subset(hypertension_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
cs_hypertension_table$Significant <- 
    ifelse(cs_hypertension_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(cs_hypertension_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Odds Ratio",
      "OR 2.5% CI",
      "OR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[26]] <- cs_hypertension_table
```

# Obesity

```{r cs_obesity_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

# create prevalent obesity variable
for (k in seq_along(all_data_ncd)) {
    all_data_ncd[[k]]$prev_obesity <-
        ifelse(all_data_ncd[[k]]$BMI >= 30, 1, 0)
    
    all_data_ncd[[k]]$prev_obesity <- factor(all_data_ncd[[k]]$prev_obesity,
                                             ordered = FALSE)
    
    all_data_ncd[[k]]$prev_obesity <- relevel(all_data_ncd[[k]]$prev_obesity,
                                              ref = "0")
}

# print sample size for analysis (after exclusions)
sample_sizes[27] <- nrow(all_data_ncd[[1]])

### Setting exposures 

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models 

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
obesity_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_ncd, function(y)
            glm(as.formula(
                paste0(
                    "prev_obesity ~
                        recruitment_age + sex +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group + ",
                    x
                )
            ), family = "binomial", data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_ncd, function(y)
            glm(as.formula(
                paste0(
                    "prev_obesity ~
                        recruitment_age + sex +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + ",
                    x
                )
            ), family = "binomial", data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_ncd, function(y)
            glm(as.formula(
                paste0(
                    "prev_obesity ~
                        recruitment_age + sex +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), family = "binomial", data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_ncd, function(y)
            glm(prev_obesity ~
                    recruitment_age + sex +
                    recruitment_centre + education_years + hshld_income + ethnicity +
                    IPAQ_activity_group + smoking_status, 
                family = "binomial",
                data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_ncd, function(y)
            glm(as.formula(
                paste0(
                    "prev_obesity ~
                        recruitment_age + sex +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + ",
                    x
                )
            ), family = "binomial", data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_obesity <- as.list(seq(1,length(exposures))) # create list to store model results
pool_obesity <- pblapply(exposures, obesity_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_obesity[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
obesity_rest <- rbindlist(smry)

# rename column for exposure
names(obesity_rest)[names(obesity_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
obesity_rest$"exp(Beta)" <- exp(obesity_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
obesity_rest$"exp(Beta)_2.5%" <- exp(obesity_rest$`2.5 %`)
obesity_rest$"exp(Beta)_97.5%" <- exp(obesity_rest$`97.5 %`)

# rename column for betas
names(obesity_rest)[names(obesity_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(obesity_rest)[names(obesity_rest) == "2.5 %"] <- "Beta_2.5%"
names(obesity_rest)[names(obesity_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_obesity[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_obesity[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_obesity[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_obesity[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_obesity[rest][[j]]$pooled$estimate / sqrt(pool_obesity[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_obesity[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_obesity[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
obesity_rest <- cbind(obesity_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(obesity_rest$Exposure, obesity_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
obesity_rest$p.value <- ifelse(obesity_rest$p.value == 0, 
                            obesity_rest$p.value.full,
                            obesity_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(obesity_rest[which(obesity_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

obesity_rest <- obesity_rest[!grepl("recruitment_age", obesity_rest$Exposure), ]
obesity_rest <- obesity_rest[!grepl("sexMale", obesity_rest$Exposure), ]
obesity_rest <- obesity_rest[!grepl("recruitment_centre", obesity_rest$Exposure), ]
obesity_rest <- obesity_rest[!grepl("hshld_income", obesity_rest$Exposure), ]
obesity_rest <- obesity_rest[!grepl("education_years", obesity_rest$Exposure), ]
obesity_rest <- obesity_rest[!grepl("ethnicity", obesity_rest$Exposure), ]
obesity_rest <- obesity_rest[!grepl("smoking_status", obesity_rest$Exposure), ]
obesity_rest <- obesity_rest[!grepl("IPAQ_activity_group", obesity_rest$Exposure), ]
obesity_rest <- obesity_rest[!grepl("overall_health", obesity_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
obesity_rest$Exposure <- gsub(".L", "", obesity_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_obesity[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
obesity_smoke <- rbindlist(smry)

# rename column for exposure
names(obesity_smoke)[names(obesity_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
obesity_smoke$"exp(Beta)" <- exp(obesity_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
obesity_smoke$"exp(Beta)_2.5%" <- exp(obesity_smoke$`2.5 %`)
obesity_smoke$"exp(Beta)_97.5%" <- exp(obesity_smoke$`97.5 %`)

# rename column for betas
names(obesity_smoke)[names(obesity_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(obesity_smoke)[names(obesity_smoke) == "2.5 %"] <- "Beta_2.5%"
names(obesity_smoke)[names(obesity_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_obesity[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_obesity[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_obesity[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_obesity[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_obesity[smoke][[j]]$pooled$estimate / sqrt(pool_obesity[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_obesity[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_obesity[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
obesity_smoke <- cbind(obesity_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(obesity_smoke$Exposure, obesity_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
obesity_smoke$p.value <- ifelse(obesity_smoke$p.value == 0,
                            obesity_smoke$p.value.full,
                            obesity_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(obesity_smoke[which(obesity_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
obesity_smoke <- obesity_smoke[!grepl("recruitment_age", obesity_smoke$Exposure), ]
obesity_smoke <- obesity_smoke[!grepl("sexMale", obesity_smoke$Exposure), ]
obesity_smoke <- obesity_smoke[!grepl("recruitment_centre", obesity_smoke$Exposure), ]
obesity_smoke <- obesity_smoke[!grepl("hshld_income", obesity_smoke$Exposure), ]
obesity_smoke <- obesity_smoke[!grepl("education_years", obesity_smoke$Exposure), ]
obesity_smoke <- obesity_smoke[!grepl("ethnicity", obesity_smoke$Exposure), ]
obesity_smoke <- obesity_smoke[!grepl("IPAQ_activity_group", obesity_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
obesity_smoke$Exposure <- gsub(".L", "", obesity_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
obesity_pa <- summary(pool_obesity[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(obesity_pa)[names(obesity_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
obesity_pa$"exp(Beta)" <- exp(obesity_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
obesity_pa$"exp(Beta)_2.5%" <- exp(obesity_pa$`2.5 %`)
obesity_pa$"exp(Beta)_97.5%" <- exp(obesity_pa$`97.5 %`)

# rename column for betas
names(obesity_pa)[names(obesity_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(obesity_pa)[names(obesity_pa) == "2.5 %"] <- "Beta_2.5%"
names(obesity_pa)[names(obesity_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_obesity[[ipaq]]$pooled$estimate / sqrt(pool_obesity[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_obesity[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_obesity[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
obesity_pa <- cbind(obesity_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(obesity_pa$Exposure, obesity_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
obesity_pa$p.value <- ifelse(obesity_pa$p.value == 0,
                            obesity_pa$p.value.full,
                            obesity_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(obesity_pa[which(obesity_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
obesity_pa <- obesity_pa[!grepl("recruitment_age", obesity_pa$Exposure), ]
obesity_pa <- obesity_pa[!grepl("sexMale", obesity_pa$Exposure), ]
obesity_pa <- obesity_pa[!grepl("recruitment_centre", obesity_pa$Exposure), ]
obesity_pa <- obesity_pa[!grepl("hshld_income", obesity_pa$Exposure), ]
obesity_pa <- obesity_pa[!grepl("education_years", obesity_pa$Exposure), ]
obesity_pa <- obesity_pa[!grepl("ethnicity", obesity_pa$Exposure), ]
obesity_pa <- obesity_pa[!grepl("smoking_status", obesity_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
obesity_pa$Exposure <- gsub(".L", "", obesity_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
obesity_covars <- summary(pool_obesity[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(obesity_covars)[names(obesity_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
obesity_covars$"exp(Beta)" <- exp(obesity_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
obesity_covars$"exp(Beta)_2.5%" <- exp(obesity_covars$`2.5 %`)
obesity_covars$"exp(Beta)_97.5%" <- exp(obesity_covars$`97.5 %`)

# rename column for betas
names(obesity_covars)[names(obesity_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(obesity_covars)[names(obesity_covars) == "2.5 %"] <- "Beta_2.5%"
names(obesity_covars)[names(obesity_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_obesity[covars][[1]]$pooled$estimate / sqrt(pool_obesity[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_obesity[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_obesity[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
obesity_covars <- cbind(obesity_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(obesity_covars$Exposure, obesity_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
obesity_covars$p.value <- ifelse(obesity_covars$p.value == 0,
                            obesity_covars$p.value.full,
                            obesity_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(obesity_covars[which(obesity_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
obesity_covars <- obesity_covars[!grepl("recruitment_age", obesity_covars$Exposure), ]
obesity_covars <- obesity_covars[!grepl("sexMale", obesity_covars$Exposure), ]
obesity_covars <- obesity_covars[!grepl("smoking_status", obesity_covars$Exposure), ]
obesity_covars <- obesity_covars[!grepl("IPAQ_activity_group", obesity_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
obesity_covars$Exposure <- gsub(".L", "", obesity_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(obesity_rest, obesity_smoke, obesity_pa, obesity_covars)

# merge with rbind
obesity_total <- as.data.frame(do.call(rbind, dfs))

### Categories 

## map variable names to results
obesity_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  obesity_total$Variable[obesity_total$Exposure %in% obesity_total$Exposure[substring(
    obesity_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
obesity_total <- merge(obesity_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
obesity_total$FDR <- p.adjust(obesity_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
cs_obesity_total <- subset(obesity_total,
                           select = c("Exposure",
                                      "Beta",
                                      "Beta_2.5%",
                                      "Beta_97.5%",
                                      "exp(Beta)",
                                      "exp(Beta)_2.5%",
                                      "exp(Beta)_97.5%",
                                      "p.value",
                                      "FDR",
                                      "std.error",
                                      "statistic",
                                      "df",
                                      "Variable",
                                      "Category"
                           ))

### output results
options(scipen = 999)
# subset results to columns for table
cs_obesity_table <- 
    subset(obesity_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
cs_obesity_table$Significant <- 
    ifelse(cs_obesity_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(cs_obesity_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[27]] <- cs_obesity_table

```

# Dyslipidemia

```{r cs_dyslipidemia_analysis}

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

# create prevalent dyslipidemia variable
identify_prev_cases <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$dyslipidemia_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_dyslipidemia <- NA
    x$baseline_dyslipidemia[baseline_ncd] <- 1
    x$baseline_dyslipidemia[which(x$cholesterol_meds == "Yes")] <- 1
    x$baseline_dyslipidemia[which(x$cholesterol >= (240 / 38.67))] <- 1
    x$baseline_dyslipidemia[which(x$LDL_direct >= (160 / 38.67))] <- 1
    x$baseline_dyslipidemia[which(x$HDL_cholesterol < (40 / 38.67))] <- 1
    x$baseline_dyslipidemia[which(x$triglycerides >= (200 / 88.57))] <- 1
    x$baseline_dyslipidemia[which(is.na(x$baseline_dyslipidemia))] <- 0
    x$baseline_dyslipidemia <- factor(x$baseline_dyslipidemia)
    x$baseline_dyslipidemia <- relevel(x$baseline_dyslipidemia, ref = "0")
    
    return(x)
}

# run function in each dataset
all_data_ncd <- lapply(all_data_ncd, identify_prev_cases)

# print sample size for analysis (after exclusions)
sample_sizes[28] <- nrow(all_data_ncd[[1]])

### Setting exposures 

# load list of vars significant in cluster multivariate analyses
exposures <- read.csv(paste0(path, "/output/full cohort/cluster multivariate/total_sig_vars_list_nov_07_2022_all_sexes.csv"))
exposures <- as.vector(unlist(exposures[1]))


# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# make final vector of exposures ordered by category
exposures <- as.vector(summary$exposures)

### Run models 

# list of XWAS covars
covar_list <- c("recruitment_centre", "education_years", "hshld_income", "ethnicity")

## function
dyslipidemia_model <- function(x) {
    
    if (x %in% c("smoking_status", "pack_years_prop")) {
  
        models <- lapply(all_data_ncd, function(y)
            glm(as.formula(
                paste0(
                    "baseline_dyslipidemia ~
                        recruitment_age + sex +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        IPAQ_activity_group + ",
                    x
                )
            ), family = "binomial", data = y)
        )
        
    }
    
    else if (x == "IPAQ_activity_group") {
    
        models <- lapply(all_data_ncd, function(y)
            glm(as.formula(
                paste0(
                    "baseline_dyslipidemia ~
                        recruitment_age + sex +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + ",
                    x
                )
            ), family = "binomial", data = y)
        )
    }
    
    else if (x == "alcohol_freq") {
    
        models <- lapply(all_data_ncd, function(y)
            glm(as.formula(
                paste0(
                    "baseline_dyslipidemia ~
                        recruitment_age + sex +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + overall_health + ",
                    x
                )
            ), family = "binomial", data = y)
        )
    }
    
    else if (x %in% covar_list) {
        
        models <- lapply(all_data_ncd, function(y)
            glm(baseline_dyslipidemia ~
                    recruitment_age + sex +
                    recruitment_centre + education_years + hshld_income + ethnicity +
                    IPAQ_activity_group + smoking_status, 
                family = "binomial",
                data = y)
        )
    }
    
    else {
        
        models <- lapply(all_data_ncd, function(y)
            glm(as.formula(
                paste0(
                    "baseline_dyslipidemia ~
                        recruitment_age + sex +
                        recruitment_centre + education_years + hshld_income + ethnicity + 
                        smoking_status + IPAQ_activity_group + ",
                    x
                )
            ), family = "binomial", data = y)
        )
    }
    
    pool <- pool(models)
    rm(models)
    return(pool)
}


## run models
pool_dyslipidemia <- as.list(seq(1,length(exposures))) # create list to store model results
pool_dyslipidemia <- pblapply(exposures, dyslipidemia_model, cl = cores)

### Summaries 

covars <- which(exposures %in% covar_list)
smoke <- which(exposures %in% c("smoking_status", "pack_years_prop"))
ipaq <- which(exposures == "IPAQ_activity_group")
rest <- which(exposures %nin% c(covar_list, 
                                "smoking_status", 
                                "pack_years_prop", 
                                "IPAQ_activity_group"))

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_dyslipidemia[rest],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
dyslipidemia_rest <- rbindlist(smry)

# rename column for exposure
names(dyslipidemia_rest)[names(dyslipidemia_rest) == "term"] <- "Exposure"

# calculate Hazard Ratio
dyslipidemia_rest$"exp(Beta)" <- exp(dyslipidemia_rest$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
dyslipidemia_rest$"exp(Beta)_2.5%" <- exp(dyslipidemia_rest$`2.5 %`)
dyslipidemia_rest$"exp(Beta)_97.5%" <- exp(dyslipidemia_rest$`97.5 %`)

# rename column for betas
names(dyslipidemia_rest)[names(dyslipidemia_rest) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(dyslipidemia_rest)[names(dyslipidemia_rest) == "2.5 %"] <- "Beta_2.5%"
names(dyslipidemia_rest)[names(dyslipidemia_rest) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_dyslipidemia[rest]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_dyslipidemia[rest]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_dyslipidemia[rest]))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_dyslipidemia[rest])) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_dyslipidemia[rest][[j]]$pooled$estimate / sqrt(pool_dyslipidemia[rest][[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_dyslipidemia[rest][[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_dyslipidemia[rest][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
dyslipidemia_rest <- cbind(dyslipidemia_rest, p_table)

# test to make sure the rows didn't get mixed up
all.equal(dyslipidemia_rest$Exposure, dyslipidemia_rest$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
dyslipidemia_rest$p.value <- ifelse(dyslipidemia_rest$p.value == 0, 
                            dyslipidemia_rest$p.value.full,
                            dyslipidemia_rest$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(dyslipidemia_rest[which(dyslipidemia_rest$p.value == 0), ]))
      

### Remove covariate estimates 

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

dyslipidemia_rest <- dyslipidemia_rest[!grepl("recruitment_age", dyslipidemia_rest$Exposure), ]
dyslipidemia_rest <- dyslipidemia_rest[!grepl("sexMale", dyslipidemia_rest$Exposure), ]
dyslipidemia_rest <- dyslipidemia_rest[!grepl("recruitment_centre", dyslipidemia_rest$Exposure), ]
dyslipidemia_rest <- dyslipidemia_rest[!grepl("hshld_income", dyslipidemia_rest$Exposure), ]
dyslipidemia_rest <- dyslipidemia_rest[!grepl("education_years", dyslipidemia_rest$Exposure), ]
dyslipidemia_rest <- dyslipidemia_rest[!grepl("ethnicity", dyslipidemia_rest$Exposure), ]
dyslipidemia_rest <- dyslipidemia_rest[!grepl("smoking_status", dyslipidemia_rest$Exposure), ]
dyslipidemia_rest <- dyslipidemia_rest[!grepl("IPAQ_activity_group", dyslipidemia_rest$Exposure), ]
dyslipidemia_rest <- dyslipidemia_rest[!grepl("overall_health", dyslipidemia_rest$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
dyslipidemia_rest$Exposure <- gsub(".L", "", dyslipidemia_rest$Exposure, fixed = TRUE)

### smoking

# get list of summaries for all pooled models (minus 3 above that overlap with covariates)
smry <- lapply(pool_dyslipidemia[smoke],
               summary,
               conf.int = TRUE,
               conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
dyslipidemia_smoke <- rbindlist(smry)

# rename column for exposure
names(dyslipidemia_smoke)[names(dyslipidemia_smoke) == "term"] <- "Exposure"

# calculate Hazard Ratio
dyslipidemia_smoke$"exp(Beta)" <- exp(dyslipidemia_smoke$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
dyslipidemia_smoke$"exp(Beta)_2.5%" <- exp(dyslipidemia_smoke$`2.5 %`)
dyslipidemia_smoke$"exp(Beta)_97.5%" <- exp(dyslipidemia_smoke$`97.5 %`)

# rename column for betas
names(dyslipidemia_smoke)[names(dyslipidemia_smoke) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(dyslipidemia_smoke)[names(dyslipidemia_smoke) == "2.5 %"] <- "Beta_2.5%"
names(dyslipidemia_smoke)[names(dyslipidemia_smoke) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery
tstat <- as.list(seq(1,length(pool_dyslipidemia[smoke]))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_dyslipidemia[smoke]))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_dyslipidemia[smoke]))) # create list to p table dfs

# loop to calculate p-values and create table of results
for (j in seq_along(pool_dyslipidemia[smoke])) {
    # t statistic test using pooled estimate and pooled variance (t)
    tstat[[j]] <- pool_dyslipidemia[smoke][[j]]$pooled$estimate / sqrt(pool_dyslipidemia[smoke][[j]]$pooled$t)
    # calculate p-values
    p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_dyslipidemia[smoke][[j]]$pooled$df))
    # create df in p table
    p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
    # fill in p table
    p_table[[j]]$X2 <- p.val[[j]][[1]]
    # add in variable names
    p_table[[j]]$X1 <- pool_dyslipidemia[smoke][[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
dyslipidemia_smoke <- cbind(dyslipidemia_smoke, p_table)

# test to make sure the rows didn't get mixed up
all.equal(dyslipidemia_smoke$Exposure, dyslipidemia_smoke$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
dyslipidemia_smoke$p.value <- ifelse(dyslipidemia_smoke$p.value == 0,
                            dyslipidemia_smoke$p.value.full,
                            dyslipidemia_smoke$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(dyslipidemia_smoke[which(dyslipidemia_smoke$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
dyslipidemia_smoke <- dyslipidemia_smoke[!grepl("recruitment_age", dyslipidemia_smoke$Exposure), ]
dyslipidemia_smoke <- dyslipidemia_smoke[!grepl("sexMale", dyslipidemia_smoke$Exposure), ]
dyslipidemia_smoke <- dyslipidemia_smoke[!grepl("recruitment_centre", dyslipidemia_smoke$Exposure), ]
dyslipidemia_smoke <- dyslipidemia_smoke[!grepl("hshld_income", dyslipidemia_smoke$Exposure), ]
dyslipidemia_smoke <- dyslipidemia_smoke[!grepl("education_years", dyslipidemia_smoke$Exposure), ]
dyslipidemia_smoke <- dyslipidemia_smoke[!grepl("ethnicity", dyslipidemia_smoke$Exposure), ]
dyslipidemia_smoke <- dyslipidemia_smoke[!grepl("IPAQ_activity_group", dyslipidemia_smoke$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
dyslipidemia_smoke$Exposure <- gsub(".L", "", dyslipidemia_smoke$Exposure, fixed = TRUE)

### physical activity

# extract all model summaries from the lists and convert to single data frame of estimates
dyslipidemia_pa <- summary(pool_dyslipidemia[[ipaq]],
                  conf.int = TRUE,
                  conf.level = 0.95)

# rename column for exposure
names(dyslipidemia_pa)[names(dyslipidemia_pa) == "term"] <- "Exposure"

# calculate Hazard Ratio
dyslipidemia_pa$"exp(Beta)" <- exp(dyslipidemia_pa$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
dyslipidemia_pa$"exp(Beta)_2.5%" <- exp(dyslipidemia_pa$`2.5 %`)
dyslipidemia_pa$"exp(Beta)_97.5%" <- exp(dyslipidemia_pa$`97.5 %`)

# rename column for betas
names(dyslipidemia_pa)[names(dyslipidemia_pa) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(dyslipidemia_pa)[names(dyslipidemia_pa) == "2.5 %"] <- "Beta_2.5%"
names(dyslipidemia_pa)[names(dyslipidemia_pa) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

# t statistic test using pooled estimate and pooled variance (t)
tstat <- pool_dyslipidemia[[ipaq]]$pooled$estimate / sqrt(pool_dyslipidemia[[ipaq]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_dyslipidemia[[ipaq]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_dyslipidemia[[ipaq]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
dyslipidemia_pa <- cbind(dyslipidemia_pa, p_table)

# test to make sure the rows didn't get mixed up
all.equal(dyslipidemia_pa$Exposure, dyslipidemia_pa$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
dyslipidemia_pa$p.value <- ifelse(dyslipidemia_pa$p.value == 0,
                            dyslipidemia_pa$p.value.full,
                            dyslipidemia_pa$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(dyslipidemia_pa[which(dyslipidemia_pa$p.value == 0), ]))


### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
dyslipidemia_pa <- dyslipidemia_pa[!grepl("recruitment_age", dyslipidemia_pa$Exposure), ]
dyslipidemia_pa <- dyslipidemia_pa[!grepl("sexMale", dyslipidemia_pa$Exposure), ]
dyslipidemia_pa <- dyslipidemia_pa[!grepl("recruitment_centre", dyslipidemia_pa$Exposure), ]
dyslipidemia_pa <- dyslipidemia_pa[!grepl("hshld_income", dyslipidemia_pa$Exposure), ]
dyslipidemia_pa <- dyslipidemia_pa[!grepl("education_years", dyslipidemia_pa$Exposure), ]
dyslipidemia_pa <- dyslipidemia_pa[!grepl("ethnicity", dyslipidemia_pa$Exposure), ]
dyslipidemia_pa <- dyslipidemia_pa[!grepl("smoking_status", dyslipidemia_pa$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
dyslipidemia_pa$Exposure <- gsub(".L", "", dyslipidemia_pa$Exposure, fixed = TRUE)

### covars

# extract model summaries from just the first one, since they're all identical
dyslipidemia_covars <- summary(pool_dyslipidemia[covars][[1]],
                      conf.int = TRUE,
                      conf.level = 0.95)

# rename column for exposure
names(dyslipidemia_covars)[names(dyslipidemia_covars) == "term"] <- "Exposure"

# calculate Hazard Ratio
dyslipidemia_covars$"exp(Beta)" <- exp(dyslipidemia_covars$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
dyslipidemia_covars$"exp(Beta)_2.5%" <- exp(dyslipidemia_covars$`2.5 %`)
dyslipidemia_covars$"exp(Beta)_97.5%" <- exp(dyslipidemia_covars$`97.5 %`)

# rename column for betas
names(dyslipidemia_covars)[names(dyslipidemia_covars) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(dyslipidemia_covars)[names(dyslipidemia_covars) == "2.5 %"] <- "Beta_2.5%"
names(dyslipidemia_covars)[names(dyslipidemia_covars) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

tstat <- pool_dyslipidemia[covars][[1]]$pooled$estimate / sqrt(pool_dyslipidemia[covars][[1]]$pooled$t)
# calculate p-values
p.val <- as.data.frame(2 * pt(-abs(tstat), df = pool_dyslipidemia[covars][[1]]$pooled$df))
# create df in p table
p_table <- data.frame(matrix(NA, nrow = nrow(p.val), ncol = 2))
# fill in p table
p_table$X2 <- p.val[[1]]
# add in variable names
p_table$X1 <- pool_dyslipidemia[covars][[1]]$pooled$term

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
dyslipidemia_covars <- cbind(dyslipidemia_covars, p_table)

# test to make sure the rows didn't get mixed up
all.equal(dyslipidemia_covars$Exposure, dyslipidemia_covars$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
dyslipidemia_covars$p.value <- ifelse(dyslipidemia_covars$p.value == 0,
                            dyslipidemia_covars$p.value.full,
                            dyslipidemia_covars$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:",
      nrow(dyslipidemia_covars[which(dyslipidemia_covars$p.value == 0), ]))

### Remove covariate estimates

# remove the unwanted rows with coefficients for the covariates from each model
dyslipidemia_covars <- dyslipidemia_covars[!grepl("recruitment_age", dyslipidemia_covars$Exposure), ]
dyslipidemia_covars <- dyslipidemia_covars[!grepl("sexMale", dyslipidemia_covars$Exposure), ]
dyslipidemia_covars <- dyslipidemia_covars[!grepl("smoking_status", dyslipidemia_covars$Exposure), ]
dyslipidemia_covars <- dyslipidemia_covars[!grepl("IPAQ_activity_group", dyslipidemia_covars$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
dyslipidemia_covars$Exposure <- gsub(".L", "", dyslipidemia_covars$Exposure, fixed = TRUE)

### Merge

# list of 4 output dfs
dfs <- list(dyslipidemia_rest, dyslipidemia_smoke, dyslipidemia_pa, dyslipidemia_covars)

# merge with rbind
dyslipidemia_total <- as.data.frame(do.call(rbind, dfs))

### Categories 

## map variable names to results
dyslipidemia_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_daily_intake" to "alcohol_daily_intakeDaily or almost daily")
for(j in seq_along(variables)) {
  dyslipidemia_total$Variable[dyslipidemia_total$Exposure %in% dyslipidemia_total$Exposure[substring(
    dyslipidemia_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
dyslipidemia_total <- merge(dyslipidemia_total,  
                      subset(categories, select = c("Variable", "Category")), 
                      by = "Variable", 
                      all = F, 
                      sort = F)

### FDR 

## calculate FDR in the discovery analyses using benjamini-hochberg method
dyslipidemia_total$FDR <- p.adjust(dyslipidemia_total$p.value, 
                          method = "BH")

### Save 

# Re-order columns
cs_dyslipidemia_total <- subset(dyslipidemia_total,
                           select = c("Exposure",
                                      "Beta",
                                      "Beta_2.5%",
                                      "Beta_97.5%",
                                      "exp(Beta)",
                                      "exp(Beta)_2.5%",
                                      "exp(Beta)_97.5%",
                                      "p.value",
                                      "FDR",
                                      "std.error",
                                      "statistic",
                                      "df",
                                      "Variable",
                                      "Category"
                           ))


### output results
options(scipen = 999)
# subset results to columns for table
cs_dyslipidemia_table <- 
    subset(dyslipidemia_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "exp(Beta)",
                      "exp(Beta)_2.5%",
                      "exp(Beta)_97.5%",
                      "Beta",
                      "Beta_2.5%",
                      "Beta_97.5%",
                      "p.value",
                      "FDR"))

# make column for replicated yes/no
cs_dyslipidemia_table$Significant <- 
    ifelse(cs_dyslipidemia_table$FDR < 0.05,
           "Yes",
           "No")

# make nicer column names
colnames(cs_dyslipidemia_table) <-
    c("Exposure",
      "Variable",
      "Category",
      "Hazard Ratio",
      "HR 2.5% CI",
      "HR 97.5% CI",
      "Beta",
      "Beta 2.5% CI",
      "Beta 97.5% CI",
      "P-value",
      "FDR",
      "Significant"
    )


# add to list of results
disease_results[[28]] <- cs_dyslipidemia_table
```

# save all results

```{r save, eval=FALSE}

save(
    disease_results,
    sample_sizes,
    file = paste0(paste0(paste0(path, "/results/incident disease/all_disease_analysis_output_with_cs_"), date), "_all_sexes.RData"))

```



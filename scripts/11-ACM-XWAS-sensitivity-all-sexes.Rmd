
# Disease sensitivity analysis - re-testing significant XWAS exposures in those with no disease at baseline 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(results = 'asis')
```

```{r path}
path <- "/Users/austin.argentieri/OneDrive - Nexus365/DPhil Research/UKB/Analysis projects/ACM EWAS 2021"
```

```{r load}
# load analysis datasets
load(paste0(path, "/datasets/ACM_final_analysis_datasets_feb_16_2022.RData"))

# load NCD data
load("/Users/austin.argentieri/OneDrive - Nexus365/DPhil Research/UKB/Datasets/6. Outcome data/ID_and_NCD_may_15_2021.RData")

# load XWAS results
load(paste0(path,"/results/full cohort/ACM_XWAS_results_feb_22_2022_all_sexes.RData"))

# load data dictionary to assign variable categories
categories <- read.csv("/Users/austin.argentieri/OneDrive - Nexus365/DPhil Research/UKB/Data dictionaries/Argentieri UKB dataset data dictionary.csv")
```

```{r combining_sex_datasets}

# get vector of common columns (vars) between men and women
common_cols <- intersect(colnames(mult_disc[[1]]), colnames(fmult_disc[[1]]))

# function to subset datasets to common columns
common_col_subset <- function(x) {
    x <- x[common_cols]
    return(x)
}

# run in datasets
mult_disc_common <- lapply(mult_disc, common_col_subset)
mult_rep_common <- lapply(mult_rep, common_col_subset)
fmult_disc_common <- lapply(fmult_disc, common_col_subset)
fmult_rep_common <- lapply(fmult_rep, common_col_subset)

# rbind male and female discovery datasets
discovery_combined <- as.list(seq_along(mult_disc))
for (k in seq_along(discovery_combined)) {
    discovery_combined[[k]] <- rbind(mult_disc_common[[k]],
                                     fmult_disc_common[[k]])
}

# rbind male and female replication datasets
replication_combined <- as.list(seq_along(mult_rep))
for (k in seq_along(replication_combined)) {
    replication_combined[[k]] <- rbind(mult_rep_common[[k]],
                                       fmult_rep_common[[k]])
}

```

```{r merge_disease_data}

# merge ICD-10 data with ACM datasets
discovery_sensitivity <- lapply(discovery_combined, function(x)
    as.data.frame(
        merge(x, 
              dat_all,
              by = "eid",
              all = FALSE,
              sort = FALSE)
    )
)

replication_sensitivity <- lapply(replication_combined, function(x)
    as.data.frame(
        merge(x, 
              dat_all,
              by = "eid",
              all = FALSE,
              sort = FALSE)
    )
)

# function to code baseline disease indicator
identify_prev_disease <- function(x) {
  
    # define all participants with NCD diagnosis before or equal to recruitment date
    baseline_ncd <- which(x$NCD_censor_date <= x$recruitment_date)
    
    # creating health indicator for baseline disease in total population
    x$baseline_disease_indicator <- NA
    x$baseline_disease_indicator[baseline_ncd] <- 1
    x$baseline_disease_indicator[which(x$bronchitis_emphysema_diagnosis == "Yes")] <- 1
    x$baseline_disease_indicator[which(x$cancer_diagnosis == "Yes")] <- 1
    x$baseline_disease_indicator[which(x$diabetes_diagnosis == "Yes")] <- 1
    x$baseline_disease_indicator[which(x$heart_attack_diagnosis == "Yes")] <- 1
    x$baseline_disease_indicator[which(x$stroke_diagnosis == "Yes")] <- 1
    x$baseline_disease_indicator[which(x$number_cancers > 0)] <- 1
    x$baseline_disease_indicator[which(is.na(x$baseline_disease_indicator))] <- 0
    x$baseline_disease_indicator <- factor(x$baseline_disease_indicator)
    
    return(x)
}

# run function in each dataset
discovery_sensitivity <- lapply(discovery_sensitivity, identify_prev_disease)
replication_sensitivity <- lapply(replication_sensitivity, identify_prev_disease)

```

```{r XWAS, eval=FALSE}

library(survival)
library(mice)
library(Hmisc)
library(pbapply)
library(data.table)

# set global R options
options(scipen = 999) # turn off scientific notation
pboptions(type = "timer", char = "=") # initialize progress bar

### Setting exposures -------------------------------------------------------------------

# create vector of exposures (only variables replicated in the main XWAS)
exposures <- XWAS_total[which(XWAS_total$FDR.rep < 0.05), ]
exposures <- unique(exposures$Variable)

# add in categories to sort
exposures <- as.data.frame(exposures) # create df from exposure list
summary <- merge(exposures,
                 categories,
                 by.x = "exposures",
                 by.y = "Variable",
                 all = F) # merge with categories
summary <- summary[order(summary$Category), ] # order exposures by category

# get vector of just exposure names
exposures <- as.vector(summary$exposures) # make final vector of exposures ordered by category

### Subset datasets -------------------------------------------------------------------

# subset to those without disease at baseline
discovery_sensitivity <- lapply(discovery_sensitivity, function(x) {
    x <- x[which(x$baseline_disease_indicator == 0), ]
    return(x)
}
)

# subset to those without disease at baseline
replication_sensitivity <- lapply(replication_sensitivity, function(x) {
    x <- x[which(x$baseline_disease_indicator == 0), ]
    return(x)
}
)

### Survival variables -------------------------------------------------------------------

# create age at censoring variables for age-at-risk analysis - discovery
for(j in seq_along(discovery_sensitivity)) {
    # divide survival time (days) by 365.25 to get time in years
    discovery_sensitivity[[j]]$time <- 
        # change to numeric because survival time is a difftime object
        as.numeric(discovery_sensitivity[[j]]$ACM_survival_time / 365.25) 
    
    # add time (years) to recruitment age to get censor age
    discovery_sensitivity[[j]]$censor_age <-
        discovery_sensitivity[[j]]$recruitment_age + discovery_sensitivity[[j]]$time 
}

# create age at censoring variables for age-at-risk analysis - discovery
for(j in seq_along(replication_sensitivity)) {
    # divide survival time (days) by 365.25 to get time in years
    replication_sensitivity[[j]]$time <- 
        # change to numeric because survival time is a difftime object
        as.numeric(replication_sensitivity[[j]]$ACM_survival_time / 365.25) 
    
    # add time (years) to recruitment age to get censor age
    replication_sensitivity[[j]]$censor_age <-
        replication_sensitivity[[j]]$recruitment_age + replication_sensitivity[[j]]$time 
}

### Create 5-year birth cohorts -------------------------------------------------------------------

# function to calculate birth cohorts
split_birth_year <- function(x){
  x$birth_cohort <- ifelse(
    x$birth_year >= 1935 & x$birth_year < 1940,
    "1935-1940",
    ifelse(
      x$birth_year >= 1940 & x$birth_year < 1945,
      "1940-1945",
      ifelse(
        x$birth_year >= 1945 & x$birth_year < 1950,
        "1945-1950",
        ifelse(
          x$birth_year >= 1950 & x$birth_year < 1955,
          "1950-1955",
          ifelse(
            x$birth_year >= 1955 & x$birth_year < 1960,
            "1955-1960",
            ifelse(
              x$birth_year >= 1960 & x$birth_year < 1965,
              "1960-1965",
              ifelse(
                x$birth_year >= 1965 & x$birth_year <= 1970, 
                "1965-1970", 
                NA
              )
            )
          )
        )
      )
    )
  )
  
  x$birth_cohort <- as.factor(x$birth_cohort)
  return(x)
}

# execute function across imputed datasets to create 5-year age bands
discovery_sensitivity <- lapply(discovery_sensitivity, split_birth_year)
replication_sensitivity <- lapply(replication_sensitivity, split_birth_year)

### Scale -------------------------------------------------------------------

# scale function
scale_numeric <- function(x) { 
  # create logical vector of numeric columns
  nums <- sapply(x, is.numeric)
  
  # list of numeric variables to exclude from scaling
  scale_exclude <- c(
    Cs(
      recruitment_age,
      censor_age,
      ACM_event_indicator,
      eid,
      time,
      ACM_survival_time,
      hazard,
      birth_year
    )
  )
  
  # exclude those columns I don't want to scale
  nums[names(nums) %in% scale_exclude] <- FALSE # don't want to scale these
  
  # perform scale
  x[nums] <- scale(x[nums],
                   scale = TRUE)
  
  # return entire dataset
  return(x)
}

# scale desired numeric columns
discovery_sensitivity <- lapply(discovery_sensitivity, scale_numeric)
replication_sensitivity <- lapply(replication_sensitivity, scale_numeric)

### Ordinal contrasts -------------------------------------------------------------------

# overriding default polynomial contrasts to only return linear contrasts
set_contrasts <- function(x) {

  # find ordered variables
  ord <- sapply(x, is.ordered)

  # set contrasts to only linear
  for (k in seq(ncol(x[ord]))) {
    contrasts(x[ord][[k]], how.many = 1) <- contr.poly(nlevels(x[ord][[k]]))
  }

  return(x)

}

# run in datasets
discovery_sensitivity <- lapply(discovery_sensitivity, set_contrasts)
replication_sensitivity <- lapply(replication_sensitivity, set_contrasts)

### XWAS -------------------------------------------------------------------

## functions

# discovery
model_disc <- function(x) {
  lapply(discovery_sensitivity, function(y)
    coxph(as.formula(
      paste0(
          "Surv(recruitment_age, censor_age, ACM_event_indicator) ~
             strata(birth_cohort, sex) + 
             recruitment_centre + education_years + hshld_income + ethnicity + ",
        x
      )
    ), data = y)
  )
}

# replication
model_rep <- function(x) {
  lapply(replication_sensitivity, function(y)
    coxph(as.formula(
      paste0(
          "Surv(recruitment_age, censor_age, ACM_event_indicator) ~
             strata(birth_cohort, sex) + 
             recruitment_centre + education_years + hshld_income + ethnicity + ",
        x
      )
    ), data = y)
  )
}


## discovery XWAS
models_disc <- as.list(seq(1,length(exposures))) # create list to store model results
models_disc <- pblapply(exposures, model_disc)

## replication XWAS
models_rep <- as.list(seq(1,length(exposures))) # create list to store model results
models_rep <- pblapply(exposures, model_rep)

### Pool -------------------------------------------------------------------

## pool discovery XWAS
pool_disc <- as.list(seq(1,length(exposures))) # create list to store pool results

for(j in seq_along(exposures)) {
  pool_disc[[j]] <- pool(models_disc[[j]])
}

## pool replication XWAS
pool_rep <- as.list(seq(1,length(exposures))) # create list to store pool results

for(j in seq_along(exposures)) {
  pool_rep[[j]] <- pool(models_rep[[j]])
}


### Summaries -------------------------------------------------------------------

# get list of summaries for all pooled models (with beta)
smry_disc <-lapply(pool_disc,
                   summary,
                   conf.int = TRUE,
                   conf.level = 0.95)

smry_rep <- lapply(pool_rep,
                   summary,
                   conf.int = TRUE,
                   conf.level = 0.95)

# extract all model summaries from the lists and convert to single data frame of estimates
allvars_disc <- rbindlist(smry_disc)
allvars_rep <- rbindlist(smry_rep)

# rename column for exposure
names(allvars_disc)[names(allvars_disc) == "term"] <- "Exposure"
names(allvars_rep)[names(allvars_rep) == "term"] <- "Exposure"

# calculate Hazard Ratio
allvars_disc$Hazard.Ratio <- exp(allvars_disc$estimate)
allvars_rep$Hazard.Ratio <- exp(allvars_rep$estimate)

# exponentiate beta 95% CIs for HR 95% CIs
allvars_disc$"HR_2.5%" <- exp(allvars_disc$`2.5 %`)
allvars_disc$"HR_97.5%" <- exp(allvars_disc$`97.5 %`)

allvars_rep$"HR_2.5%" <- exp(allvars_rep$`2.5 %`)
allvars_rep$"HR_97.5%" <- exp(allvars_rep$`97.5 %`)

# rename column for betas
names(allvars_disc)[names(allvars_disc) == "estimate"] <- "Beta"
names(allvars_rep)[names(allvars_rep) == "estimate"] <- "Beta"

# rename column for beta 95% CIs
names(allvars_disc)[names(allvars_disc) == "2.5 %"] <- "Beta_2.5%"
names(allvars_disc)[names(allvars_disc) == "97.5 %"] <- "Beta_97.5%"

names(allvars_rep)[names(allvars_rep) == "2.5 %"] <- "Beta_2.5%"
names(allvars_rep)[names(allvars_rep) == "97.5 %"] <- "Beta_97.5%"

### Getting accurate p-values  -------------------------------------------------------------------

### using summary on a mipo object (output from the pool function) rounds very small p-values to 0
### even when we set the # of digits to the max in R (22)
### so we have to hard code the math to get the p-values manually from the mipo object

## discovery 
tstat <- as.list(seq(1,length(pool_disc))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_disc))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_disc))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_disc)) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_disc[[j]]$pooled$estimate / sqrt(pool_disc[[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_disc[[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_disc[[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
allvars_disc <- cbind(allvars_disc, p_table)

# test to make sure the rows didn't get mixed up
all.equal(allvars_disc$Exposure, allvars_disc$Exposure.p.table)

# replace all 0 p-values from pooling with actual value
allvars_disc$p.value <- ifelse(allvars_disc$p.value == 0, 
                            allvars_disc$p.value.full,
                            allvars_disc$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(allvars_disc[which(allvars_disc$p.value == 0), ]))
      
## replication 
tstat <- as.list(seq(1,length(pool_rep))) # create list to store t stats
p.val <- as.list(seq(1,length(pool_rep))) # create list to store p-values
p_table <- as.list(seq(1,length(pool_rep))) # create list to p table dfs
  
# loop to calculate p-values and create table of results
for (j in seq_along(pool_rep)) {
  # t statistic test using pooled estimate and pooled variance (t)
  tstat[[j]] <- pool_rep[[j]]$pooled$estimate / sqrt(pool_rep[[j]]$pooled$t)
  # calculate p-values
  p.val[[j]] <- as.data.frame(2 * pt(-abs(tstat[[j]]), df = pool_rep[[j]]$pooled$df))
  # create df in p table
  p_table[[j]] <- data.frame(matrix(NA, nrow = nrow(p.val[[j]]), ncol = 2))
  # fill in p table
  p_table[[j]]$X2 <- p.val[[j]][[1]]
  # add in variable names
  p_table[[j]]$X1 <- pool_rep[[j]]$pooled$term
}

# extract list into a single df
p_table <- rbindlist(p_table)

# change column names
colnames(p_table) <- c("Exposure.p.table",
                       "p.value.full")

# merge p table with XWAS results
allvars_rep <- cbind(allvars_rep, p_table)

# test to make sure the rows didn't get mixed up
all.equal(allvars_rep$Exposure, allvars_rep$Exposure.p.table)

# replace all 0 p-values with actual value
allvars_rep$p.value <- ifelse(allvars_rep$p.value == 0, 
                           allvars_rep$p.value.full,
                           allvars_rep$p.value)

# test to see if any 0 p-values remain
paste("number of p-values rounded to 0:", 
      nrow(allvars_rep[which(allvars_rep$p.value == 0), ]))

### Remove covariate estimates ------------------------------------------------

# remove the unwanted rows with coefficients for the covariates from each model
# will need to add more lines if more covariates are used
# strata terms (birth_cohort) are not listed in output and don't need removing

allvars_disc <- allvars_disc[!grepl("recruitment_centre", allvars_disc$Exposure), ]
allvars_rep <- allvars_rep[!grepl("recruitment_centre", allvars_rep$Exposure), ]

allvars_disc <- allvars_disc[!grepl("hshld_income", allvars_disc$Exposure), ]
allvars_rep <- allvars_rep[!grepl("hshld_income", allvars_rep$Exposure), ]

allvars_disc <- allvars_disc[!grepl("education_years", allvars_disc$Exposure), ]
allvars_rep <- allvars_rep[!grepl("education_years", allvars_rep$Exposure), ]

allvars_disc <- allvars_disc[!grepl("ethnicity", allvars_disc$Exposure), ]
allvars_rep <- allvars_rep[!grepl("ethnicity", allvars_rep$Exposure), ]

# remove ".L" from exposure names for ordinal variables - need to do after p-value step above
allvars_disc$Exposure <- gsub(".L", "", allvars_disc$Exposure, fixed = TRUE)
allvars_rep$Exposure <- gsub(".L", "", allvars_rep$Exposure, fixed = TRUE)

### Categories -------------------------------------------------------------------

# get p-value column from replication set to merge
rep <- subset(allvars_rep, select = c("Exposure", 
                                   "p.value")) # subset replication results to just p-values
names(rep)[names(rep) == "p.value"] <- "p.value.rep" # re-name p-values to differentiate from discovery

## merge disc and rep, keeping estimates just from discovery
allvars_total <- merge(allvars_disc, 
                       rep, 
                       by = "Exposure", 
                       all = T, 
                       sort = F)

## map variable names to results
allvars_total$Variable <- NA
# create vector of variable names
variables <- sort(as.vector(summary$exposures)) 

# add variable names based on partial match with XWAS output exposure column with variable response level 
# (e.g., match "alcohol_freq" to "alcohol_freqDaily or almost daily")
for(j in seq_along(variables)) {
  allvars_total$Variable[allvars_total$Exposure %in% allvars_total$Exposure[substring(
    allvars_total$Exposure,
    1,
    nchar(variables[[j]])) == variables[[j]]]] <- variables[[j]]
}

## add in categories according to match with variable name
allvars_total <- merge(allvars_total,  
                       subset(categories, select = c("Variable", "Category")), 
                       by = "Variable", 
                       all = F, 
                       sort = F)

### Separate exposome -------------------------------------------------------------

## get row positions for non-exposome exposures
non_exposome_exp <- which(
        allvars_total$Exposure %in% 
        c("accommodation_typeSheltered accommodation",
          "diet_change_5yrsYes, because of illness") 
)

## subset results to exposome
XWAS_total <- allvars_total[-non_exposome_exp]

### Exposome FDR -------------------------------------------------------------------

## calculate FDR in the discovery analyses using benjamini-hochberg method
XWAS_total$FDR.disc <- p.adjust(XWAS_total$p.value, 
                                method = "BH")

## calculate FDR in the replication analyses only among those from the discovery with FDR p-value < 0.05
exposome_rep <- subset(XWAS_total, select = c("Exposure", 
                                              "FDR.disc",
                                              "p.value.rep"))

# subset to associations that were significant after FDR in discovery
sig <- exposome_rep[which(exposome_rep$FDR.disc < 0.05), ] 

# calculate FDR on replication p-values only for significant variables in discovery
sig$FDR.rep <- p.adjust(sig$p.value.rep, 
                        method = "BH") 

# subset replication results to just FDR p-values
sig <- subset(sig, select = c("Exposure", 
                              "FDR.rep")) 

## recombine FDR p-values from replication with discovery results
XWAS_total <- merge(XWAS_total, 
                    sig, 
                    by = "Exposure", 
                    all = T, 
                    sort = F)

### Save -------------------------------------------------------------------

# Re-order columns
XWAS_total <- subset(XWAS_total,
                     select = c("Exposure",
                                "Beta",
                                "Beta_2.5%",
                                "Beta_97.5%",
                                "Hazard.Ratio",
                                "HR_2.5%",
                                "HR_97.5%",
                                "p.value",
                                "FDR.disc",
                                "FDR.rep",
                                "std.error",
                                "statistic",
                                "df",
                                "Variable",
                                "Category"
                     ))

# save
save(pool_disc,
     pool_rep,
     allvars_disc, 
     allvars_rep,
     allvars_total,
     XWAS_total,
     model_disc,
     model_rep,
     exposures,
     file = paste0(path,"/results/healthy subset/ACM_XWAS_sensitivity_results_feb_22_2022_all_sexes.RData"))

```

```{r comparison_plot}
library(plotly)
library(ggplot2)
library(htmlwidgets)
library(ggpubr)

options(scipen = 999)

# load color palette
load(paste0(path,"/results/color_palette.RData"))

# load full results
load(paste0(path,"/results/full cohort/ACM_XWAS_results_feb_22_2022_all_sexes.RData"))

# rename
full_XWAS_total <- XWAS_total

#load healthy subset results
load(paste0(path,"/results/healthy subset/ACM_XWAS_sensitivity_results_feb_22_2022_all_sexes.RData"))

# merge
plots_df <- merge(full_XWAS_total, 
                  XWAS_total,
                  by = "Exposure",
                  all = TRUE,
                  sort = FALSE)

# merge categories for plot
plots_df$Category <- ifelse(!is.na(plots_df$Category.x),
                            plots_df$Category.x,
                            plots_df$Category.y)

color_map$color[which(color_map$sequence == "Stressful life events")] <- 
    color_map$color[which(color_map$sequence == "General health")]

color_map$sequence[which(color_map$sequence == "Medications")] <- "Supplements"
color_map$color[which(color_map$sequence == "Supplements")] <- 
    color_map$color[which(color_map$sequence == "Urine biomarkers")]

# merge color map with plots df
plots_df <- merge(plots_df, 
                  color_map, 
                  by.x = "Category",
                  by.y = "sequence", 
                  all = F)

# add in grey/black color for non-significant points
plots_df$color <- ifelse((plots_df$FDR.rep.x > 0.05 |
                             is.na(plots_df$FDR.rep.x)) &
                             (plots_df$FDR.rep.y > 0.05 |
                             is.na(plots_df$FDR.rep.y)),
                         "#4c4c4c",
                         plots_df$color)

# add in red color for points only significant in full cohort
plots_df$color[which(plots_df$FDR.rep.x < 0.05 &
                         (plots_df$FDR.rep.y > 0.05 |
                              is.na(plots_df$FDR.rep.y)))] <- "#cc0610"

# add in red color for points only significant in healthy subset
plots_df$color[which(plots_df$FDR.rep.y < 0.05 &
                         (plots_df$FDR.rep.x > 0.05 |
                              is.na(plots_df$FDR.rep.x)))] <- "#012380"

# add in "non-significant" category for plots
plots_df$Category <- ifelse(plots_df$color == "#4c4c4c",
                            "* Non-significant",
                            plots_df$Category)

# add in "non-significant" category for plots
plots_df$Category <- ifelse(plots_df$color == "#cc0610",
                            "* Only replicated in full cohort",
                            plots_df$Category)

# add in "non-significant" category for plots
plots_df$Category <- ifelse(plots_df$color == "#012380",
                            "* Only replicated in healthy subset",
                            plots_df$Category)

names(plots_df)[names(plots_df) == "Hazard.Ratio.x"] <- "Hazard.Ratio.Full.Cohort"
names(plots_df)[names(plots_df) == "Hazard.Ratio.y"] <- "Hazard.Ratio.Healthy.Subset"

# re-order so that black dots are behind colored dots
plots_df <- plots_df[order(plots_df$Category), ]

# correlation coefficient between men and women
hr_corr <- cor(plots_df$Hazard.Ratio.Full.Cohort, 
               plots_df$Hazard.Ratio.Healthy.Subset)

# regression line for plot
hazard.ratio.lm <- lm(Hazard.Ratio.Healthy.Subset ~ Hazard.Ratio.Full.Cohort, plots_df)

# ggplot
comp_plot <- 
    ggplot(
        plots_df,
        aes(x = Hazard.Ratio.Full.Cohort, 
            y = Hazard.Ratio.Healthy.Subset, 
            label = Exposure
        )) + 
    geom_point(
        aes(color = Category),
        size = 3) + 
    scale_color_manual(values = unique(plots_df$color)) +
    ggtitle("Comparison of Mortality XWAS Hazard Ratios in the UK Biobank - Full Cohort vs. Healthy Subset") +
    labs(x = "Full cohort",
         y = "No disease at baseline") +
    theme_classic(base_size = 18) +
    # theme(legend.position = "none") +
    geom_hline(yintercept = 1, 
               color = "gray", 
               linetype = "dashed") + 
    geom_vline(xintercept = 1, 
               color = "gray", 
               linetype = "dashed") +
    # breaks have function to only use integers and no decimals for axis values
    scale_x_continuous(breaks = function(x) seq(ceiling(x[1]), floor(x[2]), by = 1)) +
    scale_y_continuous(breaks = function(x) seq(ceiling(x[1]), floor(x[2]), by = 1)) +
    # show correlation coefficient between hazard ratios and p-value for correlation
    stat_cor(method = "pearson",
             label.x.npc = "center",
             label.y.npc = "bottom",
             p.digits = 5,
             size = 6) +
    # show regression line between hazard ratios
    geom_abline(slope = coef(hazard.ratio.lm)[[2]], 
                intercept = coef(hazard.ratio.lm)[[1]],
                color = "red")

# save
ggsave(comp_plot, 
       filename = paste0(path, "/output/healthy subset/ACM_XWAS_sensitivity_feb_22_2022_all_sexes.png"), width = 15, height = 10)

# text styling for plotly
t <- list(family = "sans-serif",
          size = 18,
          color = 'black')

# plotly interactive plot
fig <- ggplotly(comp_plot, 
                tooltip = c("x", 
                            "y", 
                            "label")) %>% 
  layout(title = "Comparison of Mortality XWAS Hazard Ratios in the Biobank - Full Cohort vs. Healthy Subset", 
         font = t)

hide_legend(fig) 

# save HTML
saveWidget(fig, 
           file = paste0(path, "/output/healthy subset/html/ACM_XWAS_sensitivity_feb_22_2022_all_sexes.html"))
```

```{r summary_table}
load(paste0(path,"/results/healthy subset/ACM_XWAS_sensitivity_results_feb_22_2022_all_sexes.RData"))

library(DT)

# number of replicated exposures
hits <- nrow(XWAS_total[!is.na(XWAS_total$FDR.rep) & 
                        XWAS_total$FDR.rep < 0.05, ])

disc <- length(unique(XWAS_total$Variable[which(XWAS_total$FDR.disc < 0.05)]))
rep <- length(unique(XWAS_total$Variable[which(XWAS_total$FDR.rep < 0.05)]))
vars <- length(unique(XWAS_total$Variable))

# create dataframe of replicated vs. non-replicated
numbers <- c(nrow(XWAS_total), vars, disc, rep, hits, rep/vars)
labels <- c("Number of tests",
            "Number of unique variables tested",
            "Number of variables significant in discovery",
            "Number of variables significant after replication",
            "Number of significant replicated associations",
            "Percent of variables that were significant after replication")

tab <- data.frame(numbers)
rownames(tab) <- labels
colnames(tab) <- " "

# interactive html table
datatable(tab, 
          options = list(dom = 't'))

```

```{r save_output}

# subset results to columns for table
rep_table <- 
    subset(XWAS_total, 
           select = c("Exposure",
                      "Variable",
                      "Category",
                      "Hazard.Ratio",
                      "HR_2.5%",
                      "HR_97.5%",
                      "p.value",
                      "FDR.disc",
                      "FDR.rep"))

# make column for replicated yes/no
rep_table$Replicated <- 
    ifelse(rep_table$FDR.disc < 0.05 & 
               rep_table$FDR.rep < 0.05,
           "Yes",
           "No")

write.csv(rep_table, file = paste0(path, "/output/healthy subset/ACM_XWAS_sensitivity_output_feb_22_2022_all_sexes.csv"))
datatable(rep_table)
```

```{r count_cases}

nrow(data_male_disc[[1]])
cases <- nrow(data_male_disc[[1]][which(data_male_disc[[1]]$ACM_event_indicator == 1), ])
total <- nrow(data_male_disc[[1]])
mort_rate <- cases/total

nrow(data_male_rep[[1]])
cases <- nrow(data_male_rep[[1]][which(data_male_rep[[1]]$ACM_event_indicator == 1), ])
total <- nrow(data_male_rep[[1]])
mort_rate <- cases/total

```

```{r different_vars}

# make column for replicated yes/no
full_XWAS_total$Replicated <- 
    ifelse(full_XWAS_total$FDR.disc < 0.05 & 
               full_XWAS_total$FDR.rep < 0.05,
           "Yes",
           "No")

## get just replicated variables from full XWAS and sensitivity
sig_vars <- unique(rep_table$Variable[which(rep_table$Replicated == "Yes")])
full_sig_vars <- unique(full_XWAS_total$Variable[which(full_XWAS_total$Replicated == "Yes")])

# get variables replicated in full cohort but not in sensitivity
diff_vars <- full_sig_vars[which(full_sig_vars %nin% sig_vars)]

# get variables not replicated in sensitivity 
non_sig_vars <- unique(rep_table$Variable[which(rep_table$Replicated == "No")])
non_sig_vars <- non_sig_vars[which(non_sig_vars %nin% sig_vars)]
# should be same as diff_vars
all.equal(diff_vars, non_sig_vars)

diff_table <- rep_table[which(rep_table$Variable %in% diff_vars), ]

# save table
write.csv(diff_table, file = paste0(path, "/output/healthy subset/ACM_XWAS_sensitivity_non_sig_vars_feb_22_2022_all_sexes.csv"))

# save variable list
write.csv(non_sig_vars, file = paste0(path, "/output/healthy subset/ACM_XWAS_sensitivity_non_sig_vars_list_feb_22_2022_all_sexes.csv"))

# finding variables significant at p < 0.05, but not FDR significant
nominal_sig_vars <- unique(rep_table$Variable[which(rep_table$p.value < 0.05)])

# variable nominally significant that aren't FDR significant
nominal_sig_vars <- nominal_sig_vars[which(nominal_sig_vars %nin% sig_vars)]

# save variable list
write.csv(nominal_sig_vars, file = paste0(path, "/output/healthy subset/ACM_XWAS_sensitivity_nominal_sig_vars_list_feb_22_2022_all_sexes.csv"))

# find variables significant at p < 0.05 in discovery analysis
disc_nominal_sig_vars <- unique(rep_table$Variable[which(rep_table$p.value < 0.05)])
disc_FDR_sig_vars <- unique(rep_table$Variable[which(rep_table$FDR.disc < 0.05)])

# compare with variables that were FDR significant
diff3 <- disc_nominal_sig_vars[which(disc_nominal_sig_vars %nin% disc_FDR_sig_vars)]

```



